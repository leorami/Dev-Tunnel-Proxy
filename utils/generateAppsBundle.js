#!/usr/bin/env node
/*
  Compose app configs with proxy-owned overrides into a single generated file
  used by Nginx. Precedence: overrides > apps. No app names are hardcoded.

  Inputs:
    - appsDir:   ./apps/*.conf           (ignored in git; provided by engineers)
    - overrides: ./overrides/*.conf      (generic proxy-owned snippets)

  Output:
    - build/sites-enabled/apps.generated.conf

  Notes:
    - We only emit location blocks and related directives expected inside the
      main server block defined in config/default.conf.
    - Duplicate routes are resolved by keeping the override version and
      skipping conflicting app blocks.
*/

const fs = require('fs');
const path = require('path');

const ROOT_DIR = path.resolve(__dirname, '..');
const APPS_DIR = path.join(ROOT_DIR, 'apps');
const OVERRIDES_DIR = path.join(ROOT_DIR, 'overrides');
const OUTPUT_DIR = path.join(ROOT_DIR, 'build', 'sites-enabled');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'apps.generated.conf');

function readTextFileSafe(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (_err) {
    return null;
  }
}

function listConfFiles(dir) {
  try {
    const entries = fs.readdirSync(dir);
    return entries
      .filter((f) => f.endsWith('.conf') && !f.startsWith('.'))
      .map((f) => path.join(dir, f))
      .sort();
  } catch (_err) {
    return [];
  }
}

function extractLocationBlocksWithText(text) {
  const blocks = [];
  if (!text) return blocks;

  // Find each "location" start and capture until its matching closing brace
  const re = /(^|\n)\s*location\s+([^\{]+)\{/g;
  let match;
  while ((match = re.exec(text)) !== null) {
    // Start at the exact 'l' of the 'location' token
    const locStart = text.indexOf('location', match.index);
    if (locStart === -1) continue;
    // Find the first '{' after 'location'
    const braceOpen = text.indexOf('{', locStart);
    if (braceOpen === -1) continue;
    const pathSpec = match[2].trim();
    // Brace matching starting just after '{'
    let depth = 1;
    let i = braceOpen + 1;
    while (i < text.length && depth > 0) {
      const ch = text[i++];
      if (ch === '{') depth++;
      else if (ch === '}') depth--;
    }
    const bodyEnd = i; // position after the closing brace
    const fullText = text.slice(locStart, bodyEnd);
    const body = text.slice(braceOpen + 1, bodyEnd - 1);
    blocks.push({ pathSpec, body, fullText });
  }
  return blocks;
}

function normalizeLocationPath(pathSpec) {
  const trimmed = pathSpec.trim();
  const noMod = trimmed.replace(/^([=~\^~*]+)\s+/, '');

  if (noMod.startsWith('^/')) {
    if (noMod.match(/\^\/.+\.+/)) return null; // too broad
    const pathMatch = noMod.match(/^\^\/([^\/\(\?\$\*\+\.]+(?:\/[^\/\(\?\$\*\+\.]+)*)/);
    if (pathMatch) {
      const p = pathMatch[1];
      return p.endsWith('/') ? `/${p}` : `/${p}/`;
    }
    return null;
  }

  if (noMod === '/' || noMod === '/_next' || noMod === '/_next/' || noMod.startsWith('/__next')) {
    return null;
  }
  if (noMod.startsWith('/')) {
    if (/\.[A-Za-z0-9]+$/.test(noMod)) return null;
    return noMod.endsWith('/') ? noMod : `${noMod}/`;
  }
  return null;
}

function buildKeySetFromBlocks(blocks) {
  const keys = new Set();
  for (const b of blocks) {
    const exactKey = `raw:${b.pathSpec.trim()}`;
    keys.add(exactKey);
    const normalized = normalizeLocationPath(b.pathSpec);
    if (normalized) keys.add(`norm:${normalized}`);
  }
  return keys;
}

function collectBlocksFromFiles(files) {
  const allBlocks = [];
  for (const file of files) {
    const text = readTextFileSafe(file);
    if (!text) continue;
    const blocks = extractLocationBlocksWithText(text);
    for (const b of blocks) {
      allBlocks.push({ ...b, sourceFile: file });
    }
  }
  return allBlocks;
}

function ensureDirSync(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function main() {
  const appFiles = listConfFiles(APPS_DIR);
  const overrideFiles = listConfFiles(OVERRIDES_DIR);

  const overrideBlocks = collectBlocksFromFiles(overrideFiles);
  const appBlocks = collectBlocksFromFiles(appFiles);

  // Track override keys (raw and normalized) to let overrides win
  const seen = buildKeySetFromBlocks(overrideBlocks);

  // Start composing output
  ensureDirSync(OUTPUT_DIR);

  const lines = [];
  lines.push('# GENERATED FILE - DO NOT EDIT');
  lines.push('# This file is generated by utils/generateAppsBundle.js');
  lines.push(`# Generated at: ${new Date().toISOString()}`);
  lines.push('# Precedence: overrides > apps');
  if (overrideFiles.length > 0) {
    lines.push(`# Overrides: ${overrideFiles.map((f) => path.relative(ROOT_DIR, f)).join(', ')}`);
  }
  if (appFiles.length > 0) {
    lines.push(`# Apps: ${appFiles.map((f) => path.relative(ROOT_DIR, f)).join(', ')}`);
  }
  lines.push('');

  // Emit overrides first, in file order
  for (const b of overrideBlocks) {
    lines.push(b.fullText.trimEnd());
    lines.push('');
  }

  // Emit app blocks unless a conflicting key (raw or normalized) already exists
  for (const b of appBlocks) {
    const pathSpecTrim = b.pathSpec.trim();
    const rawKey = `raw:${pathSpecTrim}`;
    const norm = normalizeLocationPath(b.pathSpec);
    const normKey = norm ? `norm:${norm}` : null;
    // Allow both exact and prefix blocks for same normalized route.
    // Skip if an override already claimed this exact raw path, or an override claimed the normalized path
    // and this is NOT an exact match block.
    if (seen.has(rawKey) || (normKey && seen.has(normKey) && !pathSpecTrim.startsWith('='))) {
      continue;
    }
    // Avoid exact duplicate raws among app blocks, but do not mark normalized key
    if (seen.has(rawKey)) continue;
    seen.add(rawKey);
    lines.push(b.fullText.trimEnd());
    lines.push('');
  }

  fs.writeFileSync(OUTPUT_FILE, lines.join('\n'), 'utf8');
  // eslint-disable-next-line no-console
  console.log(`Wrote ${path.relative(ROOT_DIR, OUTPUT_FILE)}`);
}

if (require.main === module) {
  try {
    main();
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error('generateAppsBundle failed:', err);
    process.exit(1);
  }
}


