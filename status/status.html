<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dev Proxy Status</title>
    <link rel="icon" type="image/svg+xml" href="/status/assets/favicon.svg" />
    <link rel="icon" type="image/png" href="/status/assets/favicon.png" />
    <link rel="shortcut icon" href="/status/assets/favicon.svg" />
    <script>
      // Default the global flag early so handlers never see undefined
      window.__calliopeEnabled = false;
    </script>
    <style>
      :root{--bg:#0c111c;--bg2:#0e1627;--panel:#101827;--panelGlass:rgba(16,24,39,.92);--appBgGlass:rgba(13,20,36,.95);--border:#1f2a44;--muted:#8a9bb7;--text:#e4ecfa;--heading:#cfe0ff;--chip:#1a2440;--chipBg:#132140;--chipBorder:#263455;--chipText:#b8c8e6;--ok:#16c784;--warn:#f59e0b;--err:#ef4444;--lnk:#7fb0ff;--btnBg:rgba(19,42,77,.45);--btnBorder:rgba(58,110,174,.55);--btnText:#cfe0ff;--btnBgHover:rgba(22,52,95,.6);--headerBg:rgba(10,16,30,.55);--codeBg:#0a1223;--codeBorder:#1b2a48;--glowOpacity:.10;--summaryGap:24px}
      :root[data-theme="light"]{--bg:#edf2fb;--bg2:#f7faff;--panel:#ffffff;--panelGlass:rgba(255,255,255,.88);--appBgGlass:rgba(255,255,255,.9);--border:#d6e0f5;--muted:#5b6b8a;--text:#0b1220;--heading:#0b1220;--chip:#e8eefc;--chipBg:#eef2ff;--chipBorder:#cddcff;--chipText:#0b1220;--ok:#0f9d6a;--warn:#b7791f;--err:#c24141;--lnk:#2d6cdf;--btnBg:#eef2ff;--btnBorder:#bfd1ff;--btnText:#0b1220;--btnBgHover:#e2e8ff;--headerBg:rgba(255,255,255,.78);--codeBg:#f6f8ff;--codeBorder:#d6e0f5;--glowOpacity:.14}
      *{box-sizing:border-box}
      body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans}
      header{padding:16px 20px 12px 20px;border-bottom:1px solid var(--border);background:var(--headerBg);backdrop-filter:saturate(180%) blur(10px);position:sticky;top:0;z-index:1000;box-shadow:0 10px 30px rgba(0,0,0,.25)}
      .header-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .header-actions{display:flex;gap:8px;align-items:center}
      header h1{font-size:16px;margin:0;display:flex;gap:10px;align-items:center}
      header h1 span{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--chip);color:var(--text);font-weight:600}
      .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding-top:4px}
      .toolbar.centered{justify-content:center;margin:20px auto 18px}
      .toolbar .field{display:flex;gap:6px;align-items:center}
      .toolbar select,.toolbar input[type="text"]{background:var(--btnBg);border:1px solid var(--btnBorder);color:var(--btnText);border-radius:8px;padding:7px 10px}
      .btn{appearance:none;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600;text-decoration:none;text-align:center;backdrop-filter:saturate(160%) blur(6px);box-shadow:inset 0 1px 0 rgba(255,255,255,.05), 0 4px 18px rgba(0,0,0,.25)}
      .btn:hover{background:var(--btnBgHover)}
      .btn:active{transform:translateY(1px)}
      .btn.copied{background:#16402b;border-color:#2a7f54;color:#a6f3cc}
      .content{width: 100%}
      .container{max-width:1100px;margin:16px 16px}
      .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-bottom:16px}
      .summaryRow{position:sticky;top:calc(var(--headerH, 64px) + var(--summaryGap, 12px));z-index:2004;background:var(--headerBg);backdrop-filter:saturate(180%) blur(8px);border-radius: 12px;}
      .appsHeader{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;background:var(--headerBg);border:1px solid var(--border);border-radius:10px;padding:8px 12px}
      .appsHeader .toolbar{padding-top:0}
      .card{background:var(--panelGlass);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25);backdrop-filter:saturate(160%) blur(6px);transition:box-shadow .12s ease; font-size: 12px}
      .card:hover{box-shadow:0 10px 28px rgba(0,0,0,.30)}
      .card h2{margin:0 0 10px 0;font-size:14px;color:var(--heading);letter-spacing:.2px; padding: 0 0 8px 0}
      .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
      .apps-controls{justify-content:flex-start}
      .field{display:inline-block;margin-right:10px}
      .label{color:var(--muted)}
      .value{font-weight:600}
      .ok{color:var(--ok)}.warn{color:var(--warn)}.err{color:var(--err)}
      .apps{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
      /* Inside a source column, each app card should span full column width (one per row) */
      .card .apps{grid-template-columns:1fr}
      .app{background:var(--appBgGlass);border:1px solid var(--border);border-radius:10px;padding:12px;transition:transform .12s ease, box-shadow .12s ease;box-shadow:inset 0 1px 0 rgba(255,255,255,.02);position:relative}
      .app:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .app.ok{border-color:rgba(22,199,132,.7);box-shadow:0 0 0 2px rgba(22,199,132,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.warn{border-color:rgba(245,158,11,.7);box-shadow:0 0 0 2px rgba(245,158,11,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.err{border-color:rgba(239,68,68,.8);box-shadow:0 0 0 2px rgba(239,68,68,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app .route{font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
      .groupHead{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .groupHead .chips{gap:6px}
      .groupHead .btn-small{font-size:12px;padding:6px 10px}
      .chip{display:inline-flex;gap:6px;align-items:center;padding:5px 8px;border-radius:999px;background:var(--chipBg);border:1px solid var(--chipBorder);color:var(--chipText);position:relative}
      .chip.ok{background:rgba(22,199,132,.12);border-color:rgba(22,199,132,.35);color:#8ef0c3}
      .chip.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.35);color:#ffd38a}
      .chip.err{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:#ffb1b1}
      .chip[data-tip]:hover:after{content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:calc(100% + 8px);white-space:pre-wrap;max-width:280px;background:#0a1223;color:#d9e2f1;border:1px solid #1b2a48;border-radius:8px;padding:8px;box-shadow:0 10px 30px rgba(0,0,0,.45);z-index:30}
      .chip[data-tip]:hover:before{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:100%;border:6px solid transparent;border-top-color:#1b2a48}
      .chip a{color:var(--lnk);text-decoration:none}
      .view{margin-top:12px}
      pre{margin:0;background:var(--codeBg, #0a1223);border:1px solid var(--codeBorder, #1b2a48);padding:12px;border-radius:10px;max-height:420px;overflow:auto}
      .switch{display:flex;gap:8px;align-items:center}
      .hidden{display:none}
      .summaryChips{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
      .chip strong{font-weight:700;margin-right:6px}
      .overviewCard{max-width:1100px;margin:16px 16px 8px;padding:12px 16px}
      /* Modal */
      .backdrop{position:fixed;inset:0;background:rgba(3,8,20,.55);backdrop-filter:saturate(160%) blur(10px);display:flex;align-items:center;justify-content:center;padding:16px;z-index:3000;overflow:auto}
      .modal{max-width:860px;width:min(860px,96vw);background:rgba(16,24,39,.92);backdrop-filter:saturate(160%) blur(6px);border:1px solid #2a3a62;border-radius:12px;box-shadow:0 24px 70px rgba(0,0,0,.65), inset 0 1px 0 rgba(255,255,255,.04);padding:16px;max-height:calc(100vh - 48px);overflow:auto;z-index:3002}
      .modal h2{margin:0 0 8px 0;color:#cfe0ff;font-size:16px}
      .modal .section{margin:10px 0;padding:10px;border:1px dashed #2a3a62;border-radius:8px;background:#0d1424}
      .modal .section h3{margin:0 0 6px 0;font-size:13px;color:#bcd3ff}
      .modal pre{max-height:280px}
      .modal .toolbar{display:flex;gap:8px;justify-content:flex-end;margin-top:10px;position:sticky;bottom:0;background:linear-gradient(180deg, rgba(16,24,39,0), rgba(16,24,39,.85) 30%, rgba(16,24,39,.95));padding-top:12px;border-top:1px solid #2a3a62;backdrop-filter:saturate(160%) blur(6px);z-index:5}

      /* Conflict Management Styles */
      .conflict-item{border:1px solid var(--border);border-radius:12px;padding:20px;margin-bottom:16px;background:var(--panelGlass);backdrop-filter:saturate(160%) blur(6px)}
      .conflict-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
      .conflict-header h3{margin:0;color:var(--heading);font-size:16px}
      .conflict-status{color:var(--muted);font-size:14px}
      .conflict-options{display:flex;flex-direction:column;gap:15px}
      .conflict-configs{display:flex;flex-direction:column;gap:10px}
      .config-option{display:flex;align-items:center;padding:12px;border:2px solid var(--border);border-radius:8px;cursor:pointer;background:var(--appBgGlass);transition:all 0.2s;backdrop-filter:saturate(160%) blur(4px)}
      .config-option:hover{border-color:var(--lnk);transform:translateY(-1px)}
      .config-option.active{border-color:var(--ok);background:rgba(22,199,132,.08)}
      .config-option input[type="radio"]{margin-right:10px}
      .config-name{font-weight:500;flex:1;color:var(--heading)}
      .config-actions{display:flex;gap:8px;margin-left:auto}
      .conflict-actions{display:flex;gap:10px;justify-content:flex-end}
      .btn-small{padding:6px 12px;font-size:12px;border:1px solid var(--border);background:var(--btnBg);color:var(--btnText);border-radius:6px;cursor:pointer;transition:all 0.2s}
      .btn-small:hover{background:var(--btnBgHover);transform:translateY(-1px)}

      /* Config Modal Styles */
      .modal.large{max-width:1200px;width:min(1200px,96vw)}
      .config-modal{color:var(--text)}
      .config-actions{margin-bottom:15px;display:flex;gap:10px}
      .config-display{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:var(--codeBg);color:var(--codeText);max-height:500px;overflow:auto}
      .config-editor{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:#0d1424;color:#d9e2f1;resize:vertical;min-height:400px}
      .edit-actions{margin-top:15px;display:flex;gap:10px;justify-content:flex-end}

      /* Auto-Fix Suggestions Styles */
      .suggestion-item{border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:12px;background:var(--appBgGlass);backdrop-filter:saturate(160%) blur(4px)}
      .suggestion-item h3{margin:0 0 8px 0;color:var(--ok);font-size:14px}
      .suggestion-item p{margin:0 0 8px 0;color:var(--text);font-size:13px}
      .suggestion-item code{display:block;background:var(--codeBg);color:var(--codeText);padding:8px;border-radius:4px;margin:8px 0;font-family:var(--mono, monospace);font-size:12px}
      .suggestion-item .btn{margin-top:8px;font-size:12px}

      /* Global Conflict Indicator */
      .global-conflict-indicator{position:fixed;top:20px;right:20px;z-index:1000;animation:slideIn 0.3s ease-out}
      .conflict-badge{background:rgba(245,158,11,.15);border:2px solid var(--warn);border-radius:8px;padding:12px 16px;color:var(--warn);font-weight:600;display:flex;align-items:center;gap:12px;backdrop-filter:saturate(160%) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .conflict-badge button{background:var(--warn);color:#000;border:none;padding:6px 12px;border-radius:4px;font-weight:600;cursor:pointer;font-size:12px}
      .conflict-badge button:hover{opacity:0.9;transform:translateY(-1px)}
      @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}
      
      /* Healing Badge */
      .healing-badge{position:absolute;top:-12px;right:-12px;width:24px;height:24px;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);border-radius:50%;box-shadow:0 2px 5px rgba(0,0,0,.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:12px;cursor:pointer;transition:transform .2s ease;opacity:.85}
      .healing-badge:hover{opacity:1;transform:scale(1.15)}
      .healing-badge.active{animation:pulse 1.5s infinite}
      @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
      
      /* Healing History Panel */
      .healing-history{position:absolute;top:60px;right:48px;width:320px;background:var(--panelGlass);border:1px solid var(--border);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.4);backdrop-filter:saturate(160%) blur(6px);z-index:2010;padding:12px;display:none}
      .healing-history.visible{display:block}
      .healing-history h3{margin:0 0 10px 0;font-size:14px;display:flex;align-items:center;justify-content:space-between}
      .healing-history h3 button{background:none;border:none;cursor:pointer;font-size:16px;color:var(--muted);line-height:1}
      .healing-history-list{max-height:300px;overflow-y:auto}
      .healing-entry{margin-bottom:8px;padding:8px;border-radius:8px;background:rgba(125,162,255,.07);border:1px solid rgba(125,162,255,.15)}
      .healing-entry.success{border-color:rgba(22,199,132,.25);background:rgba(22,199,132,.07)}
      .healing-entry.failure{border-color:rgba(239,68,68,.25);background:rgba(239,68,68,.07)}
      .healing-entry-header{display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px}
      .healing-entry-issue{font-weight:bold}
      .healing-entry-timestamp{color:var(--muted);font-size:11px}
      .healing-entry-details{font-size:12px;margin-top:4px;word-break:break-word}
      .healing-entry-actions{display:flex;gap:8px;margin-top:6px}
      .healing-entry-actions button{font-size:11px;padding:3px 6px;border-radius:4px;cursor:pointer;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText)}
      .healing-entry-actions button:hover{background:var(--btnBgHover)}
      
      /* Healing Status Indicator in AI header */
      .ai-healing-status{font-size:12px;padding:4px 8px;border-radius:999px;display:inline-flex;align-items:center;gap:6px;border:1px solid var(--btnBorder);font-weight:700}
      .ai-healing-status .pulse{display:none}
      .ai-healing-count{color:var(--muted);font-size:11px}
      :root{--ai-ready:#16c784;--ai-healing:#ff5bbd;--ai-audit:#8b5cf6;--ai-coding:#3b82f6;--ai-offline:#ef4444}
      @keyframes chipGlow{0%{box-shadow:0 0 0 0 rgba(255,255,255,.0)}50%{box-shadow:0 0 18px 2px rgba(255,255,255,.22)}100%{box-shadow:0 0 0 0 rgba(255,255,255,.0)}}
      .ai-healing-status.status-ready{background:rgba(22,199,132,.18);border-color:rgba(22,199,132,.55);color:#fff}
      .ai-healing-status.status-healing{background:#ff5bbd;border-color:#ff5bbd;color:#fff;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-auditing{background:#8b5cf6;border-color:#8b5cf6;color:#fff;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-coding{background:#3b82f6;border-color:#3b82f6;color:#fff;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-offline{background:#ef4444;border-color:#ef4444;color:#fff}

      /* Hierarchical Route Styles */
      .expandable-route{position:relative}
      .route-header{cursor:pointer;padding:8px;border-radius:6px;transition:background-color 0.2s;display:flex;align-items:center;justify-content:space-between;position:relative}
      .route-header:hover{background:rgba(255,255,255,.05)}
      .route-title{display:flex;align-items:center;gap:8px;font-weight:600}
      .expand-icon{transition:transform 0.2s;font-size:12px;width:12px}
      .route-chips-section{padding:8px;display:flex;flex-direction:column;gap:6px}
      .route-name{font-size:16px}
      .child-count{font-size:12px;color:var(--muted);font-weight:400}
      .route-children{margin-top:8px;margin-left:20px;border-left:2px solid var(--border);padding-left:16px}
      .route-children.hidden{display:none}
      .child-route{margin-bottom:8px;padding:8px;background:var(--appBgGlass);border-radius:6px;border-left:3px solid var(--border)}
      .child-route-name{font-size:14px;color:var(--muted)}
      .child-route-header{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:6px;transition:background-color 0.2s}
      .child-route-header:hover{background:rgba(255,255,255,.05)}
      .header-action-btn{background:none;border:none;color:var(--textSecondary);cursor:pointer;padding:4px 8px;border-radius:4px;transition:all 0.2s ease;font-size:14px}
      .header-action-btn:hover{background:rgba(255,255,255,.1);color:var(--text)}
      .route-header{display:flex;gap:6px;padding:8px;position:relative}
      .route-header:first-child{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .route-title{flex:1;display:flex;align-items:center;gap:8px}
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .chip.small{font-size:11px;padding:2px 6px;border-radius:10px}
      .chip.upstream-base{background:var(--chip);color:var(--muted);font-size:11px;font-weight:400}
      .chip.promoted-indicator{background:rgba(22,199,132,.2);border-color:rgba(22,199,132,.5);color:#16c784;font-size:10px;font-weight:700;margin-left:8px;padding:2px 6px}
      .btn-small{padding:4px 8px;font-size:11px;min-height:24px}
      .route-header .chips{display:flex;flex-wrap:wrap;gap:4px;align-items:center}
      .parent-status .chip{margin-right:4px}
      .child-summary{margin-top:2px}
      .child-summary .chip{background:var(--btnBg);border-color:var(--btnBorder);font-size:10px;padding:1px 4px}
      .route-controls{margin-top:4px}
      .route-controls .btn{margin-right:6px}
      .route-actions{position:absolute;top:8px;right:8px;display:flex;gap:6px;flex-wrap:wrap;z-index:10}
      .route-actions .btn{margin-right:6px;min-width:60px}
      /* Action buttons container */
      .action-buttons-container{display:flex;gap:6px;align-items:center;z-index:10}
      
      /* Universal circular button style */
      .circular-action-btn{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border:1.5px solid var(--btnBorder);background:white;color:var(--btnText);border-radius:999px;font-size:14px;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05);transition:background 0.2s ease}
      .circular-action-btn:hover{background:#f0f0f0}
      .circular-action-btn svg{width:18px;height:18px;display:block}
      .circular-action-btn img{width:16px;height:16px;display:block}
      
      /* Legacy styles for compatibility */
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .icon-actions .icon-btn{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border:1.5px solid var(--btnBorder);background:white;color:var(--btnText);border-radius:999px;font-size:14px;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05);transition:background 0.2s ease}
      .icon-actions .icon-btn:hover{background:#f0f0f0}
      .icon-actions .icon-btn svg{width:18px;height:18px;display:block}
      .root-actions{position:absolute;top:8px;right:8px;display:flex;gap:8px;align-items:center}

      /* Hover scroll helpers */
      .hover-scroll{overflow:auto}

      /* AI Drawer */
      :root{--aiWidth:clamp(420px, 36vw, 840px)}
      .ai-drawer{position:fixed;right:0;height:calc(88vh - (var(--headerH, 64px) + var(--summaryH, 0px)));width:var(--aiWidth);padding:8px 8px;z-index:2005;background:var(--panelGlass);border-left:1px solid var(--border);border-radius:12px 0 0 12px;box-shadow:-8px 0 24px rgba(0,0,0,.35);backdrop-filter:saturate(160%) blur(8px);display:flex;flex-direction:column;transition:transform .18s ease}
      .ai-drawer.collapsed{transform:translateX(calc(100%));border-left:none;box-shadow:none}
      .ai-drawer.collapsed .ai-header,.ai-drawer.collapsed .ai-content{opacity:0;pointer-events:none}
      .ai-tab{position:absolute;left:-36px;top:15%;transform:translateY(-50%);background:var(--btnBg);border:1px solid var(--btnBorder);border-right:none;border-radius:10px 0 0 10px;color:var(--btnText);padding:12px 8px;font-size:13px;font-weight:700;cursor:pointer;box-shadow:-6px 6px 18px rgba(0,0,0,.25);display:flex;flex-direction:column;align-items:center;gap:8px}
      .ai-tab .icon-steth{display:flex;align-items:center;justify-content:center}
      .ai-tab .icon-steth img{width:20px;height:20px;display:block;transform: rotate(270deg);}
      .ai-tab .label{letter-spacing:.3px;writing-mode:vertical-rl;text-orientation:mixed;transform: rotate(180deg);}
      .ai-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border)}
      .ai-header h2{margin:0;font-size:14px;color:var(--heading)}
      .ai-meta{display:flex;gap:12px;font-size:12px;color:var(--muted);flex-wrap:wrap}
      .ai-content{display:flex;flex-direction:column;padding:10px 12px;gap:10px;height:100%;}
      .ai-row{display:flex;gap:8px;align-items:center}
      .ai-chat{flex:1;min-height:120px;border:1px solid var(--codeBorder);border-radius:10px;background:var(--codeBg);padding:10px;overflow:auto}
      .bubble{max-width:85%;padding:8px 12px;border-radius:14px;margin:12px 0;line-height:1.45}
      .bubble.user{margin-left:auto;background:rgba(125,162,255,.22);border:1px solid rgba(125,162,255,.35)}
      .bubble.assistant{margin-right:auto;background:linear-gradient(180deg, rgba(255,143,211,.12), rgba(255,91,189,.10));border:1px solid rgba(255,143,211,.45)}
      .bubble-title{font-size:11px;font-weight:600;color:var(--muted);margin-bottom:6px;padding-bottom:4px;border-bottom:1px solid rgba(255,255,255,.1)}
      .bubble-content{margin-top:0; overflow-wrap:anywhere; word-break:break-word}
      .bubble-content pre{white-space:pre-wrap; word-break:break-word}
      .bubble-content a{word-break:break-all}
      .ai-healing-history{display:flex;align-items:center;gap:4px;font-size:12px;color:var(--muted);background:rgba(125,162,255,.1);border:1px solid rgba(125,162,255,.3);padding:2px 8px;border-radius:12px;cursor:pointer;transition:all 0.2s ease}
      .ai-healing-history:hover{background:rgba(125,162,255,.2);border-color:rgba(125,162,255,.5)}
      .bubble p{margin:.4em 0}
      .bubble ul,.bubble ol{margin:.35em 0 .35em .9em}
      .bubble ul ul,.bubble ol ol{margin-left:.9em}
      .bubble li{margin:.25em 0}
      .bubble pre{margin:.5em 0;background:var(--codeBg);border:1px solid var(--codeBorder);padding:10px;border-radius:10px;overflow:auto}
      .bubble code{background:rgba(125,162,255,.15);border:1px solid rgba(125,162,255,.25);padding:0 4px;border-radius:4px}
      .ai-input{display:flex;flex-direction:column;gap:8px}
      .ai-input textarea{resize:vertical;min-height:44px;max-height:160px;font-family:var(--font-body);border:1px solid var(--codeBorder);border-radius:10px;background:var(--codeBg)}
      .ai-input textarea::placeholder{font-family:var(--font-body);color:var(--muted)}
      .ai-actions{display:flex;gap:8px;justify-content:flex-end;position:sticky;bottom:0;padding-top:8px;border-top:1px solid var(--border)}
      /* Thinking indicator */
      .bubble.thinking{background:transparent;border:1px dashed var(--btnBorder);opacity:.85}
      .dots{display:inline-flex;gap:4px;vertical-align:middle}
      .dot{width:6px;height:6px;border-radius:50%;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);opacity:.6;animation:dotPulse 1s infinite ease-in-out}
      .dot:nth-child(2){animation-delay:.15s}
      .dot:nth-child(3){animation-delay:.3s}
      @keyframes dotPulse{0%,80%,100%{transform:scale(.6);opacity:.4}40%{transform:scale(1);opacity:1}}

      /* Mobile: bottom drawer behavior + compact headers */
      @media (max-width: 768px){
        .ai-drawer{left:12px;right:12px;top:auto;bottom:12px;width:auto;height:min(50vh, calc(100vh - (var(--headerH, 64px) + 24px)));border-radius:12px}
        .ai-drawer.collapsed{transform:translateY(calc(100% - 28px));border-left:1px solid var(--border)}
        .ai-tab{left:50%;top:auto;bottom:-28px;transform:translate(-50%, 0);border-right:1px solid var(--btnBorder);border-left:1px solid var(--btnBorder)}
        .summaryRow h2{display:none}
        .appsHeader h2{display:none}
        .appsHeader .toolbar{width:100%}
        /* Keep buttons visible and reduce chat height on small screens */
        .ai-content{overflow:hidden}
        .ai-chat{flex:none;max-height:38vh}
      }

      /* Desktop/tablet: shift content left when assistant open */
      @media (min-width: 769px){
        body.ai-open .content{width:calc(100% - var(--aiWidth) - 28px);margin-left:16px;margin-right:calc(var(--aiWidth) + 12px)}
      }

      @media (max-width:1400px){
        .grid{grid-template-columns:repeat(2, minmax(0, 1fr))}
        .apps{grid-template-columns:repeat(2, minmax(0, 1fr))}
      }
      @media (max-width:1024px){
        .grid{grid-template-columns:1fr}
        .apps{grid-template-columns:1fr}
        .header-row{flex-wrap:wrap;gap:8px}
        .header-actions{gap:6px}
        .ai-drawer{height: calc(78vh - (var(--headerH, 64px) + var(--summaryH, 0px)));}
        /* On medium screens, keep input/actions in view by limiting chat height */
        .ai-content{overflow:hidden}
        .ai-chat{flex:none;max-height:48vh}
      }
      /* reserved for legacy global diagnose button (removed) */
      #aiDiagnoseGlobal{display:none}
      @media (max-width:768px){
        .conflict-options{gap:10px}
        .config-option{flex-direction:column;align-items:flex-start;gap:10px}
        .config-actions{margin-left:0}
        .conflict-actions{flex-direction:column}
        .suggestion-item{padding:12px}
        .toolbar{gap:6px}
        .toolbar .field{width:100%}
        .toolbar select,.toolbar input[type="text"]{width:100%}
        .route-header{padding:6px}
        .child-route{padding:6px}
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-row">
        <h1>
          <img src="/status/assets/logo.svg" alt="Dev Tunnel Proxy logo" style="height:40px;vertical-align:middle;margin-right:10px"/>
          <span>Dev Tunnel Proxy</span>
          Status
        </h1>
        <div class="header-actions">
          <a class="btn" href="/health">Health</a>
          <a class="btn" href="/reports/">Reports</a>
          <a class="btn" href="/dashboard/" target="_blank" rel="noopener">Dashboard</a>
          <button class="btn" id="reloadConfigs" title="Reload all configurations and rescan apps">🔄</button>
          <button class="btn" id="themeToggle" title="Toggle theme" aria-label="Toggle theme">🌙</button>
        <button class="btn" id="aiSelfCheckGlobal" title="Diagnose with Calliope" aria-label="Diagnose with Calliope">Self‑Check</button>
        </div>
      </div>
      
    </header>
    <div class="content">
      <div class="card overviewCard">
        <div class="summaryChips" id="summaryChips"></div>
      </div>
      <div class="container">
        <div class="ai-drawer collapsed" id="aiDrawer">
          <button class="ai-tab" id="aiTab" title="Calliope">
            <div class="icon-steth" aria-hidden="true">
              <img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope Stethoscope" style="width:20px;height:20px;display:block;">
            </div>
            <div class="label">Calliope</div>
          </button>
          
          
          <!-- Healing History Panel -->
          <div class="healing-history" id="healingHistory">
            <h3>
              Self-Healing History
              <button class="close-history">&times;</button>
            </h3>
            <div class="healing-history-list" id="healingHistoryList">
              <!-- Healing entries will be populated here -->
              <div class="empty-history">No healing actions recorded yet.</div>
            </div>
          </div>
          <div class="ai-header">
            <h2>
              <span class="icon-steth-header" aria-hidden="true">
                <img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope Stethoscope" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;">
              </span>
              Calliope
            </h2>
            <div class="ai-meta">
              <span class="ai-healing-history" id="aiHealingHistory">
                <span class="ai-healing-history-label">Healing History</span>
              </span>
              <span class="ai-healing-status" id="aiHealingStatus">
                <span class="pulse"></span>
                <span class="ai-healing-status-label" id="aiHealingStatusLabel">Healing</span>
                <span class="ai-healing-count" style="display:none" id="aiHealingCount"></span>
              </span>
              <button class="btn" id="aiHealBtn" title="Run Self-Check" aria-label="Run Self-Check">Self‑Check</button>
            </div>
          </div>
          <div class="ai-content">
            <div id="aiChat" class="ai-chat hover-scroll"></div>
            <div class="ai-input">
              <textarea id="aiQuery" class="hover-scroll" rows="3" placeholder="Ask about proxy/network issues" style="padding: 12px;"></textarea>
              <div class="ai-actions">
                <button class="btn" id="aiCopyBtn" title="Copy conversation to clipboard">Copy</button>
                <button class="btn" id="aiClearBtn" title="Clear conversation">Clear</button>
                <button class="btn" id="aiAskBtn">Ask</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card" id="appsCard">
          <h2 style="margin:0">Configured Apps</h2>

          <div class="card hidden" id="conflictCard" data-dismissible="true">
            <h2>⚠️ Route Conflicts</h2>
            <p>Multiple configuration files are declaring the same routes. Choose which config should win:</p>
            <div id="conflicts">Loading conflicts...</div>
          </div>
    
            <div class="card appsHeader">
            <div class="toolbar">
              <div class="field">
                <label class="label">Sort</label>
                <select id="sortMode">
                  <option value="alpha">A–Z</option>
                  <option value="status">By status</option>
                  <option value="depth">By depth</option>
                </select>
              </div>
              <div class="field">
                <label class="label">Filter</label>
                <input id="routeFilter" type="text" placeholder="/api, ok, warn, err, 200, ngrok:200" />
              </div>
            </div>
          </div>
          <div class="apps" id="apps">Loading…</div>
        </div>

      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script>
      function initTheme(){
        const stored = localStorage.getItem('dtpTheme');
        // Default to dark if nothing stored
        const theme = stored || 'dark';
        document.documentElement.setAttribute('data-theme', theme==='light'?'light':'dark');
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = theme==='light' ? '🌙' : '☀️';
        tbtn.setAttribute('title', theme==='light'?'Switch to dark':'Switch to light');
      }
      function measureStickyHeights(){
        const headerEl = document.querySelector('header');
        const summaryEl = document.querySelector('.summaryRow');
        const headerH = headerEl ? headerEl.getBoundingClientRect().height : 64;
        const summaryH = summaryEl ? summaryEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--headerH', headerH + 'px');
        document.documentElement.style.setProperty('--summaryH', summaryH + 'px');
      }
      function toggleTheme(){
        const cur = document.documentElement.getAttribute('data-theme')==='light'?'light':'dark';
        const next = cur==='light'?'dark':'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('dtpTheme', next);
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = next==='light' ? '🌙' : '☀️';
        tbtn.setAttribute('title', next==='light'?'Switch to dark':'Switch to light');
      }
      // Make logo/title clickable for branding
      (function enableHomeClicks(){
        const brand=document.querySelector('header h1');
        if (brand){ brand.style.cursor='pointer'; brand.addEventListener('click',()=>{ location.reload(); }); }
      })();
      window.addEventListener('load', measureStickyHeights);
      window.addEventListener('resize', measureStickyHeights);

      function chip(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }
      function chipEl(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }

      // Choose best URL to open (ALWAYS use ngrok URL + route)
      function chooseOpenUrl(routes, targets, routeKey){
        // ALWAYS use the global ngrok URL if available
        if (globalNgrokUrl && globalNgrokUrl !== 'not discovered') {
          // Ensure route starts with / and ngrok URL doesn't end with /
          const cleanRoute = routeKey.startsWith('/') ? routeKey : '/' + routeKey;
          const cleanNgrok = globalNgrokUrl.replace(/\/$/, '');
          return cleanNgrok + cleanRoute;
        }
        
        // Fallback to old logic if no global ngrok URL
        const pref = ['ngrok', 'local-proxy'];
        
        // First pass: try to find a successful response (2xx or 3xx for ngrok, only 2xx for localhost)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) {
            if (t === 'ngrok' && info.status >= 200 && info.status < 400) {
              return info.url;
            } else if (t === 'local-proxy' && info.status >= 200 && info.status < 300) {
              return info.url;
            }
          }
        }
        
        // Second pass: return ngrok URL even if not successful (better than localhost error)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) return info.url;
        }
        
        return null;
      }

      async function loadJSON(url){
        const res = await fetch(url, { headers: { 'ngrok-skip-browser-warning':'true' } });
        if(!res.ok) throw new Error('HTTP '+res.status);
        return res.json();
      }

      let routesData = null;
      let preferences = null;
      let promotedRoots = null; // { [baseKey]: '/api/' }
      let globalNgrokUrl = null; // Store the global ngrok URL for Open buttons

      function loadPrefs(){
        try{ return JSON.parse(localStorage.getItem('statusPrefs')||'{}'); }catch{ return {}; }
      }
      function savePrefs(p){ localStorage.setItem('statusPrefs', JSON.stringify(p||{})); }
      function loadPromotions(){
        try{ return JSON.parse(localStorage.getItem('routePromotions')||'{}'); }catch{ return {}; }
      }
      function savePromotions(p){ localStorage.setItem('routePromotions', JSON.stringify(p||{})); }

      function routeDepth(r){ return (r||'').split('/').filter(Boolean).length; }
      function normalizeBase(up){
        if (!up) return '';
        
        // Handle nginx variables like $inspire_upstream by treating them as literal keys
        if (up.includes('$')) {
          const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
          if (m && m[0]) return m[0];
          // Fallback: strip protocol and take host token before first '/'
          return up.replace(/^https?:\/\//,'').split('/')[0];
        }
        
        try{ 
          const u = new URL(up.startsWith('http') ? up : `http://${up}`); 
          return `${u.protocol}//${u.hostname}${u.port ? `:${u.port}` : ''}`;
        } catch { 
          return up.replace(/\/$/, ''); 
        }
      }
      function extractHostname(up){
        if (!up) return '';
        if (up.includes('$')) return up;
        try{
          const u = new URL(up.startsWith('http') ? up : `http://${up}`);
          return u.hostname; // ignore port for grouping
        }catch{
          return up.replace(/:\d+.*$/, '').replace(/\/$/, '');
        }
      }
      function addStatusChips(container, route, targets, routes){
        for (const t of targets) {
          const info = (routes.summary?.[t] || {})[route];
          if (!info) continue;
          
          const status = info.status || 0;
          let cls = 'err', reason = '';
          // Treat 2xx as ok, 3xx as warn (not ok) to avoid green-on-308 confusion
          if (status >= 200 && status < 300) { cls = 'ok'; reason = 'Working correctly'; }
          else if (status >= 300 && status < 400) { cls = 'warn'; reason = 'Redirect'; }
          else if (status === 404) { cls = 'warn'; reason = 'Not found - check route configuration'; }
          else if (status === 0) { cls = 'warn'; reason = 'No response from this target'; }
          else if (status >= 400 && status < 500) { cls = 'warn'; reason = 'Client error - check route configuration'; }
          else if (status >= 500) { cls = 'err'; reason = 'Server error - upstream service issue'; }
          
          const labelName = (t === 'local-proxy') ? 'localhost' : t;
          const label = `${labelName}: ${status}`;
          const statusChip = chip(label, cls, reason);
          container.appendChild(statusChip);
        }
      }
      function severityOf(route, targets, routes){
        // ok if ANY target is ok; redirects/0 treated as warn
        let sev='err';
        for (const t of targets){
          const info=(routes.summary?.[t]||{})[route];
          if (!info) continue;
          const s = info.status||0;
          if (s>=200 && s<300) return 'ok';
          if (s>=300 && s<400) sev = sev==='ok'?'ok':'warn';
          else if (s===0) sev = sev==='ok'?'ok':'warn';
        }
        return sev;
      }
      function applyFilter(routeGroups, filterValue, targets, routes){
        const q=(filterValue||'').trim().toLowerCase(); if(!q) return routeGroups;
        const codeOnly = /^\d{3}$/.test(q) ? parseInt(q,10) : null;
        const targetCodeMatch = q.match(/^(ngrok|localhost|local-proxy):(\d{3})$/);
        const targetKey = targetCodeMatch ? (targetCodeMatch[1]==='localhost'?'local-proxy':targetCodeMatch[1]) : null;
        const targetCode = targetCodeMatch ? parseInt(targetCodeMatch[2],10) : null;
        const matches = (route)=>{
          const name=(route||'').toLowerCase();
          if (name.includes(q)) return true;
          if (q==='ok'||q==='warn'||q==='err') return severityOf(route,targets,routes)===q;
          // match upstream base host
          const up = (routes.metadata?.[route]?.upstream || '').toLowerCase();
          if (up && up.includes(q)) return true;
          // status code anywhere
          if (codeOnly!=null){
            for (const t of targets){ const info=(routes.summary?.[t]||{})[route]; if (info && info.status===codeOnly) return true; }
          }
          // specific target:code
          if (targetKey){ const info=(routes.summary?.[targetKey]||{})[route]; if (info && info.status===targetCode) return true; }
          return false;
        };
        return routeGroups.filter(g=> matches(g.route) || (g.children||[]).some(c=>matches(c)) );
      }

      function debounce(fn, wait){ let to=null; return function(...args){ clearTimeout(to); to=setTimeout(()=>fn.apply(this,args), wait); }; }

      function rebuildApps(){
        const routes = routesData;
        const appsEl = document.getElementById('apps');
        appsEl.innerHTML = '';
        const targets = Object.keys(routes.summary||{});
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const src = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          (bySource[src] = bySource[src] || []).push(r);
        });
        // Force the apps grid to have exactly one column per source file (desktop),
        // but collapse to max 2 columns on tablets and 1 on mobile.
        if (appsEl) {
          const totalSources = Math.max(1, Object.keys(bySource).length);
          const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
          let cols = totalSources;
          if (vw <= 768) cols = 1;
          else if (vw <= 1200) cols = Math.min(2, totalSources);
          appsEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        }
        function buildGroupsByBase(routesInSource, meta){
          const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/','/api/resolve-conflict','/api/rename-route']);
          const routesList = routesInSource.filter(r=>!systemRoutes.has(r));
          const byBase = new Map();
          routesList.forEach(r=>{
            const up = (meta[r]||{}).upstream||'';
            const baseKey = normalizeBase(up);
            if (!byBase.has(baseKey)) byBase.set(baseKey, []);
            byBase.get(baseKey).push(r);
          });

          promotedRoots = loadPromotions();
          const groups = [];
          byBase.forEach((list, baseKey)=>{
            const unique = Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b));
            const promoted = promotedRoots?.[baseKey] || null;
            if (promoted && unique.includes(promoted)){
              const children = unique.filter(r=> r!==promoted);
              groups.push({ route: promoted, children, baseKey });
              return;
            }
            const depths = unique.map(r=>({ r, d:(r||'').split('/').filter(Boolean).length }));
            const minD = Math.min.apply(null, depths.map(x=>x.d));
            const shallow = depths.filter(x=>x.d===minD).map(x=>x.r);
            if (shallow.length === 1){
              const parent = shallow[0];
              const children = unique.filter(r=> r!==parent);
              groups.push({ route: parent, children, baseKey });
            } else {
              unique.forEach(r=> groups.push({ route:r, children:[], baseKey }));
            }
          });
          
          // Second pass: Handle path-based grouping for cross-upstream route relationships
          const finalGroups = [];
          const processedRoutes = new Set();
          
          // Sort groups by route length to process parents before children
          groups.sort((a, b) => a.route.length - b.route.length);
          
          groups.forEach(group => {
            if (processedRoutes.has(group.route)) return;
            
            // Check if this route should be a child of an existing group
            let foundParent = false;
            for (let existingGroup of finalGroups) {
              if (group.route !== existingGroup.route && 
                  group.route.startsWith(existingGroup.route) && 
                  group.route.length > existingGroup.route.length &&
                  (group.route[existingGroup.route.length] === '/' || existingGroup.route.endsWith('/'))) {
                // This route is a child of an existing group by path prefix
                if (!existingGroup.children.includes(group.route)) {
                  existingGroup.children.push(group.route);
                }
                // Add any children this group had to the parent as well
                group.children.forEach(child => {
                  if (!existingGroup.children.includes(child)) {
                    existingGroup.children.push(child);
                  }
                });
                processedRoutes.add(group.route);
                group.children.forEach(child => processedRoutes.add(child));
                foundParent = true;
                break;
              }
            }
            
            if (!foundParent) {
              finalGroups.push({ ...group });
              processedRoutes.add(group.route);
              group.children.forEach(child => processedRoutes.add(child));
            }
          });
          
          return finalGroups;
        }

        Object.keys(bySource).sort().forEach(source => {
          const groupCard = document.createElement('div');
          groupCard.className = 'card';
          const head = document.createElement('div');
          head.className = 'groupHead';
          const h2 = document.createElement('h2');
          h2.textContent = source;
          const buttonGroup = document.createElement('div');
          buttonGroup.className = 'chips';
          const jsonBtn = document.createElement('button');
          jsonBtn.className = 'btn btn-small';
          jsonBtn.textContent = 'JSON';
          jsonBtn.addEventListener('click', (e)=>{ e.preventDefault(); viewSourceJson(source, bySource[source]); });
          const resolveBtn = document.createElement('a');
          resolveBtn.className = 'btn btn-small'; resolveBtn.href = '#'; resolveBtn.textContent = 'Resolve Override';
          resolveBtn.style.display = 'none';
          resolveBtn.addEventListener('click', async (e)=>{
            e.preventDefault();
            const filename = (source||'').split('/').pop();
            if (!filename) return;
            if (!confirm(`Promote app version '${filename}' into overrides? This will replace overrides/${filename}.`)) return;
            try{
              const resp = await fetch('/api/overrides/promote', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ filename }) });
              if (!resp.ok){
                const j = await resp.json().catch(()=>({error:'request_failed'}));
                alert(`Failed to promote: ${j.error||resp.status}`);
              } else {
                alert('Promoted and reloaded nginx. Regenerating view...');
                location.reload();
              }
            }catch(err){ alert('Error: '+err.message); }
          });
          buttonGroup.appendChild(jsonBtn);
          buttonGroup.appendChild(resolveBtn);
          head.appendChild(h2);
          head.appendChild(buttonGroup);
          // If this source has a basename conflict, show resolve button now
          try {
            const basename = (source||'').split('/').pop();
            if (basename && window.conflictByName && window.conflictByName.has(basename)){
              resolveBtn.style.display = '';
            }
          } catch {}
          groupCard.appendChild(head);

          const list = document.createElement('div');
          list.className = 'apps';

          const inThisSource = Object.keys(meta).filter(r => (meta[r]||{}).sourceFile === source);
          let routeGroups = buildGroupsByBase(inThisSource, meta);
          const targetsArr = Object.keys(routes.summary||{});
          const sortEl = document.getElementById('sortMode');
          const filterEl = document.getElementById('routeFilter');
          let sortMode = (preferences?.sortMode) || (sortEl && sortEl.value) || 'status';
          if (sortMode==='manual') { sortMode='status'; preferences.sortMode='status'; savePrefs(preferences); if (sortEl) sortEl.value='status'; }
          const filterVal = (preferences?.filter) || (filterEl && filterEl.value) || '';
          routeGroups = applyFilter(routeGroups, filterVal, targetsArr, routes);
          routeGroups = sortRoutes(routeGroups, sortMode, targetsArr, routes);

          routeGroups.forEach(group => {
            const app = document.createElement('div');
            app.className = 'app';

            // Create unified action buttons container
            const actionContainer = document.createElement('div');
            actionContainer.className = 'action-buttons-container';
            
            // Create action buttons in order: Open, Promote, Calliope, Diagnose
            function createActionButton(type, options = {}) {
              const btn = document.createElement('button');
              btn.className = 'circular-action-btn';
              btn.type = 'button';
              btn.title = options.title || '';
              btn.setAttribute('aria-label', options.ariaLabel || options.title || '');
              if (options.innerHTML) btn.innerHTML = options.innerHTML;
              else btn.textContent = options.text || '';
              if (options.dataset) {
                Object.entries(options.dataset).forEach(([key, value]) => {
                  btn.dataset[key] = value;
                });
              }
              return btn;
            }
            
            app.appendChild(actionContainer);

            if (group.children && group.children.length > 0) {
              app.classList.add('expandable-route');
              const header = document.createElement('div');
              header.className = 'route-header';
              
              // Add title directly to header (left side)
              const titleSection = document.createElement('div');
              titleSection.className = 'route-title';
              titleSection.innerHTML = `
                <span class="expand-icon">▶</span>
                <span class="route-name">${group.route}</span>
                <span class="child-count">(${group.children.length} sub-routes)</span>
              `;
              header.appendChild(titleSection);
              
              // Add action buttons directly to header (right side)
              header.appendChild(actionContainer);
              
              // Ensure action order: Open, Dashboard, Promote, Calliope
              // Add Open button
              const openBtn = createActionButton('open', {
                title: 'Open Route',
                innerHTML: '🚀',
                dataset: { route: group.route }
              });
              openBtn.addEventListener('click', (e) => {
                e.preventDefault(); 
                e.stopPropagation();
                const url = chooseOpenUrl(routes, targets, group.route);
                if (url) window.open(url, '_blank', 'noopener');
              });
              actionContainer.appendChild(openBtn);
              
              // Add Dashboard button
              const dashBtn = createActionButton('dashboard', {
                title: 'Open Dashboard (route-focused)',
                innerHTML: '📊',
                dataset: { route: group.route }
              });
              dashBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopPropagation();
                const route = group.route;
                const base = (globalNgrokUrl && globalNgrokUrl !== 'not discovered') ? globalNgrokUrl.replace(/\/$/, '') : '';
                const url = base ? `${base}${route.startsWith('/')?route:'/'+route}` : '';
                const qp = new URLSearchParams();
                if (route) qp.set('route', route);
                if (url) qp.set('url', url);
                window.open(`/dashboard/?${qp.toString()}`,'_blank','noopener');
              });
              actionContainer.appendChild(dashBtn);
              
              // Add Promote button (make this expandable group's route the root)
              const promoteGroupBtn = createActionButton('promote', {
                title: 'Make Root Route',
                innerHTML: '🎓',
                dataset: { route: group.route }
              });
              promoteGroupBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const base = group.baseKey || normalizeBase(meta[group.route]?.upstream || '');
                if (!promotedRoots) promotedRoots = loadPromotions();
                promotedRoots[base] = group.route;
                savePromotions(promotedRoots);
                rebuildApps();
              });
              actionContainer.appendChild(promoteGroupBtn);

              // Add Calliope button last
              const calliopeBtn = createActionButton('calliope', {
                title: 'Diagnose with Calliope',
                innerHTML: '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;">',
                dataset: { route: group.route }
              });
              calliopeBtn.onclick = function(e){
                e.preventDefault(); e.stopPropagation();
                try { runCalliopeHealth(group.route); } catch(_) {
                  const drawer = document.getElementById('aiDrawer');
                  if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
                }
              };
              actionContainer.appendChild(calliopeBtn);
              
              // Create chips section (below header)
              const chipsSection = document.createElement('div');
              chipsSection.className = 'route-chips-section';
              
              const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
              const baseChipContainer = document.createElement('div');
              baseChipContainer.className = 'chips';
              baseChipContainer.appendChild(baseChip);
              chipsSection.appendChild(baseChipContainer);
              
              const parentStatusContainer = document.createElement('div');
              parentStatusContainer.className = 'chips parent-status';
              addStatusChips(parentStatusContainer, group.route, targets, routes);
              chipsSection.appendChild(parentStatusContainer);
              
              const summaryChips = document.createElement('div');
              summaryChips.className = 'chips child-summary';
              (group.children||[]).forEach(childRoute=>{
                const sev = severityOf(childRoute, targets, routes);
                const pref = ['ngrok','local-proxy'];
                let code = null;
                for (const t of pref){ const info=(routes.summary?.[t]||{})[childRoute]; if (info && typeof info.status==='number'){ code=info.status; break; } }
                const label = `${childRoute} ${code??''}`.trim();
                const sc = chip(label, `small ${sev}`);
                summaryChips.appendChild(sc);
              });
              chipsSection.appendChild(summaryChips);
              
              const childrenContainer = document.createElement('div');
              childrenContainer.className = 'route-children hidden';
              group.children.forEach(child => {
                const childApp = document.createElement('div');
                childApp.className = 'child-route';
                const childTitle = document.createElement('div');
                childTitle.className = 'route child-route-name';
                childTitle.textContent = child;
                
                // Create child route action container
                const childActionContainer = document.createElement('div');
                childActionContainer.className = 'action-buttons-container';
                
                // Add Open button to child action container
                const childOpenBtn = createActionButton('open', {
                  title: 'Open Route',
                  innerHTML: '🚀',
                  dataset: { route: child }
                });
                childOpenBtn.addEventListener('click', (e) => {
                  e.preventDefault(); 
                  e.stopPropagation();
                  const url = chooseOpenUrl(routes, targets, child);
                  if (url) window.open(url, '_blank', 'noopener');
                });
                childActionContainer.appendChild(childOpenBtn);
                
                // Add Dashboard button (child)
                const childDashBtn = createActionButton('dashboard', {
                  title: 'Open Dashboard (route-focused)',
                  innerHTML: '📊',
                  dataset: { route: child }
                });
                childDashBtn.addEventListener('click', (e) => {
                  e.preventDefault(); e.stopPropagation();
                  const route = child;
                  const base = (globalNgrokUrl && globalNgrokUrl !== 'not discovered') ? globalNgrokUrl.replace(/\/$/, '') : '';
                  const url = base ? `${base}${route.startsWith('/')?route:'/'+route}` : '';
                  const qp = new URLSearchParams();
                  if (route) qp.set('route', route);
                  if (url) qp.set('url', url);
                  window.open(`/dashboard/?${qp.toString()}`,'_blank','noopener');
                });
                childActionContainer.appendChild(childDashBtn);
                
                const childHeader = document.createElement('div');
                childHeader.className = 'child-route-header';
                childHeader.appendChild(childTitle);
                childHeader.appendChild(childActionContainer);
                childApp.appendChild(childHeader);
                
                // Create chips section for child routes
                const childChipsSection = document.createElement('div');
                childChipsSection.className = 'route-chips-section';
                
                const childBaseChip = chip(normalizeBase(meta[child]?.upstream || ''), 'upstream-base');
                const childBaseContainer = document.createElement('div');
                childBaseContainer.className = 'chips';
                childBaseContainer.appendChild(childBaseChip);
                childChipsSection.appendChild(childBaseContainer);
                
                const childStatusContainer = document.createElement('div');
                childStatusContainer.className = 'chips route-status';
                addStatusChips(childStatusContainer, child, targets, routes);
                childChipsSection.appendChild(childStatusContainer);
                
                childApp.appendChild(childChipsSection);
                
                // Add Promote button (for children only)
                const promoteBtn = createActionButton('promote', {
                  title: 'Make Root Route',
                  innerHTML: '🎓',
                  dataset: { route: child }
                });
                promoteBtn.addEventListener('click',(e)=>{
                  e.preventDefault();
                  e.stopPropagation(); // Prevent card expansion
                  const base = group.baseKey;
                  if (!promotedRoots) promotedRoots = loadPromotions();
                  promotedRoots[base] = child;
                  savePromotions(promotedRoots);
                  rebuildApps();
                });
                childActionContainer.appendChild(promoteBtn);
                
                // Add Calliope button (child)
                const childCalliopeBtn = createActionButton('calliope', {
                  title: 'Diagnose with Calliope',
                  innerHTML: '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;">',
                  dataset: { route: child }
                });
                childCalliopeBtn.onclick = function(e){
                  e.preventDefault(); e.stopPropagation();
                  try { runCalliopeHealth(child); } catch(_) {
                    const drawer = document.getElementById('aiDrawer');
                    if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
                  }
                };
                childActionContainer.appendChild(childCalliopeBtn);
                childrenContainer.appendChild(childApp);
              });
              header.addEventListener('click', () => {
                const isExpanded = !childrenContainer.classList.contains('hidden');
                childrenContainer.classList.toggle('hidden', isExpanded);
                header.querySelector('.expand-icon').textContent = isExpanded ? '▶' : '▼';
              });

              const filterVal = (preferences?.filter)||'';
              if (filterVal){
                const q=(filterVal||'').trim().toLowerCase();
                const anyMatch = (group.children||[]).some(c=>{
                  const name=(c||'').toLowerCase();
                  if (name.includes(q)) return true;
                  if (q==='ok'||q==='warn'||q==='err') return severityOf(c, targets, routes)===q;
                  const up = (routes.metadata?.[c]?.upstream || '').toLowerCase();
                  if (up && up.includes(q)) return true;
                  return false;
                });
                if (anyMatch){
                  childrenContainer.classList.remove('hidden');
                  header.querySelector('.expand-icon').textContent = '▼';
                }
              }
              app.appendChild(header);
              app.appendChild(chipsSection);
              app.appendChild(childrenContainer);
              applySeverityToApp(app, group.route, targets, routes);
            } else {
              const isPromoted = promotedRoots && promotedRoots[group.baseKey] === group.route;
              if (isPromoted) {
                app.classList.add('expandable-route');
                const header = document.createElement('div');
                header.className = 'route-header';
                
                // Add title directly to header (left side, no chevron for promoted routes)
                const titleSection = document.createElement('div');
                titleSection.className = 'route-title';
                titleSection.innerHTML = `
                  <span class="route-name">${group.route}</span>
                  <span class="child-count">(root)</span>
                `;
                header.appendChild(titleSection);
                
                // Add action buttons directly to header (right side)
                header.appendChild(actionContainer);
                
                // Create chips section for promoted routes
                const promotedChipsSection = document.createElement('div');
                promotedChipsSection.className = 'route-chips-section';
                
                const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
                const baseChipContainer = document.createElement('div');
                baseChipContainer.className = 'chips';
                baseChipContainer.appendChild(baseChip);
                promotedChipsSection.appendChild(baseChipContainer);
                
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chips parent-status';
                addStatusChips(statusContainer, group.route, targets, routes);
                promotedChipsSection.appendChild(statusContainer);
                
                const summaryChips = document.createElement('div');
                summaryChips.className = 'chips child-summary';
                promotedChipsSection.appendChild(summaryChips);
                
                // Add Open button for promoted routes
                const promotedOpenBtn = createActionButton('open', {
                  title: 'Open Route',
                  innerHTML: '🚀',
                  dataset: { route: group.route }
                });
                promotedOpenBtn.addEventListener('click', (e) => {
                  e.preventDefault(); 
                  e.stopPropagation();
                  const url = chooseOpenUrl(routes, targets, group.route);
                  if (url) window.open(url, '_blank', 'noopener');
                });
                actionContainer.appendChild(promotedOpenBtn);
                
                // Add Dashboard button for promoted routes
                const promotedDashBtn = createActionButton('dashboard', {
                  title: 'Open Dashboard (route-focused)',
                  innerHTML: '📊',
                  dataset: { route: group.route }
                });
                promotedDashBtn.addEventListener('click', (e) => {
                  e.preventDefault(); e.stopPropagation();
                  const route = group.route;
                  const base = (globalNgrokUrl && globalNgrokUrl !== 'not discovered') ? globalNgrokUrl.replace(/\/$/, '') : '';
                  const url = base ? `${base}${route.startsWith('/')?route:'/'+route}` : '';
                  const qp = new URLSearchParams();
                  if (route) qp.set('route', route);
                  if (url) qp.set('url', url);
                  window.open(`/dashboard/?${qp.toString()}`,'_blank','noopener');
                });
                actionContainer.appendChild(promotedDashBtn);
                
                // Add Promote button for promoted routes (idempotent)
                const promotedPromoteBtn = createActionButton('promote', {
                  title: 'Make Root Route',
                  innerHTML: '🎓',
                  dataset: { route: group.route }
                });
                promotedPromoteBtn.addEventListener('click', (e) => {
                  e.preventDefault(); e.stopPropagation();
                  const base = normalizeBase(meta[group.route]?.upstream || '');
                  if (!promotedRoots) promotedRoots = loadPromotions();
                  promotedRoots[base] = group.route;
                  savePromotions(promotedRoots);
                  rebuildApps();
                });
                actionContainer.appendChild(promotedPromoteBtn);

                // Ensure order: Open, Dashboard, Promote, Calliope
                // Add Calliope button for promoted routes
                const promotedCalliopeBtn = createActionButton('calliope', {
                  title: 'Diagnose with Calliope',
                  innerHTML: '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;">',
                  dataset: { route: group.route }
                });
                promotedCalliopeBtn.onclick = function(e){
                  e.preventDefault(); e.stopPropagation();
                  try { runCalliopeHealth(group.route); } catch(_) {
                    const drawer = document.getElementById('aiDrawer');
                    if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
                  }
                };
                actionContainer.appendChild(promotedCalliopeBtn);
                app.appendChild(header);
                app.appendChild(promotedChipsSection);
              } else {
                // Create header for standalone routes
                const header = document.createElement('div');
                header.className = 'route-header';
                
                // Add title directly to header (left side, no chevron for standalone routes)
                const titleSection = document.createElement('div');
                titleSection.className = 'route-title';
                titleSection.innerHTML = `<span class="route-name">${group.route}</span>`;
                header.appendChild(titleSection);
                
                // Add action buttons directly to header (right side)
                header.appendChild(actionContainer);
                
                // Create chips section for standalone routes
                const standaloneChipsSection = document.createElement('div');
                standaloneChipsSection.className = 'route-chips-section';
                
                const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
                const baseContainer = document.createElement('div');
                baseContainer.className = 'chips';
                baseContainer.appendChild(baseChip);
                standaloneChipsSection.appendChild(baseContainer);
                
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chips route-status';
                addStatusChips(statusContainer, group.route, targets, routes);
                standaloneChipsSection.appendChild(statusContainer);
                
                // Add Open button for standalone routes
                const standaloneOpenBtn = createActionButton('open', {
                  title: 'Open Route',
                  innerHTML: '🚀',
                  dataset: { route: group.route }
                });
                standaloneOpenBtn.addEventListener('click', (e) => {
                  e.preventDefault(); 
                  e.stopPropagation();
                  const url = chooseOpenUrl(routes, targets, group.route);
                  if (url) window.open(url, '_blank', 'noopener');
                });
                actionContainer.appendChild(standaloneOpenBtn);
                
                // Add Dashboard button for standalone routes
                const standaloneDashBtn = createActionButton('dashboard', {
                  title: 'Open Dashboard (route-focused)',
                  innerHTML: '📊',
                  dataset: { route: group.route }
                });
                standaloneDashBtn.addEventListener('click', (e) => {
                  e.preventDefault(); e.stopPropagation();
                  const route = group.route;
                  const base = (globalNgrokUrl && globalNgrokUrl !== 'not discovered') ? globalNgrokUrl.replace(/\/$/, '') : '';
                  const url = base ? `${base}${route.startsWith('/')?route:'/'+route}` : '';
                  const qp = new URLSearchParams();
                  if (route) qp.set('route', route);
                  if (url) qp.set('url', url);
                  window.open(`/dashboard/?${qp.toString()}`,'_blank','noopener');
                });
                actionContainer.appendChild(standaloneDashBtn);
                
                // Add Make Root button for standalone routes
                const makeRootBtn = createActionButton('promote', {
                  title: 'Make Root Route',
                  innerHTML: '🎓',
                  dataset: { route: group.route }
                });
                makeRootBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  const base = normalizeBase(meta[group.route]?.upstream || '');
                  if (!promotedRoots) promotedRoots = loadPromotions();
                  promotedRoots[base] = group.route;
                  savePromotions(promotedRoots);
                  rebuildApps();
                });
                actionContainer.appendChild(makeRootBtn);
                
                // Add Calliope button for standalone routes
                const standaloneCalliopeBtn = createActionButton('calliope', {
                  title: 'Diagnose with Calliope',
                  innerHTML: '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;">',
                  dataset: { route: group.route }
                });
                standaloneCalliopeBtn.onclick = function(e){
                  e.preventDefault(); e.stopPropagation();
                  try { runCalliopeHealth(group.route); } catch(_) {
                    const drawer = document.getElementById('aiDrawer');
                    if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
                  }
                };
                actionContainer.appendChild(standaloneCalliopeBtn);
                
                // Append header and chips to standalone routes
                app.appendChild(header);
                app.appendChild(standaloneChipsSection);
              }
              applySeverityToApp(app, group.route, targets, routes);
            }
            list.appendChild(app);
          });
          groupCard.appendChild(list);
          appsEl.appendChild(groupCard);
        });
      }
      function sortRoutes(routeGroups, sortMode, targets, routes){
        if (sortMode==='alpha') return routeGroups.slice().sort((a,b)=> a.route.localeCompare(b.route));
        if (sortMode==='depth') return routeGroups.slice().sort((a,b)=> routeDepth(a.route)-routeDepth(b.route) || a.route.localeCompare(b.route));
        if (sortMode==='status'){
          const rank={err:0,warn:1,ok:2};
          return routeGroups.slice().sort((a,b)=> (rank[severityOf(a.route,targets,routes)]-rank[severityOf(b.route,targets,routes)]) || a.route.localeCompare(b.route));
        }
        return routeGroups;
      }
      function rememberOrder(rendered){ preferences.routeOrder = rendered.map(g=>g.route); savePrefs(preferences); }

      // Bootstrap Calliope enabled flag ASAP so global handlers have a value
      (async function bootstrapCalliopeEnabled(){
        try{
          const resp = await fetch('/api/ai/health', { headers: { 'ngrok-skip-browser-warning': 'true' } });
          if (resp.ok){
            const j = await resp.json();
            window.__calliopeEnabled = !!j.enabled;
            document.body.classList.toggle('calliope-enabled', window.__calliopeEnabled);
          } else {
            window.__calliopeEnabled = false;
            document.body.classList.remove('calliope-enabled');
          }
        }catch{
          window.__calliopeEnabled = false;
          document.body.classList.remove('calliope-enabled');
        }
      })();

      (async function init(){
        preferences = loadPrefs();
        const routes = await loadJSON('/routes.json');
        routesData = routes;
        
        // Load ngrok URL with multiple fallback strategies
        let ngrokTxt = 'not discovered';
        
        // Strategy 1: Try status.json first (source of truth for health dashboard)
        try {
          const status = await loadJSON('/status.json');
          if (status && status.ngrok && status.ngrok !== 'not discovered' && status.ngrok !== 'null') {
            ngrokTxt = status.ngrok;
          }
        } catch (e) { /* Continue to next strategy */ }
        
        // Strategy 2: If status.json fails or has no ngrok, try health-latest.json
        if (ngrokTxt === 'not discovered') {
          try {
            const healthResp = await fetch('/.artifacts/reports/health-latest.json', { 
              headers: { 'ngrok-skip-browser-warning': 'true' },
              cache: 'no-cache'
            });
            if (healthResp.ok) {
              const healthData = await healthResp.json();
              if (healthData && healthData.ngrok && healthData.ngrok !== 'not discovered' && healthData.ngrok !== 'null') {
                ngrokTxt = healthData.ngrok;
              }
            }
          } catch (e) { /* Continue to next strategy */ }
        }
        
        // Strategy 3: Fall back to routes.json (what we already have)
        if (ngrokTxt === 'not discovered' && routes && routes.ngrok && routes.ngrok !== 'not discovered' && routes.ngrok !== 'null') {
          ngrokTxt = routes.ngrok;
        }
        
        // Strategy 4: Last resort - look for static domain hint in a minimal API call
        if (ngrokTxt === 'not discovered') {
          try {
            const staticDomainResp = await fetch('/api/ai/health', { 
              method: 'GET',
              headers: { 'ngrok-skip-browser-warning': 'true' }
            });
            if (staticDomainResp.ok) {
              const data = await staticDomainResp.json();
              if (data && data.staticNgrokDomain) {
                ngrokTxt = `https://${data.staticNgrokDomain}`;
              }
            }
          } catch (e) { /* Tried our best */ }
        }
        
        // Store globally for Open button functionality
        globalNgrokUrl = ngrokTxt;
        
        // Build overview chips row with bold labels
        const summaryWrap = document.getElementById('summaryChips');
        summaryWrap.innerHTML = '';
        const generatedTime = routes.generatedAt ? new Date(routes.generatedAt).toLocaleString() : '—';
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Generated:</strong> ${generatedTime}`;
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Ngrok URL:</strong> ${ngrokTxt}`;
        const targets = Object.keys(routes.summary||{});
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Targets:</strong> ${targets.join(', ') || '—'}`;

        // Group by source file from metadata (data-driven)
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const src = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          (bySource[src] = bySource[src] || []).push(r);
        });

        // Fetch override conflicts and mark sources that can be resolved
        let conflicts = [];
        try{
          const c = await fetch('/api/overrides/conflicts', { headers: { 'ngrok-skip-browser-warning': 'true' } });
          if (c.ok){ const j = await c.json(); conflicts = Array.isArray(j.conflicts) ? j.conflicts : []; }
        }catch{}
        const conflictByName = new Set(conflicts.map(x=> x && x.filename).filter(Boolean));
        window.conflictByName = conflictByName;

        // Build hierarchical route structure (no hardcoded roots)
        const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/','/api/resolve-conflict','/api/rename-route']);
        const isSystem = (r)=> systemRoutes.has(r);
        const isTechnical = (r)=> r.startsWith('/static/') || r.startsWith('/sockjs-node') || r.startsWith('/node_modules/') || r.startsWith('/@') || r.startsWith('/_next/') || r.startsWith('/src/') || r.startsWith('/.storybook/') || r.startsWith('/sb-') || r==='/' || r==='/favicon.ico' || r==='/asset-manifest.json';
        function normalizeBase(up){
          if (!up) return '';
          if (up.includes('$')){
            const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
            if (m && m[0]) return m[0];
            return up.replace(/^https?:\/\//,'').split('/')[0];
          }
          try{ const u=new URL(up.startsWith('http')?up:`http://${up}`); return `${u.protocol}//${u.hostname}${u.port?`:${u.port}`:''}`; }catch{ return up.replace(/\/$/,''); }
        }
        function buildGroupsByBase(routesInSource, meta){
          const routes = routesInSource.filter(r=>!isSystem(r));
          const byBase = new Map();
          routes.forEach(r=>{
            const up = (meta[r]||{}).upstream||'';
            const baseKey = normalizeBase(up);
            if (!byBase.has(baseKey)) byBase.set(baseKey, []);
            byBase.get(baseKey).push(r);
          });

          promotedRoots = loadPromotions();
          const groups = [];
          byBase.forEach((list, baseKey)=>{
            const unique = Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b));
            const promoted = promotedRoots?.[baseKey] || null;
            if (promoted && unique.includes(promoted)){
              const children = unique.filter(r=> r!==promoted);
              groups.push({ route: promoted, children, baseKey });
              return;
            }
            // Auto-parent ONLY if there is a single shallowest route
            const depths = unique.map(r=>({ r, d:(r||'').split('/').filter(Boolean).length }));
            const minD = Math.min.apply(null, depths.map(x=>x.d));
            const shallow = depths.filter(x=>x.d===minD).map(x=>x.r);
            if (shallow.length === 1){
              const parent = shallow[0];
              const children = unique.filter(r=> r!==parent);
              groups.push({ route: parent, children, baseKey });
            } else {
              // No auto parent; present as standalone with baseKey so user can promote
              unique.forEach(r=> groups.push({ route:r, children:[], baseKey }));
            }
          });
          return groups;
        }
        // Distribute routes by their source file (single pass)
        // Note: avoid duplicating entries across sources
        // meta is keyed by route; each value contains its sourceFile

        // Provide early stub so Diagnose clicks before assistant init are queued
        try{
          if (!window.runCalliopeHealth){
            window.runCalliopeHealth = function(route){
              try{ const d = document.getElementById('aiDrawer'); if (d){ d.classList.remove('collapsed'); document.body.classList.add('ai-open'); } }catch{}
              window.__pendingDiagnoseRoute = route || '/sdk';
            };
          }
        }catch{}

        // Show conflict management section if there are conflicts
        showConflictManagement(routes);
        
        // Add global conflict status indicator
        updateGlobalConflictIndicator(routes);

          // Start Calliope UI immediately so Diagnose clicks work even while apps load
          try { initAiAssistant(); } catch (e) { /* non-fatal */ }

          rebuildApps();

          // No manual ordering; default sort is by status
          try { await initAiAssistant(); } catch (e) { /* non-fatal */ }
      })().catch(err => {
        document.getElementById('apps').textContent = 'Error: '+err.message;
      });

      // Controls wiring
      (function initControls(){
        const sortEl=document.getElementById('sortMode');
        const filterEl=document.getElementById('routeFilter');
        const selfCheckBtn=document.getElementById('aiSelfCheckGlobal');
        preferences = loadPrefs();
        if (sortEl){
          const pref = (preferences.sortMode==='manual') ? 'status' : (preferences.sortMode||'status');
          sortEl.value = pref;
          sortEl.addEventListener('change',(e)=>{ preferences.sortMode=e.target.value; savePrefs(preferences); rebuildApps(); setTimeout(() => toggleCalliopeAffordances(true), 50); });
        }
        if (filterEl){
          if (preferences.filter) filterEl.value=preferences.filter;
          const debounced = debounce(()=>{ savePrefs(preferences); rebuildApps(); setTimeout(() => toggleCalliopeAffordances(true), 50); }, 250);
          filterEl.addEventListener('input',(e)=>{ preferences.filter=e.target.value; debounced(); });
        }
        if (selfCheckBtn){
          selfCheckBtn.addEventListener('click', async ()=>{
            try{
              const d=document.getElementById('aiDrawer'); if (d){ d.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
              chatEngaged = true; hasUserMessage = true;
              appendBubble('assistant', 'Heya! One sec while I listen to /api/...');
              await fetch('/api/ai/self-check', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ heal:true }) });
            }catch{}
          });
        }
      })();

      // Reload configurations functionality
      async function reloadConfigs() {
        const reloadBtn = document.getElementById('reloadConfigs');
        const originalText = reloadBtn.textContent;
        
        try {
          // Show loading state
          reloadBtn.textContent = '🔄 Reloading...';
          reloadBtn.disabled = true;
          
          // Force refresh of routes.json with cache busting (no API endpoint exists for scan-apps)
          let scanSuccess = false;
          const timestamp = Date.now();
          const freshRoutes = await fetch(`/routes.json?_t=${timestamp}`, {
            headers: { 'ngrok-skip-browser-warning': 'true' },
            cache: 'no-cache'
          });
          if (freshRoutes.ok) {
            scanSuccess = true;
            console.log('✅ Routes data refreshed');
          }
          
          if (scanSuccess) {
            // Success feedback
            reloadBtn.textContent = '✅ Reloaded!';
            reloadBtn.style.background = '#16402b';
            reloadBtn.style.borderColor = '#2a7f54';
            reloadBtn.style.color = '#a6f3cc';
            
            // Reload the page after short delay to show success
            setTimeout(() => {
              location.reload();
            }, 1000);
          } else {
            throw new Error('Unable to reload configs');
          }
          
        } catch (error) {
          console.error('Config reload failed:', error);
          
          // Error feedback
          reloadBtn.textContent = '❌ Failed - Try Manual';
          reloadBtn.style.background = 'rgba(239,68,68,.15)';
          reloadBtn.style.borderColor = '#ef4444';
          reloadBtn.style.color = '#ef4444';
          
          // Show manual instructions
          const instructions = `
To reload manually, run:
node test/scanApps.js
./scripts/smart-build.sh

Or check if config files have syntax errors.
          `.trim();
          
          setTimeout(() => {
            if (confirm(`Automatic reload failed.\n\n${instructions}\n\nWould you like to refresh the page anyway to check if configs were updated externally?`)) {
              location.reload();
            }
          }, 1500);
        }
        
        // Reset button after delay
        setTimeout(() => {
          reloadBtn.textContent = originalText;
          reloadBtn.disabled = false;
          reloadBtn.style.background = '';
          reloadBtn.style.borderColor = '';
          reloadBtn.style.color = '';
        }, 3000);
      }

      // Wire up reload button
      document.getElementById('reloadConfigs').addEventListener('click', reloadConfigs);

      // View JSON for specific source file
      function viewSourceJson(sourceFile, routesInSource) {
        const filteredData = {
          sourceFile: sourceFile,
          routes: {},
          metadata: {},
          generatedAt: routesData.generatedAt,
          ngrok: routesData.ngrok
        };
        
        // Filter routes data to only include routes from this source
        const targetsArr = Object.keys(routesData.summary || {});
        targetsArr.forEach(target => {
          filteredData.routes[target] = {};
          if (routesData.summary && routesData.summary[target]) {
            routesInSource.forEach(route => {
              if (routesData.summary[target][route]) {
                filteredData.routes[target][route] = routesData.summary[target][route];
              }
            });
          }
        });
        
        // Filter metadata to only include routes from this source
        if (routesData.metadata) {
          routesInSource.forEach(route => {
            if (routesData.metadata[route]) {
              filteredData.metadata[route] = routesData.metadata[route];
            }
          });
        }
        
        const modal = document.createElement('div');
        modal.className = 'backdrop';
        modal.innerHTML = `
          <div class="modal large">
            <h2>JSON Data for ${sourceFile}</h2>
            <div class="section">
              <h3>Filtered Routes & Metadata</h3>
              <p>Showing only routes from <strong>${sourceFile}</strong> (${routesInSource.length} routes)</p>
              <pre class="config-display">${JSON.stringify(filteredData, null, 2)}</pre>
            </div>
            <div class="toolbar">
              <button class="btn" onclick="navigator.clipboard.writeText('${JSON.stringify(filteredData, null, 2).replace(/'/g, "\\'")}').then(() => this.textContent = 'Copied!').then(() => setTimeout(() => this.textContent = 'Copy JSON', 1500))">Copy JSON</button>
              <button class="btn" onclick="this.closest('.backdrop').remove()">Close</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
      }

      // Conflict Management Functions
      function showConflictManagement(routes) {
        const conflictCard = document.getElementById('conflictCard');
        const conflictsDiv = document.getElementById('conflicts');
        
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        // Hide indicator if user acknowledged
        try{ const ack = JSON.parse(localStorage.getItem('conflictsAck')||'null'); if (ack && ack.ts) return; }catch{}
        
        // Respect local acknowledgement to dismiss banner/content block
        try{
          const ack = JSON.parse(localStorage.getItem('conflictsAck')||'null');
          if (ack && ack.ts && (Date.now() - ack.ts < 7*24*3600*1000)){
            conflictCard.classList.add('hidden');
            return;
          }
        }catch{}
        if (!hasConflicts) { conflictCard.classList.add('hidden'); return; }
        
        conflictCard.classList.remove('hidden');
        // Add a one-time acknowledge button
        const ackBtn = document.createElement('button');
        ackBtn.className = 'btn';
        ackBtn.textContent = 'Acknowledge';
        ackBtn.onclick = ()=>{ try{ localStorage.setItem('conflictsAck', JSON.stringify({ ts: Date.now() })); }catch{} conflictCard.classList.add('hidden'); };
        const header = conflictCard.querySelector('h2');
        if (header && !conflictCard.querySelector('.btn.ack')){ header.appendChild(document.createTextNode(' ')); header.appendChild(ackBtn); ackBtn.classList.add('ack'); }
        conflictsDiv.innerHTML = '';
        
        // Parse nginx warnings to extract conflict information
        const conflicts = parseConflictWarnings(routes.nginxWarnings || []);
        
        conflicts.forEach(conflict => {
          const conflictDiv = document.createElement('div');
          conflictDiv.className = 'conflict-item';
          conflictDiv.innerHTML = `
            <div class="conflict-header">
              <h3>Route: ${conflict.route}</h3>
              <div class="conflict-status">
                Current winner: <strong>${conflict.winner}</strong>
              </div>
            </div>
            <div class="conflict-options">
              <div class="conflict-configs">
                ${conflict.configs.map(config => `
                  <label class="config-option ${config === conflict.winner ? 'active' : ''}">
                    <input type="radio" name="conflict-${conflict.route}" value="${config}" ${config === conflict.winner ? 'checked' : ''}>
                    <span class="config-name">${config}</span>
                    <div class="config-actions">
                      <button class="btn-small" onclick="viewConfig('${config}')">View</button>
                      <button class="btn-small" onclick="renameRoute('${conflict.route}', '${config}')">Rename Route</button>
                    </div>
                  </label>
                `).join('')}
              </div>
              <div class="conflict-actions">
                <button class="btn" onclick="resolveConflict('${conflict.route}')">Apply Selection</button>
                <button class="btn" onclick="autoFixConflict('${conflict.route}')">Auto-Fix</button>
              </div>
            </div>
          `;
          conflictsDiv.appendChild(conflictDiv);
        });
      }

      function parseConflictWarnings(warnings) {
        const conflicts = [];
        warnings.forEach(warning => {
          // Parse warning like: "Route /api/: NEW CONFLICT - encast.conf wins (first config) over test-conflict.conf"
          const routeMatch = warning.match(/Route ([^:]+):/);
          const winnerMatch = warning.match(/- ([^\\s]+)\\.conf wins.*over ([^\\s,]+(?:\\.conf)?)/);
          
          if (routeMatch && winnerMatch) {
            const route = routeMatch[1];
            const winner = winnerMatch[1] + '.conf';
            const loser = winnerMatch[2].endsWith('.conf') ? winnerMatch[2] : winnerMatch[2] + '.conf';
            
            conflicts.push({
              route,
              winner,
              configs: [winner, loser]
            });
          }
        });
        return conflicts;
      }

      async function resolveConflict(route) {
        const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
        if (!selectedRadio) return;
        
        const newWinner = selectedRadio.value;
        
        try {
          const response = await fetch('/api/resolve-conflict', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ route, winner: newWinner })
          });
          
          if (response.ok) {
            // Refresh the page to show updated conflicts
            location.reload();
          } else {
            alert('Failed to resolve conflict. Check console for details.');
          }
        } catch (error) {
          alert('Error resolving conflict: ' + error.message);
        }
      }

      function viewConfig(configFile) {
        openConfigModal(configFile);
      }

      function renameRoute(route, configFile) {
        const newRoute = prompt(`Rename route ${route} in ${configFile} to:`, route);
        if (newRoute && newRoute !== route) {
          renameRouteInConfig(route, newRoute, configFile);
        }
      }

      function autoFixConflict(route) {
        // Smart auto-fix suggestions based on route type
        const suggestions = getAutoFixSuggestions(route);
        
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2>Auto-Fix Suggestions for ${route}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <p>Here are intelligent suggestions to resolve this conflict:</p>
              ${suggestions.map(s => `
                <div class="suggestion-item">
                  <h3>${s.title}</h3>
                  <p>${s.description}</p>
                  <code>${s.example}</code>
                  <button class="btn" onclick="applySuggestion('${route}', '${s.action}', '${s.params}')">Apply This Fix</button>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      function getAutoFixSuggestions(route) {
        const suggestions = [];
        
        if (route === '/api/') {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Rename one route to be app-specific',
            example: 'location /myapp/api/ { ... }',
            action: 'rename',
            params: '/myapp/api/'
          });
          suggestions.push({
            title: 'Use Versioned API',
            description: 'Add version to make routes unique',
            example: 'location /api/v1/ { ... }',
            action: 'rename', 
            params: '/api/v1/'
          });
        } else if (route === '/admin/') {
          suggestions.push({
            title: 'App-Specific Admin',
            description: 'Make admin path unique to your app',
            example: 'location /myapp/admin/ { ... }',
            action: 'rename',
            params: route.replace('/admin/', '/myapp/admin/')
          });
        } else {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Prepend your app name to make the route unique',
            example: `location /myapp${route} { ... }`,
            action: 'rename',
            params: `/myapp${route}`
          });
        }
        
        suggestions.push({
          title: 'Let First Config Win', 
          description: 'Keep the current winner, no changes needed',
          example: 'No configuration changes required',
          action: 'accept',
          params: ''
        });
        
        return suggestions;
      }

      async function applySuggestion(route, action, params) {
        if (action === 'accept') {
          document.querySelector('.modal').remove();
          return;
        }
        
        if (action === 'rename') {
          const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
          if (!selectedRadio) {
            alert('Please select a config file first');
            return;
          }
          
          const configFile = selectedRadio.value;
          await renameRouteInConfig(route, params, configFile);
          document.querySelector('.modal').remove();
        }
      }

      async function renameRouteInConfig(oldRoute, newRoute, configFile) {
        try {
          const response = await fetch('/api/rename-route', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ oldRoute, newRoute, configFile })
          });
          
          if (response.ok) {
            alert(`Route renamed successfully. Please restart the proxy for changes to take effect.`);
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to rename route: ' + error);
          }
        } catch (error) {
          alert('Error renaming route: ' + error.message);
        }
      }

      function openConfigModal(configFile) {
        // Create and show config viewing modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content large">
            <div class="modal-header">
              <h2>Config File: ${configFile}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <div class="config-actions">
                <button class="btn" onclick="downloadConfig('${configFile}')">Download</button>
                <button class="btn" onclick="enableConfigEdit(this)">Edit</button>
              </div>
              <pre id="config-content" class="config-display">Loading...</pre>
              <textarea id="config-editor" class="config-editor hidden" rows="30"></textarea>
              <div class="edit-actions hidden">
                <button class="btn" onclick="saveConfig('${configFile}')">Save Changes</button>
                <button class="btn" onclick="cancelConfigEdit()">Cancel</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        loadConfigContent(configFile);
      }

      async function loadConfigContent(configFile) {
        try {
          const response = await fetch(`/api/config/${configFile}`);
          const content = await response.text();
          
          if (response.ok) {
            document.getElementById('config-content').textContent = content;
            document.getElementById('config-editor').value = content;
          } else {
            document.getElementById('config-content').textContent = `Error loading config: ${content}`;
          }
        } catch (error) {
          document.getElementById('config-content').textContent = `Error: ${error.message}`;
        }
      }

      function enableConfigEdit(button) {
        document.getElementById('config-content').classList.add('hidden');
        document.getElementById('config-editor').classList.remove('hidden');
        document.querySelector('.edit-actions').classList.remove('hidden');
        button.style.display = 'none';
      }

      function cancelConfigEdit() {
        document.getElementById('config-content').classList.remove('hidden');
        document.getElementById('config-editor').classList.add('hidden');
        document.querySelector('.edit-actions').classList.add('hidden');
        document.querySelector('.config-actions button:nth-child(2)').style.display = '';
      }

      async function saveConfig(configFile) {
        const content = document.getElementById('config-editor').value;
        
        try {
          const response = await fetch(`/api/config/${configFile}`, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: content
          });
          
          if (response.ok) {
            alert('Config saved successfully. Restart the proxy for changes to take effect.');
            document.querySelector('.modal').remove();
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to save config: ' + error);
          }
        } catch (error) {
          alert('Error saving config: ' + error.message);
        }
      }

      function downloadConfig(configFile) {
        const content = document.getElementById('config-content').textContent;
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = configFile;
        a.click();
        URL.revokeObjectURL(url);
      }

      function updateGlobalConflictIndicator(_routes) {
        // Permanently disable the floating conflict banner
        const existing = document.querySelector('.global-conflict-indicator');
        if (existing) existing.remove();
        return;
      }

      function applySeverityToApp(appElement, route, targets, routes) {
        const severity = severityOf(route, targets, routes);
        appElement.classList.add(severity);
      }

      // Modal logic
      function openDiagnoseModal(routeKey, targets, routes){
        // If Calliope is enabled, she overrides manual diagnose with her health flow
        if (document.body.classList.contains('calliope-enabled')){
          try { runCalliopeHealth(routeKey); } catch(e){}
          return;
        }
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Diagnose: <code>${routeKey}</code></h2>
          <div class="section"><h3>Detected Issues</h3><div id="issues"></div></div>
          <div class="section"><h3>Suggested Nginx Snippet</h3><pre id="snippet"></pre></div>
          <div class="section"><h3>Repair Commands</h3><pre id="commands"></pre></div>
          <div class="toolbar"><button class="btn" id="copySnippet">Copy snippet</button><button class="btn" id="copyCmds">Copy commands</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Build issues list
        const issues = [];
        for (const t of targets){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (!info) continue;
          const status = info.status||0;
          if (!(status>=200 && status<300)) issues.push(`${t}: HTTP ${status}`);
          // Note: API conflict detection removed
          if (info.websocket && !info.websocket.ok) issues.push(`${t}: websocket upgrade failed`);
        }
        if (!issues.length) issues.push('No obvious issues detected.');
        modal.querySelector('#issues').innerHTML = `<ul>${issues.map(i=>`<li>${i}</li>`).join('')}</ul>`;

        // Build snippet template
        const name = routeKey.replace(/^\/(.*?)\/?$/, '$1');
        let snippet='';
        if (routeKey === '/api/') {
          snippet = `# Preserve /api prefix to upstream service\nlocation /api/ {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://SERVICE_ALIAS:PORT;\n}`;
        } else if (/^\/[A-Za-z0-9_-]+\/$/.test(routeKey)) {
          snippet = `# Keep prefix, enable HMR\nlocation = ${routeKey.slice(0,-1)} { rewrite ^ ${routeKey} last; }\nlocation ^~ ${routeKey}_next/ {\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_pass http://${name}-app:2000${routeKey}_next/;\n}\nlocation ^~ ${routeKey} {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-Host $host;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header X-Forwarded-Prefix ${routeKey.slice(0,-1)};\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://${name}-app:2000${routeKey};\n}`;
        } else {
          snippet = `# Example mapping\nlocation ^~ ${routeKey} {\n  proxy_pass http://SERVICE_ALIAS:PORT${routeKey};\n}`;
        }
        modal.querySelector('#snippet').textContent = snippet;

        // Commands
        const cmd = `# Copy snippet to apps/${name||'myapp'}.conf and reload\n./scripts/install-app.sh ${name||'myapp'} examples/next/myapp.conf || true\n# Or place the generated snippet into apps/${name||'myapp'}.conf then:\ndocker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#commands').textContent = cmd;

        // Copy handlers
        modal.querySelector('#copySnippet').addEventListener('click',()=>{
          navigator.clipboard.writeText(snippet);
        });
        modal.querySelector('#copyCmds').addEventListener('click',()=>{
          navigator.clipboard.writeText(cmd);
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }

      // Recommend modal – aggregates issues and provides generic fixes/snippets
      function openRecommendModal(routes, onlyRoutes){
        const targets = Object.keys(routes.summary||{});
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Recommendations</h2>
          <div class=\"section\"><h3>Detected Issues</h3><div id=\"issues\"></div></div>
          <div class="section"><h3>Standard Fixes</h3><ul id="fixes"></ul></div>
          <div class="section"><h3>Snippets</h3>
            <p><strong>Keep prefix (Next.js basePath)</strong></p>
            <pre id="snKeep"></pre>
            <p><strong>Strip prefix (CRA/Storybook)</strong></p>
            <pre id="snStrip"></pre>
            <p><strong>Preserve /api prefix</strong></p>
            <pre id="snApi"></pre>
          </div>
          <div class="section"><h3>Commands</h3><pre id="cmds"></pre></div>
          <div class="toolbar"><button class="btn" id="copyAll">Copy all</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Group issues by endpoint for readability
        const issuesByRoute = {};
        targets.forEach(t=>{
          const m = routes.summary[t]||{};
          const routeKeys = onlyRoutes && onlyRoutes.length ? onlyRoutes : Object.keys(m);
          routeKeys.forEach(r=>{
            const info = m[r]||{};
            const st = info.status||0;
            const msgs = [];
            if (!(st>=200 && st<300)) msgs.push(`${t}: HTTP ${st}`);
            if (info.websocket && !info.websocket.ok) msgs.push(`${t}: websocket upgrade failed`);
            // Only flag API ownership conflicts if owned by different config
            // Note: API conflict detection removed
            if (msgs.length) {
              issuesByRoute[r] = issuesByRoute[r] || [];
              issuesByRoute[r].push(...msgs);
            }
          });
        });
        const blocks = Object.keys(issuesByRoute).sort().map(r => `<div class=\"section\"><h3>${r}</h3><ul>${issuesByRoute[r].map(i=>`<li>${i}</li>`).join('')}</ul></div>`);
        modal.querySelector('#issues').innerHTML = blocks.length ? blocks.join('') : '<p>No warnings/errors detected.</p>';

        const fixes = [
          'Ensure all dev services join the external "devproxy" network and use service aliases as upstream hosts.',
          'Avoid proxy_pass variables for dev routes; use fixed upstreams. Use trailing slash to strip prefix when needed.',
          'For HMR: set proxy_http_version 1.1 and Upgrade/Connection headers on prefix routes.',
          'For Next.js behind a path: run a basePath-aware dev instance and DO NOT strip the prefix in the proxy.',
          'For CRA/Storybook behind a path: strip the prefix with trailing-slash proxy_pass and configure PUBLIC_URL or builder base/publicPath.',
          'If multiple projects share /api, keep /api mapped to the API app and ensure other apps call a prefixed API or separate domain.',
        ];
        modal.querySelector('#fixes').innerHTML = fixes.map(f=>`<li>${f}</li>`).join('');

        const snKeep = `# Keep prefix (Next.js basePath example)
location = /myapp { rewrite ^ /myapp/ last; }
location ^~ /myapp/_next/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_pass http://myapp-app:2000/myapp/_next/;
}
location ^~ /myapp/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Prefix /myapp;
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://myapp-app:2000/myapp/;
}`;

        const snStrip = `# Strip prefix (CRA/Storybook example)
location ^~ /ui/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://ui-app:3000/;  # trailing slash strips /ui/
}`;

        const snApi = `# Preserve /api prefix to API upstream
location /api/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://api-app:8000;
}`;

        modal.querySelector('#snKeep').textContent = snKeep;
        modal.querySelector('#snStrip').textContent = snStrip;
        modal.querySelector('#snApi').textContent = snApi;

        const cmds = `# Re-scan and update status JSON
node ./test/scanApps.js

# Install a snippet into apps/<name>.conf and reload
./scripts/install-app.sh myapp examples/next/myapp.conf || true
docker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#cmds').textContent = cmds;

        const copyAllBtn = modal.querySelector('#copyAll');
        modal.querySelector('#copyAll').addEventListener('click',()=>{
          const all = [snKeep, snStrip, snApi, cmds].join('\n\n');
          navigator.clipboard.writeText(all).then(()=>{
            copyAllBtn.classList.add('copied');
            const prev = copyAllBtn.textContent;
            copyAllBtn.textContent = 'Copied!';
            setTimeout(()=>{ copyAllBtn.textContent = prev; copyAllBtn.classList.remove('copied'); }, 1500);
          });
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      initTheme();

      // ===== AI Assistant Wiring =====
      // Healing History Management
      let healingHistory = [];
      let isHealing = false;
      
      async function loadHealingHistory() {
        try {
          const response = await fetch('/.artifacts/calliope/healing-log.json');
          if (response.ok) {
            const data = await response.json();
            healingHistory = data.entries || [];
            updateHealingUI();
          } else {
            console.log('No healing history found');
          }
        } catch (e) {
          console.log('Error loading healing history', e);
        }
      }
      
      function updateHealingUI() {
        const badge = document.getElementById('healingBadge');
        const countEl = badge.querySelector('.healing-count');
        const count = healingHistory.length;
        
        // Update badge
        countEl.textContent = count > 99 ? '99+' : count;
        badge.style.display = count > 0 ? 'flex' : 'none';
        
        // Update healing status in header
        const statusEl = document.getElementById('aiHealingStatus');
        const statusLabelEl = document.getElementById('aiHealingStatusLabel');
        const countHeaderEl = document.getElementById('aiHealingCount');
        
        // Only adjust label if not overridden by refreshHealth state mapping
        if (isHealing) {
          statusEl.classList.remove('status-ready','status-auditing','status-coding','status-offline');
          statusEl.classList.add('status-healing');
          statusLabelEl.textContent = '😵‍💫 Confused';
        }
        
        countHeaderEl.textContent = count > 0 ? `(${count})` : '';
        
        // Update history panel
        const historyList = document.getElementById('healingHistoryList');
        
        if (count === 0) {
          historyList.innerHTML = '<div class="empty-history">No healing actions recorded yet.</div>';
          return;
        }
        
        historyList.innerHTML = '';
        
        // Show most recent entries first (limit 10 per spec)
        const recentEntries = [...healingHistory].reverse().slice(0, 10);
        
        recentEntries.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = `healing-entry ${entry.success ? 'success' : 'failure'}`;
          
          const header = document.createElement('div');
          header.className = 'healing-entry-header';
          
          const issue = document.createElement('div');
          issue.className = 'healing-entry-issue';
          issue.textContent = entry.issue || 'Unknown issue';
          
          const timestamp = document.createElement('div');
          timestamp.className = 'healing-entry-timestamp';
          timestamp.textContent = new Date(entry.timestamp).toLocaleString();
          
          header.appendChild(issue);
          header.appendChild(timestamp);
          
          const details = document.createElement('div');
          details.className = 'healing-entry-details';
          
          if (entry.success) {
            details.textContent = `Successfully applied ${entry.solution}`;
          } else {
            details.textContent = entry.details?.error || 'Failed to heal';
          }
          
          const actions = document.createElement('div');
          actions.className = 'healing-entry-actions';
          
          const viewBtn = document.createElement('button');
          viewBtn.textContent = 'View Details';
          viewBtn.addEventListener('click', () => {
            // Open a modal with details
            const detailsStr = JSON.stringify(entry.details || {}, null, 2);
            alert(`Healing Details:\n${detailsStr}`);
          });
          
          actions.appendChild(viewBtn);
          
          entryEl.appendChild(header);
          entryEl.appendChild(details);
          entryEl.appendChild(actions);
          
          historyList.appendChild(entryEl);
        });
      }
      
      async function runSelfHeal() {
        if (isHealing) return;
        
        isHealing = true;
        updateHealingUI();
        
        try {
          // Append a message showing we're starting healing
          appendBubble('assistant', `<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;vertical-align:middle;"> Starting self-healing process... This might take a moment.`);
          
          const thinking = appendThinking();
          
          // Call the advanced healing API
          const response = await fetch('/api/ai/advanced-heal', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          
          thinking.remove();
          
          if (response.ok) {
            const result = await response.json();
            
            // Format the result as a message
            let message = '✨ Self-healing complete!\n\n';
            
            if (result.result.success) {
              message += `${result.result.message || 'The healing was successful.'}\n\n`;
              
              if (result.result.steps) {
                message += 'Steps performed:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}\n`;
                });
              }
              
              if (result.result.appliedStrategies && result.result.appliedStrategies.length > 0) {
                message += '\nApplied strategies:\n';
                result.result.appliedStrategies.forEach(strategy => {
                  message += `- ${strategy.issue}: ${strategy.result.message || strategy.result.success ? 'Success' : 'Failed'}\n`;
                });
              }
              
              message += '\nYour proxy should be working correctly now!';
            } else {
              message += 'The healing process encountered some issues.\n\n';
              
              if (result.result.error) {
                message += `Error: ${result.result.error}\n\n`;
              }
              
              if (result.result.steps) {
                message += 'Steps attempted:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}${step.error ? ` (${step.error})` : ''}\n`;
                });
              }
              
              message += '\nYou might need to manually fix some issues.';
            }
            
            appendBubble('assistant', message);
            
            // Refresh healing history after a delay
            setTimeout(() => {
              loadHealingHistory();
            }, 2000);
            
          } else {
            const errorText = await response.text();
            appendBubble('assistant', `❌ Self-healing failed: ${errorText || response.statusText}`);
          }
        } catch (e) {
          appendBubble('assistant', `❌ Error during self-healing: ${e.message}`);
        } finally {
          isHealing = false;
          updateHealingUI();
        }
      }
      
      async function initAiAssistant(){
        const drawer = document.getElementById('aiDrawer');
        const tab = document.getElementById('aiTab');
        const statusEl = document.getElementById('aiStatus');
        const indexEl = document.getElementById('aiIndex');
        const chatEl = document.getElementById('aiChat');
        const askBtn = document.getElementById('aiAskBtn');
        const clearBtn = document.getElementById('aiClearBtn');
        const copyBtn = document.getElementById('aiCopyBtn');
        const healBtn = document.getElementById('aiHealBtn');
        const queryEl = document.getElementById('aiQuery');
        // Persisted chat history loader
        async function loadChatHistory(){
          try{
            const resp = await fetch('/api/ai/chat-history');
            if (!resp.ok) return;
            const data = await resp.json().catch(()=>null);
            const messages = (data && data.messages) || [];
            // Render last 100 to keep UI snappy
            const recent = messages.slice(-100);
            recent.forEach(m => {
              const who = (m.role === 'assistant') ? 'assistant' : 'user';
              appendBubble(who, m.content||'');
            });
          }catch{}
        }

        // Wire the always-visible Diagnose button to trigger a self-check heal
        try{
          if (healBtn){
            healBtn.addEventListener('click', async ()=>{
              try{
                const q = document.getElementById('aiQuery');
                const drawer = document.getElementById('aiDrawer');
                if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
                chatEngaged = true; hasUserMessage = true;
                appendBubble('assistant', 'Heya! One sec while I listen to /api/...');
                await fetch('/api/ai/self-check', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ heal:true }) });
              }catch{}
            });
          }
        }catch{}

        // Thought polling for progress breadcrumbing
        let thoughtsTimer = null;
        let healthTimer = null;
        let chatEngaged = false; // set true after first user action or diagnose
        let hasUserMessage = false; // guarantees first visible bubble can be user
        function startThoughtsPolling(){
          if (thoughtsTimer) return;
          thoughtsTimer = setInterval(async ()=>{
            try{
              const r = await fetch('/api/ai/thoughts', { headers: { 'ngrok-skip-browser-warning': 'true' }, cache: 'no-cache' });
              if (!r.ok) return;
              const d = await r.json().catch(()=>null);
              const evs = (d && d.events) || [];
              evs.forEach(ev => {
                const msg = (ev && ev.message) ? String(ev.message) : '';
                const det = ev && ev.details || {};
                if (msg) {
                  console.debug('[Calliope][thought]', msg, det);
                  appendBubble('assistant', msg);
                }
                // Map thought tags to status chip state heuristically
                const statusChip = document.getElementById('aiHealingStatus');
                const labelEl = document.getElementById('aiHealingStatusLabel');
                const lower = msg.toLowerCase();
                const setState = (cls, text)=>{
                  statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding','status-offline');
                  statusChip.classList.add(cls);
                  labelEl.textContent = text;
                };
                if (/working…|working\.\.\./.test(lower)) ; else
                if (/auditing/.test(lower) || /audit/.test(lower)) setState('status-auditing','🔬 Auditing');
                else if (/healing/.test(lower) || /heal/.test(lower)) setState('status-healing','💖 Healing');
                else if (/code review|snapshot|analyz|review/i.test(lower)) setState('status-coding','🛠️ Coding');
                else if (/complete ✅|all clear|finished|done/i.test(lower)) setState('status-ready','😊 Happy');
              });
            }catch{}
          }, 2000);
        }
        // Open drawer on tab click and mark engagement
        try{
          if (tab){
            tab.addEventListener('click', function(){
              try{ const d = document.getElementById('aiDrawer'); if (d){ d.classList.remove('collapsed'); document.body.classList.add('ai-open'); } }catch{}
              chatEngaged = true;
              setTimeout(()=>{ const q=document.getElementById('aiQuery'); if(q) q.focus(); }, 50);
            });
          }
        }catch{}

        function startHealthPolling(){
          if (healthTimer) return;
          healthTimer = setInterval(()=>{
            refreshHealth().catch((e)=>{ try{ console.debug('[Calliope][health] error', e&&e.message); }catch{} });
          }, 2000);
        }

        
        // Healing history elements
        const healingBadge = document.getElementById('healingBadge');
        const healingHistory = document.getElementById('healingHistory');
        const closeHistoryBtn = document.querySelector('.close-history');

        async function refreshHealth(){
          try {
            const health = await fetch('/api/ai/health');
            if (!health.ok) throw new Error('disabled');
            const healthJson = await health.json();
            if (statusEl) statusEl.textContent = healthJson.enabled ? `Enabled${healthJson.model?` (${healthJson.model})`:''}` : 'Disabled (no key)';
            // Toggle UI affordances when Calliope is enabled
            const calliopeEnabled = healthJson.enabled; // Only enable Calliope when API key is present
            window.__calliopeEnabled = calliopeEnabled;
            document.body.classList.toggle('calliope-enabled', calliopeEnabled);
            toggleCalliopeAffordances(calliopeEnabled);

            // Update Calliope status chip color and label
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            
            const setState = (cls, text)=>{
              statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding','status-offline');
              statusChip.classList.add(cls);
              labelEl.textContent = text;
            };

            if (!healthJson.enabled || healthJson.healthy===false){
              setState('status-offline','🫥 AFK');
            } else {
              // Prefer explicit activity if provided by API
              const activity = (healthJson.activity||'').toLowerCase();
              if (activity === 'healing') setState('status-healing','💖 Healing');
              else if (activity === 'auditing') setState('status-auditing','🔬 Auditing');
              else if (activity === 'coding') setState('status-coding','🛠️ Coding');
              else setState('status-ready','😊 Happy');
            }
          } catch {
            if (statusEl) statusEl.textContent = 'Unavailable';
            // Fallback: disable Calliope UI affordances when API health check fails (no API key)
            document.body.classList.remove('calliope-enabled');
            try { toggleCalliopeAffordances(false); } catch(e) {}
            const statusChip = document.getElementById('aiHealingStatus');
            statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding');
            statusChip.classList.add('status-offline');
            statusChip.querySelector('.ai-healing-label').textContent = 'Offline';
          }
          try {
            const s = await fetch('/api/ai/stats');
            if (s.ok){ const sj = await s.json(); if(indexEl) indexEl.textContent = sj.exists ? `${sj.chunks} chunks • ${sj.model||''}`.trim() : 'No index'; }
            else if(indexEl) indexEl.textContent = '—';
          } catch { if(indexEl) indexEl.textContent = '—'; }
        }

        function toggleCalliopeAffordances(enabled){
          console.log('🔧 toggleCalliopeAffordances called with enabled:', enabled);
          
          // Hide Recommend buttons
          const recButtons = Array.from(document.querySelectorAll('a.btn, button.btn')).filter(el=>/Recommend/i.test(el.textContent||''));
          recButtons.forEach(el=> el.style.display = enabled ? 'none' : '');
          console.log('🔧 Found', recButtons.length, 'recommend buttons to hide');
          
          // NUCLEAR APPROACH: Find ANY button with stethoscope or aria-label Diagnose and override completely
          const candidates = Array.from(document.querySelectorAll('button, .icon-btn')).filter(el => {
            const label = el.getAttribute('aria-label') || '';
            const text = el.textContent || '';
            return /Diagnose/i.test(label) || text.includes('Diagnose') || el.querySelector('img[src*="calliope_heart_stethoscope"]');
          });
          candidates.forEach(el => {
            const parent = el.parentNode; if (!parent) return;
            const clone = el.cloneNode(true);
            parent.replaceChild(clone, el);
            clone.onclick = function(e){
              e.preventDefault(); e.stopPropagation();
              const route = clone.dataset.route || clone.closest('[data-route]')?.dataset?.route;
              if (enabled){
                // When Calliope is enabled, run her health check for the specific route
                if (route) {
                  runCalliopeHealth(route);
                } else {
                  // Fallback: just open the drawer if no route is found
                  const drawer = document.getElementById('aiDrawer');
                  drawer.classList.remove('collapsed');
                  document.body.classList.add('ai-open');
                  setTimeout(()=>{ const q=document.getElementById('aiQuery'); if(q) q.focus(); },100);
                }
              } else {
                // When Calliope is disabled, use the standard diagnose modal
                if (route) openDiagnoseModal(route, targets, routes);
              }
            };
            // Update accessibility labels and titles for all stethoscope/diagnose buttons
            if (enabled){ clone.title='Calliope'; clone.setAttribute('aria-label','Calliope'); }
            else { clone.title='Diagnose'; clone.setAttribute('aria-label','Diagnose'); }
          });
        }

        // Global delegated handler to ensure Calliope runs when enabled,
        // even if buttons were (re)rendered after our overrides.
        // Uses capture phase to pre-empt older listeners.
        document.addEventListener('click', function(e){
          try{
            const enabled = !!window.__calliopeEnabled || document.body.classList.contains('calliope-enabled');
            if (!enabled) return;
            const target = e.target && (e.target.closest && e.target.closest('button, .circular-action-btn, .icon-btn'));
            if (!target) return;
            const label = target.getAttribute('aria-label') || '';
            const text = target.textContent || '';
            const hasStethoscope = !!target.querySelector && !!target.querySelector('img[src*="calliope_heart_stethoscope"]');
            const isDiagnoseLike = /Diagnose/i.test(label) || text.includes('Diagnose') || hasStethoscope;
            if (!isDiagnoseLike) return;

            // Determine route context robustly
            let route = null;
            const routeContainer = target.closest && target.closest('[data-route]');
            if (routeContainer && routeContainer.dataset && routeContainer.dataset.route) route = routeContainer.dataset.route;
            if (!route && target.dataset && target.dataset.route) route = target.dataset.route;
            if (!route){
              const header = target.closest && target.closest('.route-header');
              const nameEl = header && header.querySelector && header.querySelector('.route-name');
              if (nameEl && nameEl.textContent) route = nameEl.textContent.trim();
            }
            if (!route) route = '/sdk';

            // Override default behavior
            e.preventDefault();
            e.stopPropagation();
            if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

            // Run Calliope health flow, but if not ready yet, queue it
            try {
              if (typeof runCalliopeHealth === 'function') { runCalliopeHealth(route); }
              else {
                window.__pendingDiagnoseRoute = route || '/sdk';
                const drawer = document.getElementById('aiDrawer');
                if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
              }
            } catch(err){
              const drawer = document.getElementById('aiDrawer');
              if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
            }
          }catch(_e){ /* non-fatal */ }
        }, true);

        async function onAsk(){
          const q = (queryEl.value||'').trim();
          if (!q){ return; }
          // Mark user engagement BEFORE any possible assistant thought rendering
          if (!hasUserMessage) hasUserMessage = true;
          chatEngaged = true;
          askBtn.disabled = true; askBtn.textContent = 'Thinking…';
          // Clear the input immediately so the user can type next question
          queryEl.value = '';
          
          // Append user bubble first so it appears before any thinking indicator
          const firstUser = appendBubble('user', q);
          // Now show thinking animation for at least a short time
          const thinking = appendThinking();
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 800));
          
          try{
            const [resp] = await Promise.all([
              fetch('/api/ai/ask', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ query: q }) }),
              minThinkingTime
            ]);
            
            // Remove thinking indicator
            thinking.remove();
            
            const data = await resp.json().catch(()=>null);
            if (!resp.ok){ appendBubble('assistant', (data&&data.error) ? `Error: ${data.error}` : `HTTP ${resp.status}`); }
            else {
              // Friendly rendering: interpret JSON summaries into human text
              const raw = (data.answer||'').trim();
              const friendly = raw
                .replace(/\{\s*"consoleErrors"\s*:\s*(\d+).*?\}/gs, (m)=>{
                  try{ const obj = JSON.parse(m); return `No console errors, ${obj.networkFailures||0} network failures, ${obj.httpIssues||0} HTTP issues.`; }catch{ return m; }
                })
                .replace(/```json[\s\S]*?```/g, '') // hide raw JSON blocks
                .replace(/Report:\n```[\s\S]*?```/g, '') // hide report path blocks
                .replace(/Pass (\d+) summary:/g, 'Pass $1:')
                .replace(/Delta vs previous pass:/g, 'Change since last pass:');
              appendBubble('assistant', friendly);
            }
          } catch(e){ 
            thinking.remove(); 
            appendBubble('assistant', `Request failed: ${e.message}`); 
          }
          finally{ askBtn.disabled = false; askBtn.textContent = 'Ask'; }
        }

        async function onReindex(){
          reindexBtn.disabled = true; reindexBtn.textContent = 'Indexing…';
          try{
            const resp = await fetch('/api/ai/reindex', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
            const data = await resp.json().catch(()=>null);
            if (!resp.ok){ alert(`Reindex failed: ${(data&&data.error)||('HTTP '+resp.status)}`); }
            else { appendBubble('assistant', 'Knowledge index rebuilt ✅'); }
          } catch(e){ alert('Reindex error: '+e.message); }
          await refreshHealth();
          reindexBtn.disabled = false; reindexBtn.textContent = 'Reindex';
        }

        function appendBubble(who, text){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          
          // Add chat bubble titles
          const titleEl = document.createElement('div');
          titleEl.className = 'bubble-title';
          if (who === 'user') {
            titleEl.innerHTML = '🧑 You';
          } else {
            titleEl.innerHTML = '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;vertical-align:middle;"> Calliope';
          }
          b.appendChild(titleEl);
          
          // Create content area
          const contentEl = document.createElement('div');
          contentEl.className = 'bubble-content';
          
          if (who === 'assistant'){
            try{
              const html = DOMPurify.sanitize(marked.parse(text || ''));
              contentEl.innerHTML = html;
            }catch{ contentEl.textContent = text; }
          } else {
            contentEl.textContent = text;
          }
          b.appendChild(contentEl);
          
          chatEl.appendChild(b);
          
          // Hide placeholder if this is the first user message
          if (who === 'user' && chatEl.children.length === 1) {
            queryEl.placeholder = '';
          }
          
          // Scroll behavior:
          // - For user messages, scroll to bottom so the sent message is visible
          // - For assistant replies, align the top of the new bubble to the top of the chat (if possible)
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }
        
        // Appends raw HTML content in a bubble (for complex elements like tables)
        function appendHTMLContent(who, html){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          // Directly inject the HTML without markdown parsing
          b.innerHTML = DOMPurify.sanitize(html);
          chatEl.appendChild(b);
          // Scroll to show the new content
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }

        function appendThinking(){
          const b = document.createElement('div');
          b.className = 'bubble assistant thinking';
          const span = document.createElement('span');
          span.className = 'dots';
          span.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
          b.appendChild(span);
          chatEl.appendChild(b);
          chatEl.scrollTop = chatEl.scrollHeight;
          return b;
        }

        function ensureAiOpen(){
          const drawer = document.getElementById('aiDrawer');
          if (drawer.classList.contains('collapsed')){
            drawer.classList.remove('collapsed');
            document.body.classList.add('ai-open');
          }
        }

        async function runCalliopeHealth(routeKey){
          try{
            if (window.__pendingDiagnoseRoute){ delete window.__pendingDiagnoseRoute; }
          }catch{}
          chatEngaged = true;
          ensureAiOpen();
          // First message - acknowledgment (append after recording engagement but before server work)
          appendBubble('assistant', `Heya! One sec while I listen to ${routeKey}...`);
          
          // Show thinking indicator briefly while we kick off background audit+heal
          let thinking = appendThinking();
          // Immediately reflect active state in the status chip
          try {
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            statusChip.classList.remove('status-ready','status-offline');
            statusChip.classList.add('status-auditing');
            labelEl.textContent = '🔬 Auditing';
          } catch {}
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 900));
          
          try{
            // Use container-reachable base; prefer ngrok origin if present, else dev-proxy
            const origin = window.location.origin || '';
            let baseForAudit = 'http://dev-proxy';
            try { const h = (new URL(origin)).hostname||''; if (/\.ngrok\.app$/i.test(h)) baseForAudit = origin; } catch {}
            const cleanRoute = routeKey.endsWith('/') ? routeKey : (routeKey + '/');
            const urlToAudit = (baseForAudit.replace(/\/$/, '')) + cleanRoute;
            const selfCheck = (async ()=>{
              try{
                await fetch('/api/ai/self-check', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ heal: true, route: routeKey, hint: `Focus on route ${routeKey} and its children.` })
                });
              }catch{}
            })();
            const [resp] = await Promise.all([
              fetch('/api/ai/audit-and-heal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: urlToAudit, route: routeKey, maxPasses: 3, wait: 1500, timeout: 45000 })
              }),
              minThinkingTime,
              selfCheck
            ]);
            thinking.remove();
            if (!resp.ok){
              const friendly = `\nI hit a little hiccup starting my check (HTTP ${resp.status}).\n`+
                `Here’s what I’d try next:`+
                `\n- Click “Ask” with: 
\`Please audit and heal /sdk (and give yourself the Storybook/Vite knowledge you need).\``+
                `\n- Or open my thinking stream: <a href="/api/ai/thoughts" target="_blank" rel="noopener">/api/ai/thoughts</a>`;
              appendBubble('assistant', friendly);
              // reset chip back to ready so UI doesn’t look stuck on Auditing
              try{
                const statusChip = document.getElementById('aiHealingStatus');
                const labelEl = document.getElementById('aiHealingStatusLabel');
                statusChip.classList.remove('status-auditing','status-healing','status-coding');
                statusChip.classList.add('status-ready');
                labelEl.textContent = '😊 Happy';
              }catch{}
              return;
            }
            const data = await resp.json().catch(()=>null);
            if (data && data.ok){
              appendBubble('assistant', 'Working on it — I\'ll stream my steps as they happen.');
            } else {
              const msg = (data && data.result && data.result.message) ? data.result.message : 'Couldn\'t proceed with audit+heal just now.';
              appendBubble('assistant', `⚠️ ${msg}`);
            }
            // Thoughts polling is active and will stream intermediate steps
          } catch(e){
            try { thinking.remove(); } catch{}
            const friendly = `\nOops, my ears got tangled while starting the check: ${e.message}.`+
              `\nTry asking: \`Audit and heal /sdk; add Storybook/Vite proxy guards and host allowances.\``+
              `\nPeek at my thoughts: <a href="/api/ai/thoughts" target="_blank" rel="noopener">/api/ai/thoughts</a>`;
            appendBubble('assistant', friendly);
            try{
              const statusChip = document.getElementById('aiHealingStatus');
              const labelEl = document.getElementById('aiHealingStatusLabel');
              statusChip.classList.remove('status-auditing','status-healing','status-coding');
              statusChip.classList.add('status-ready');
              labelEl.textContent = '😊 Happy';
            }catch{}
          }
        }

        // Expose for inline handlers and external triggers
        try { window.runCalliopeHealth = runCalliopeHealth; } catch {}

        askBtn.addEventListener('click', onAsk);
        clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; queryEl.value=''; queryEl.focus(); });
        copyBtn.addEventListener('click', onCopy);
        queryEl.addEventListener('keydown', (e)=>{
          if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); }
        });
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        tab.addEventListener('click', ()=>{
          const collapsed = drawer.classList.toggle('collapsed');
          document.body.classList.toggle('ai-open', !collapsed);
          try{
            if (!collapsed && window.__pendingDiagnoseRoute){
              const r = window.__pendingDiagnoseRoute; delete window.__pendingDiagnoseRoute; runCalliopeHealth(r);
            }
          }catch{}
        });
        askBtn.addEventListener('click', onAsk);
        clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; queryEl.value=''; queryEl.focus(); });
        copyBtn.addEventListener('click', onCopy);
        queryEl.addEventListener('keydown', (e)=>{
          if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); }
        });
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        
        // Healing UI handlers
        healBtn.addEventListener('click', runSelfHeal);
        
        healingBadge.addEventListener('click', (e) => {
          e.stopPropagation();
          healingHistory.classList.toggle('visible');
        });
        
        closeHistoryBtn.addEventListener('click', () => {
          healingHistory.classList.remove('visible');
        });
        
        // Initialize healing history
        try {
          await loadHealingHistory();
        } catch (e) {
          console.log('Error loading healing history', e);
        }
        
        // Hide healing status initially if empty
        const aiHealingStatus = document.getElementById('aiHealingStatus');
        if (healingHistory.length === 0) {
          aiHealingStatus.style.display = 'none';
        }
        
        // Expose minimal debug helpers
        window.__calliopeDebug = {
          setStatus: (s)=>{
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            const map = { ready:['status-ready','😊 Happy'], healing:['status-healing','💖 Healing'], auditing:['status-auditing','🔬 Auditing'], coding:['status-coding','🛠️ Coding'], offline:['status-offline','🫥 AFK'] };
            const m = map[(s||'').toLowerCase()]||map.ready;
            statusChip.className = 'ai-healing-status ' + m[0];
            labelEl.textContent = m[1];
          },
          pingThought:(m)=>fetch('/api/ai/thoughts/clear',{method:'POST'}).then(()=>appendBubble('assistant', m||'debug thought'))
        };

        // Load persisted chat first, then current health, then begin thoughts polling
        try{
          const wantPersist = (localStorage.getItem('calliopePersistChat') === '1');
          if (wantPersist){ await loadChatHistory(); }
          else { chatEl.innerHTML = ''; }
        }catch{ /* default: no persisted chat during normal/status tests */ }
        await refreshHealth();
        startThoughtsPolling();
        startHealthPolling();

        // Allow user to stop current work by clicking the status chip
        const statusChip = document.getElementById('aiHealingStatus');
        statusChip.addEventListener('click', async ()=>{
          try{
            const r = await fetch('/api/ai/cancel', { method:'POST' });
            if (r.ok){
              appendBubble('assistant', "Oops, I’ll pause now — my hyper‑focus ran away with me! 💫 I’ve stopped and I’m ready to help however you like next.");
            }
          }catch{}
        });

        // Wire global diagnose button to focus the first SDK group or fallback to /sdk
        const bindDiag = (el)=>{
          if (!el) return;
          el.addEventListener('click', (e)=>{
            e.preventDefault(); e.stopPropagation();
            // Try to find a route named /sdk first
            const sdkChip = document.querySelector('[data-route="/sdk"]') || document.querySelector('.route-name');
            const route = sdkChip && (sdkChip.getAttribute && sdkChip.getAttribute('data-route')) || '/sdk';
            runCalliopeHealth(route);
          });
        };
        // legacy buttons removed
      }
    </script>
  </body>
  </html>


