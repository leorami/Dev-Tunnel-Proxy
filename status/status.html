<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dev Proxy Status</title>
    <link rel="icon" type="image/svg+xml" href="/status/assets/favicon.svg" />
    <link rel="icon" type="image/png" href="/status/assets/favicon.png" />
    <link rel="shortcut icon" href="/status/assets/favicon.svg" />
    <style>
      :root{--bg:#0c111c;--bg2:#0e1627;--panel:#101827;--panelGlass:rgba(16,24,39,.92);--appBgGlass:rgba(13,20,36,.95);--border:#1f2a44;--muted:#8a9bb7;--text:#e4ecfa;--heading:#cfe0ff;--chip:#1a2440;--chipBg:#132140;--chipBorder:#263455;--chipText:#b8c8e6;--ok:#16c784;--warn:#f59e0b;--err:#ef4444;--lnk:#7fb0ff;--btnBg:rgba(19,42,77,.45);--btnBorder:rgba(58,110,174,.55);--btnText:#cfe0ff;--btnBgHover:rgba(22,52,95,.6);--headerBg:rgba(10,16,30,.55);--codeBg:#0a1223;--codeBorder:#1b2a48;--glowOpacity:.10;--summaryGap:24px}
      :root[data-theme="light"]{--bg:#edf2fb;--bg2:#f7faff;--panel:#ffffff;--panelGlass:rgba(255,255,255,.88);--appBgGlass:rgba(255,255,255,.9);--border:#d6e0f5;--muted:#5b6b8a;--text:#0b1220;--heading:#0b1220;--chip:#e8eefc;--chipBg:#eef2ff;--chipBorder:#cddcff;--chipText:#0b1220;--ok:#0f9d6a;--warn:#b7791f;--err:#c24141;--lnk:#2d6cdf;--btnBg:#eef2ff;--btnBorder:#bfd1ff;--btnText:#0b1220;--btnBgHover:#e2e8ff;--headerBg:rgba(255,255,255,.78);--codeBg:#f6f8ff;--codeBorder:#d6e0f5;--glowOpacity:.14}
      *{box-sizing:border-box}
      body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans}
      header{padding:16px 20px 12px 20px;border-bottom:1px solid var(--border);background:var(--headerBg);backdrop-filter:saturate(180%) blur(10px);position:sticky;top:0;z-index:1000;box-shadow:0 10px 30px rgba(0,0,0,.25)}
      .header-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .header-actions{display:flex;gap:8px;align-items:center}
      header h1{font-size:16px;margin:0;display:flex;gap:10px;align-items:center}
      header h1 span{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--chip);color:var(--text);font-weight:600}
      .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding-top:4px}
      .toolbar.centered{justify-content:center;margin:20px auto 18px}
      .toolbar .field{display:flex;gap:6px;align-items:center}
      .toolbar select,.toolbar input[type="text"]{background:var(--btnBg);border:1px solid var(--btnBorder);color:var(--btnText);border-radius:8px;padding:7px 10px}
      .btn{appearance:none;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600;text-decoration:none;text-align:center;backdrop-filter:saturate(160%) blur(6px);box-shadow:inset 0 1px 0 rgba(255,255,255,.05), 0 4px 18px rgba(0,0,0,.25)}
      .btn:hover{background:var(--btnBgHover)}
      .btn:active{transform:translateY(1px)}
      .btn.copied{background:#16402b;border-color:#2a7f54;color:#a6f3cc}
      .container{max-width:1100px;margin:24px auto;padding:0 16px}
      .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-bottom:16px}
      .summaryRow{position:sticky;top:calc(var(--headerH, 64px) + var(--summaryGap, 12px));z-index:2004;background:var(--headerBg);backdrop-filter:saturate(180%) blur(8px)}
      .appsHeader{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;position:sticky;top:calc(var(--headerH, 64px) + var(--summaryH, 0px));z-index:590;background:var(--headerBg);border:1px solid var(--border);border-radius:10px;padding:8px 12px}
      .appsHeader .toolbar{padding-top:0}
      .card{background:var(--panelGlass);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25);backdrop-filter:saturate(160%) blur(6px);transition:box-shadow .12s ease}
      .card:hover{box-shadow:0 10px 28px rgba(0,0,0,.30)}
      .card h2{margin:0 0 10px 0;font-size:14px;color:var(--heading);letter-spacing:.2px}
      .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
      .apps-controls{justify-content:flex-start}
      .field{display:inline-block;margin-right:10px}
      .label{color:var(--muted)}
      .value{font-weight:600}
      .ok{color:var(--ok)}.warn{color:var(--warn)}.err{color:var(--err)}
      .apps{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
      .app{background:var(--appBgGlass);border:1px solid var(--border);border-radius:10px;padding:12px;transition:transform .12s ease, box-shadow .12s ease;box-shadow:inset 0 1px 0 rgba(255,255,255,.02);position:relative;padding-right:80px}
      .app:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .app.ok{border-color:rgba(22,199,132,.7);box-shadow:0 0 0 2px rgba(22,199,132,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.warn{border-color:rgba(245,158,11,.7);box-shadow:0 0 0 2px rgba(245,158,11,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.err{border-color:rgba(239,68,68,.8);box-shadow:0 0 0 2px rgba(239,68,68,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app .route{font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
      .groupHead{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .groupHead .chips{gap:6px}
      .groupHead .btn-small{font-size:12px;padding:6px 10px}
      .chip{display:inline-flex;gap:6px;align-items:center;padding:5px 8px;border-radius:999px;background:var(--chipBg);border:1px solid var(--chipBorder);color:var(--chipText);font-weight:600;position:relative}
      .chip.ok{background:rgba(22,199,132,.12);border-color:rgba(22,199,132,.35);color:#8ef0c3}
      .chip.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.35);color:#ffd38a}
      .chip.err{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:#ffb1b1}
      .chip[data-tip]:hover:after{content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:calc(100% + 8px);white-space:pre-wrap;max-width:280px;background:#0a1223;color:#d9e2f1;border:1px solid #1b2a48;border-radius:8px;padding:8px;box-shadow:0 10px 30px rgba(0,0,0,.45);z-index:30}
      .chip[data-tip]:hover:before{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:100%;border:6px solid transparent;border-top-color:#1b2a48}
      .chip a{color:var(--lnk);text-decoration:none}
      .view{margin-top:12px}
      pre{margin:0;background:var(--codeBg, #0a1223);border:1px solid var(--codeBorder, #1b2a48);padding:12px;border-radius:10px;max-height:420px;overflow:auto}
      .switch{display:flex;gap:8px;align-items:center}
      .hidden{display:none}
      /* Modal */
      .backdrop{position:fixed;inset:0;background:rgba(3,8,20,.55);backdrop-filter:saturate(160%) blur(10px);display:flex;align-items:center;justify-content:center;padding:16px;z-index:2000;overflow:auto}
      .modal{max-width:860px;width:min(860px,96vw);background:rgba(16,24,39,.92);backdrop-filter:saturate(160%) blur(6px);border:1px solid #2a3a62;border-radius:12px;box-shadow:0 24px 70px rgba(0,0,0,.65), inset 0 1px 0 rgba(255,255,255,.04);padding:16px;max-height:calc(100vh - 48px);overflow:auto;z-index:2002}
      .modal h2{margin:0 0 8px 0;color:#cfe0ff;font-size:16px}
      .modal .section{margin:10px 0;padding:10px;border:1px dashed #2a3a62;border-radius:8px;background:#0d1424}
      .modal .section h3{margin:0 0 6px 0;font-size:13px;color:#bcd3ff}
      .modal pre{max-height:280px}
      .modal .toolbar{display:flex;gap:8px;justify-content:flex-end;margin-top:10px;position:sticky;bottom:0;background:linear-gradient(180deg, rgba(16,24,39,0), rgba(16,24,39,.85) 30%, rgba(16,24,39,.95));padding-top:12px;border-top:1px solid #2a3a62;backdrop-filter:saturate(160%) blur(6px);z-index:5}

      /* Conflict Management Styles */
      .conflict-item{border:1px solid var(--border);border-radius:12px;padding:20px;margin-bottom:16px;background:var(--panelGlass);backdrop-filter:saturate(160%) blur(6px)}
      .conflict-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
      .conflict-header h3{margin:0;color:var(--heading);font-size:16px}
      .conflict-status{color:var(--muted);font-size:14px}
      .conflict-options{display:flex;flex-direction:column;gap:15px}
      .conflict-configs{display:flex;flex-direction:column;gap:10px}
      .config-option{display:flex;align-items:center;padding:12px;border:2px solid var(--border);border-radius:8px;cursor:pointer;background:var(--appBgGlass);transition:all 0.2s;backdrop-filter:saturate(160%) blur(4px)}
      .config-option:hover{border-color:var(--lnk);transform:translateY(-1px)}
      .config-option.active{border-color:var(--ok);background:rgba(22,199,132,.08)}
      .config-option input[type="radio"]{margin-right:10px}
      .config-name{font-weight:500;flex:1;color:var(--heading)}
      .config-actions{display:flex;gap:8px;margin-left:auto}
      .conflict-actions{display:flex;gap:10px;justify-content:flex-end}
      .btn-small{padding:6px 12px;font-size:12px;border:1px solid var(--border);background:var(--btnBg);color:var(--btnText);border-radius:6px;cursor:pointer;transition:all 0.2s}
      .btn-small:hover{background:var(--btnBgHover);transform:translateY(-1px)}

      /* Config Modal Styles */
      .modal.large{max-width:1200px;width:min(1200px,96vw)}
      .config-modal{color:var(--text)}
      .config-actions{margin-bottom:15px;display:flex;gap:10px}
      .config-display{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:var(--codeBg);color:var(--codeText);max-height:500px;overflow:auto}
      .config-editor{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:#0d1424;color:#d9e2f1;resize:vertical;min-height:400px}
      .edit-actions{margin-top:15px;display:flex;gap:10px;justify-content:flex-end}

      /* Auto-Fix Suggestions Styles */
      .suggestion-item{border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:12px;background:var(--appBgGlass);backdrop-filter:saturate(160%) blur(4px)}
      .suggestion-item h3{margin:0 0 8px 0;color:var(--ok);font-size:14px}
      .suggestion-item p{margin:0 0 8px 0;color:var(--text);font-size:13px}
      .suggestion-item code{display:block;background:var(--codeBg);color:var(--codeText);padding:8px;border-radius:4px;margin:8px 0;font-family:var(--mono, monospace);font-size:12px}
      .suggestion-item .btn{margin-top:8px;font-size:12px}

      /* Global Conflict Indicator */
      .global-conflict-indicator{position:fixed;top:20px;right:20px;z-index:1000;animation:slideIn 0.3s ease-out}
      .conflict-badge{background:rgba(245,158,11,.15);border:2px solid var(--warn);border-radius:8px;padding:12px 16px;color:var(--warn);font-weight:600;display:flex;align-items:center;gap:12px;backdrop-filter:saturate(160%) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .conflict-badge button{background:var(--warn);color:#000;border:none;padding:6px 12px;border-radius:4px;font-weight:600;cursor:pointer;font-size:12px}
      .conflict-badge button:hover{opacity:0.9;transform:translateY(-1px)}
      @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}
      
      /* Healing Badge */
      .healing-badge{position:absolute;top:-12px;right:-12px;width:24px;height:24px;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);border-radius:50%;box-shadow:0 2px 5px rgba(0,0,0,.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:12px;cursor:pointer;transition:transform .2s ease;opacity:.85}
      .healing-badge:hover{opacity:1;transform:scale(1.15)}
      .healing-badge.active{animation:pulse 1.5s infinite}
      @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
      
      /* Healing History Panel */
      .healing-history{position:absolute;top:60px;right:48px;width:320px;background:var(--panelGlass);border:1px solid var(--border);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.4);backdrop-filter:saturate(160%) blur(6px);z-index:2010;padding:12px;display:none}
      .healing-history.visible{display:block}
      .healing-history h3{margin:0 0 10px 0;font-size:14px;display:flex;align-items:center;justify-content:space-between}
      .healing-history h3 button{background:none;border:none;cursor:pointer;font-size:16px;color:var(--muted);line-height:1}
      .healing-history-list{max-height:300px;overflow-y:auto}
      .healing-entry{margin-bottom:8px;padding:8px;border-radius:8px;background:rgba(125,162,255,.07);border:1px solid rgba(125,162,255,.15)}
      .healing-entry.success{border-color:rgba(22,199,132,.25);background:rgba(22,199,132,.07)}
      .healing-entry.failure{border-color:rgba(239,68,68,.25);background:rgba(239,68,68,.07)}
      .healing-entry-header{display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px}
      .healing-entry-issue{font-weight:bold}
      .healing-entry-timestamp{color:var(--muted);font-size:11px}
      .healing-entry-details{font-size:12px;margin-top:4px;word-break:break-word}
      .healing-entry-actions{display:flex;gap:8px;margin-top:6px}
      .healing-entry-actions button{font-size:11px;padding:3px 6px;border-radius:4px;cursor:pointer;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText)}
      .healing-entry-actions button:hover{background:var(--btnBgHover)}
      
      /* Healing Status Indicator in AI header */
      .ai-healing-status{font-size:12px;background:rgba(125,162,255,.1);padding:2px 6px;border-radius:999px;display:inline-flex;align-items:center;gap:4px}
      .ai-healing-status .pulse{width:6px;height:6px;border-radius:50%;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);display:inline-block}
      .ai-healing-status.active .pulse{animation:dotPulse 1s infinite ease-in-out}
      .ai-healing-count{color:var(--muted);font-size:11px}

      /* Hierarchical Route Styles */
      .expandable-route{position:relative}
      .route-header{cursor:pointer;padding:8px;border-radius:6px;transition:background-color 0.2s;display:flex;align-items:center;justify-content:space-between}
      .route-header:hover{background:rgba(255,255,255,.05)}
      .route-title{display:flex;align-items:center;gap:8px;font-weight:600}
      .expand-icon{transition:transform 0.2s;font-size:12px;width:12px}
      .route-name{font-size:16px}
      .child-count{font-size:12px;color:var(--muted);font-weight:400}
      .route-children{margin-top:8px;margin-left:20px;border-left:2px solid var(--border);padding-left:16px}
      .route-children.hidden{display:none}
      .child-route{margin-bottom:8px;padding:8px;background:var(--appBgGlass);border-radius:6px;border-left:3px solid var(--border)}
      .child-route-name{font-size:14px;color:var(--muted);margin-bottom:4px;flex:1}
      .child-route-header{display:flex;align-items:center;justify-content:space-between;padding:4px 0}
      .header-action-btn{background:none;border:none;color:var(--textSecondary);cursor:pointer;padding:4px 8px;border-radius:4px;transition:all 0.2s ease;font-size:14px}
      .header-action-btn:hover{background:rgba(255,255,255,.1);color:var(--text)}
      .route-header{display:flex;flex-direction:column;gap:6px;padding:8px;position:relative}
      .route-header:first-child{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .route-title{flex:1;display:flex;align-items:center;gap:8px}
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .chip.small{font-size:11px;padding:2px 6px;border-radius:10px}
      .chip.upstream-base{background:var(--chip);color:var(--muted);font-size:11px;font-weight:400}
      .chip.promoted-indicator{background:rgba(22,199,132,.2);border-color:rgba(22,199,132,.5);color:#16c784;font-size:10px;font-weight:700;margin-left:8px;padding:2px 6px}
      .btn-small{padding:4px 8px;font-size:11px;min-height:24px}
      .route-header .chips{display:flex;flex-wrap:wrap;gap:4px;align-items:center}
      .parent-status .chip{margin-right:4px}
      .child-summary{margin-top:2px}
      .child-summary .chip{background:var(--btnBg);border-color:var(--btnBorder);font-size:10px;padding:1px 4px}
      .route-controls{margin-top:4px}
      .route-controls .btn{margin-right:6px}
      .route-actions{position:absolute;top:8px;right:8px;display:flex;gap:6px;flex-wrap:wrap;z-index:10}
      .route-actions .btn{margin-right:6px;min-width:60px}
      /* Collapse controls */
      .collapse-toggle{position:absolute;top:8px;right:8px;border:1.5px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:999px;font-size:14px;width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05)}
      .collapse-toggle:hover{background:var(--btnBgHover)}
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .icon-actions .icon-btn{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border:1.5px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:999px;font-size:14px;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05)}
      .icon-actions .icon-btn:hover{background:var(--btnBgHover)}
      .icon-actions .icon-btn svg{width:18px;height:18px;display:block}
      .root-actions{position:absolute;top:8px;right:8px;display:flex;gap:8px;align-items:center}
      .collapsed-bar{display:none;align-items:center;gap:8px;font-weight:700}
      .app.collapsed .collapsed-bar{display:flex}
      .app.collapsed > *:not(.collapse-toggle):not(.collapsed-bar){display:none}

      /* Hover scroll helpers */
      .hover-scroll{overflow:auto}

      /* AI Drawer */
      :root{--aiWidth:clamp(420px, 36vw, 840px)}
      .ai-drawer{position:fixed;top:calc(var(--headerH, 64px) + var(--summaryGap, 12px));right:0;height:calc(100vh - (var(--headerH, 64px) + var(--summaryGap, 12px)));width:var(--aiWidth);z-index:2005;background:var(--panelGlass);border-left:1px solid var(--border);border-radius:12px 0 0 12px;box-shadow:-8px 0 24px rgba(0,0,0,.35);backdrop-filter:saturate(160%) blur(8px);display:flex;flex-direction:column;transition:transform .18s ease}
      .ai-drawer.collapsed{transform:translateX(calc(100% - 28px));border-left:none;box-shadow:none}
      .ai-drawer.collapsed .ai-header,.ai-drawer.collapsed .ai-content{opacity:0;pointer-events:none}
      .ai-tab{position:absolute;left:-36px;top:50%;transform:translateY(-50%);writing-mode:vertical-rl;text-orientation:mixed;background:var(--btnBg);border:2px solid var(--btnBorder);border-right:none;border-radius:10px 0 0 10px;color:var(--btnText);padding:12px 8px;font-size:13px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.25)}
      .ai-tab .icon-steth{display:inline-flex;align-items:center;justify-content:center;margin-bottom:8px}
      .ai-tab .icon-steth svg{width:20px;height:20px;display:block}
      .ai-tab .label{letter-spacing:.3px}
      .ai-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border)}
      .ai-header h2{margin:0;font-size:14px;color:var(--heading)}
      .ai-meta{display:flex;gap:12px;font-size:12px;color:var(--muted);flex-wrap:wrap}
      .ai-content{display:flex;flex-direction:column;padding:10px 12px;gap:10px;height:100%;}
      .ai-row{display:flex;gap:8px;align-items:center}
      .ai-chat{flex:1;min-height:120px;border:1px solid var(--codeBorder);border-radius:10px;background:var(--codeBg);padding:10px;overflow:auto}
      .bubble{max-width:85%;padding:8px 12px;border-radius:14px;margin:12px 0;line-height:1.45}
      .bubble.user{margin-left:auto;background:rgba(125,162,255,.22);border:1px solid rgba(125,162,255,.35)}
      .bubble.assistant{margin-right:auto;background:linear-gradient(180deg, rgba(255,143,211,.12), rgba(255,91,189,.10));border:1px solid rgba(255,143,211,.45)}
      .bubble-title{font-size:11px;font-weight:600;color:var(--muted);margin-bottom:6px;padding-bottom:4px;border-bottom:1px solid rgba(255,255,255,.1)}
      .bubble-content{margin-top:0}
      .ai-healing-history{display:flex;align-items:center;gap:4px;font-size:12px;color:var(--muted);background:rgba(125,162,255,.1);border:1px solid rgba(125,162,255,.3);padding:2px 8px;border-radius:12px;cursor:pointer;transition:all 0.2s ease}
      .ai-healing-history:hover{background:rgba(125,162,255,.2);border-color:rgba(125,162,255,.5)}
      .bubble p{margin:.4em 0}
      .bubble ul,.bubble ol{margin:.35em 0 .35em .9em}
      .bubble ul ul,.bubble ol ol{margin-left:.9em}
      .bubble li{margin:.25em 0}
      .bubble pre{margin:.5em 0;background:var(--codeBg);border:1px solid var(--codeBorder);padding:10px;border-radius:10px;overflow:auto}
      .bubble code{background:rgba(125,162,255,.15);border:1px solid rgba(125,162,255,.25);padding:0 4px;border-radius:4px}
      .ai-input{display:flex;flex-direction:column;gap:8px}
      .ai-input textarea{resize:vertical;min-height:44px;max-height:160px;font-family:var(--font-body)}
      .ai-input textarea::placeholder{font-family:var(--font-body);color:var(--muted)}
      .ai-actions{display:flex;gap:8px;justify-content:flex-end}
      /* Thinking indicator */
      .bubble.thinking{background:transparent;border:1px dashed var(--btnBorder);opacity:.85}
      .dots{display:inline-flex;gap:4px;vertical-align:middle}
      .dot{width:6px;height:6px;border-radius:50%;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);opacity:.6;animation:dotPulse 1s infinite ease-in-out}
      .dot:nth-child(2){animation-delay:.15s}
      .dot:nth-child(3){animation-delay:.3s}
      @keyframes dotPulse{0%,80%,100%{transform:scale(.6);opacity:.4}40%{transform:scale(1);opacity:1}}

      /* Mobile: bottom drawer behavior */
      @media (max-width: 768px){
        .ai-drawer{left:12px;right:12px;top:auto;bottom:12px;width:auto;height:min(50vh, calc(100vh - (var(--headerH, 64px) + 24px)));border-radius:12px}
        .ai-drawer.collapsed{transform:translateY(calc(100% - 28px));border-left:1px solid var(--border)}
        .ai-tab{left:50%;top:auto;bottom:-28px;transform:translate(-50%, 0);border-right:1px solid var(--btnBorder);border-left:1px solid var(--btnBorder)}
      }

      /* Desktop/tablet: shift content left when assistant open */
      @media (min-width: 769px){
        body.ai-open .container{max-width:none;width:calc(100% - var(--aiWidth) - 28px);margin-left:16px;margin-right:calc(var(--aiWidth) + 12px)}
      }

      @media (max-width:1024px){
        .container{padding:0 12px}
        .grid{grid-template-columns:1fr}
        .apps{grid-template-columns:1fr}
        .header-row{flex-wrap:wrap;gap:8px}
        .header-actions{gap:6px}
      }
      @media (max-width:768px){
        .conflict-options{gap:10px}
        .config-option{flex-direction:column;align-items:flex-start;gap:10px}
        .config-actions{margin-left:0}
        .conflict-actions{flex-direction:column}
        .suggestion-item{padding:12px}
        .toolbar{gap:6px}
        .toolbar .field{width:100%}
        .toolbar select,.toolbar input[type="text"]{width:100%}
        .route-header{padding:6px}
        .child-route{padding:6px}
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-row">
        <h1>
          <img src="/status/assets/logo.svg" alt="Dev Tunnel Proxy logo" style="height:40px;vertical-align:middle;margin-right:10px"/>
          <span>Dev Tunnel Proxy</span>
          Status
        </h1>
        <div class="header-actions">
          <a class="btn" href="/health">Health</a>
          <a class="btn" href="/reports/">Reports</a>
          <button class="btn" id="reloadConfigs" title="Reload all configurations and rescan apps">üîÑ</button>
          <button class="btn" id="themeToggle" title="Toggle theme" aria-label="Toggle theme">üåô</button>
        </div>
      </div>
      
    </header>
    <div class="container">
      <div class="grid summaryRow">
        <div class="card">
          <h2>Overview</h2>
          <div class="row"><div class="label">Generated</div><div class="value" id="generated">‚Äî</div></div>
          <div class="row"><div class="label">Ngrok</div><div class="value" id="ngrok">‚Äî</div></div>
        </div>
        <div class="card">
          <h2>Targets</h2>
          <div class="row"><div class="label">Detected</div><div class="value" id="targets">‚Äî</div></div>
        </div>
      </div>

      <div class="card hidden" id="conflictCard">
        <h2>‚ö†Ô∏è Route Conflicts</h2>
        <p>Multiple configuration files are declaring the same routes. Choose which config should win:</p>
        <div id="conflicts">Loading conflicts...</div>
      </div>

      <div class="ai-drawer collapsed" id="aiDrawer">
        <button class="ai-tab" id="aiTab" title="Calliope">
          <span class="icon-steth" aria-hidden="true">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="pinkSteth" x1="0%" y1="0%" x2="0%" y2="100%">
                  <stop offset="0%" stop-color="#ff8fd3"/>
                  <stop offset="100%" stop-color="#ff5bbd"/>
                </linearGradient>
                <linearGradient id="metalGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                  <stop offset="0%" stop-color="#f0f3f6"/>
                  <stop offset="45%" stop-color="#cfd5dc"/>
                  <stop offset="100%" stop-color="#8a9099"/>
                </linearGradient>
              </defs>
              <g fill="none" stroke="url(#pinkSteth)" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round">
                <!-- Heart-shaped tube (open aesthetic) -->
                <path d="M12 21c-3.9-2.7-6.6-4.9-8.4-6.6c-2.3-2.1-2.7-5.5-.4-7.1c1.7-1.2 4.1-.7 5.5.9c.5.6 1 1.3 1.3 2c.3-.7.8-1.4 1.3-2c1.4-1.6 3.8-2.1 5.5-.9c2.3 1.5 1.9 5-.4 7.1C18.6 16.1 15.9 18.3 12 21"/>
                <!-- Earpieces -->
                <circle cx="6.0" cy="6.0" r="1.2" fill="url(#pinkSteth)" stroke="none"/>
                <circle cx="18.0" cy="6.0" r="1.2" fill="url(#pinkSteth)" stroke="none"/>
                <!-- Metallic chestpiece (distinct from tube) -->
                <circle cx="7.4" cy="16.6" r="1.9" fill="url(#metalGrad)" stroke="none"/>
                <circle cx="7.4" cy="16.6" r="2.5"/>
              </g>
            </svg>
          </span>
          <span class="label">Calliope</span>
        </button>
        
        <!-- Healing History Badge -->
        <div class="healing-badge" id="healingBadge" title="Self-healing history">
          <span class="healing-count">0</span>
        </div>
        
        <!-- Healing History Panel -->
        <div class="healing-history" id="healingHistory">
          <h3>
            Self-Healing History
            <button class="close-history">&times;</button>
          </h3>
          <div class="healing-history-list" id="healingHistoryList">
            <!-- Healing entries will be populated here -->
            <div class="empty-history">No healing actions recorded yet.</div>
          </div>
        </div>
        <div class="ai-header">
          <h2>
            <span class="icon-steth-header" aria-hidden="true">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width:20px;height:20px;vertical-align:middle;margin-right:8px">
                <defs>
                  <linearGradient id="pinkStethHeader" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" stop-color="#ff8fd3"/>
                    <stop offset="100%" stop-color="#ff5bbd"/>
                  </linearGradient>
                  <linearGradient id="metalGradHeader" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" stop-color="#f0f3f6"/>
                    <stop offset="45%" stop-color="#cfd5dc"/>
                    <stop offset="100%" stop-color="#8a9099"/>
                  </linearGradient>
                </defs>
                <g fill="none" stroke="url(#pinkStethHeader)" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 21c-3.9-2.7-6.6-4.9-8.4-6.6c-2.3-2.1-2.7-5.5-.4-7.1c1.7-1.2 4.1-.7 5.5.9c.5.6 1 1.3 1.3 2c.3-.7.8-1.4 1.3-2c1.4-1.6 3.8-2.1 5.5-.9c2.3 1.5 1.9 5-.4 7.1C18.6 16.1 15.9 18.3 12 21"/>
                  <circle cx="6.0" cy="6.0" r="1.2" fill="url(#pinkStethHeader)" stroke="none"/>
                  <circle cx="18.0" cy="6.0" r="1.2" fill="url(#pinkStethHeader)" stroke="none"/>
                  <circle cx="7.4" cy="16.6" r="1.9" fill="url(#metalGradHeader)" stroke="none"/>
                  <circle cx="7.4" cy="16.6" r="2.5" stroke="url(#pinkStethHeader)"/>
                </g>
              </svg>
            </span>
            Calliope
          </h2>
          <div class="ai-meta">
            <span class="ai-healing-history" id="aiHealingHistory">
              <span class="ai-healing-label">Healing History</span>
            </span>
            <span class="ai-healing-status" id="aiHealingStatus">
              <span class="pulse"></span>
              <span class="ai-healing-label">Healing</span>
              <span class="ai-healing-count" id="aiHealingCount"></span>
            </span>
          </div>
        </div>
        <div class="ai-content">
          <div id="aiChat" class="ai-chat hover-scroll"></div>
          <div class="ai-input">
            <textarea id="aiQuery" class="hover-scroll" rows="3" placeholder="Ask about proxy/network issues" style="padding: 12px;"></textarea>
            <div class="ai-actions">
              <button class="btn" id="aiCopyBtn" title="Copy conversation to clipboard">Copy</button>
              <button class="btn" id="aiClearBtn" title="Clear conversation">Clear</button>
              <button class="btn" id="aiAskBtn">Ask</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card" id="appsCard">
        <div class="appsHeader">
          <h2 style="margin:0">Configured Apps</h2>
          <div class="toolbar">
            <div class="field">
              <label class="label">Sort</label>
              <select id="sortMode">
                <option value="alpha">A‚ÄìZ</option>
                <option value="status">By status</option>
                <option value="depth">By depth</option>
              </select>
            </div>
            <div class="field">
              <label class="label">Filter</label>
              <input id="routeFilter" type="text" placeholder="/api, ok, warn, err, 200, ngrok:200" />
            </div>
          </div>
        </div>
        <div class="apps" id="apps">Loading‚Ä¶</div>
      </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script>
      function initTheme(){
        const stored = localStorage.getItem('dtpTheme');
        // Default to dark if nothing stored
        const theme = stored || 'dark';
        document.documentElement.setAttribute('data-theme', theme==='light'?'light':'dark');
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = theme==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', theme==='light'?'Switch to dark':'Switch to light');
      }
      function measureStickyHeights(){
        const headerEl = document.querySelector('header');
        const summaryEl = document.querySelector('.summaryRow');
        const headerH = headerEl ? headerEl.getBoundingClientRect().height : 64;
        const summaryH = summaryEl ? summaryEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--headerH', headerH + 'px');
        document.documentElement.style.setProperty('--summaryH', summaryH + 'px');
      }
      function toggleTheme(){
        const cur = document.documentElement.getAttribute('data-theme')==='light'?'light':'dark';
        const next = cur==='light'?'dark':'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('dtpTheme', next);
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = next==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', next==='light'?'Switch to dark':'Switch to light');
      }
      // Make logo/title clickable for branding
      (function enableHomeClicks(){
        const brand=document.querySelector('header h1');
        if (brand){ brand.style.cursor='pointer'; brand.addEventListener('click',()=>{ location.reload(); }); }
      })();
      window.addEventListener('load', measureStickyHeights);
      window.addEventListener('resize', measureStickyHeights);

      function chip(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }

      // Choose best URL to open (ALWAYS use ngrok URL + route)
      function chooseOpenUrl(routes, targets, routeKey){
        // ALWAYS use the global ngrok URL if available
        if (globalNgrokUrl && globalNgrokUrl !== 'not discovered') {
          // Ensure route starts with / and ngrok URL doesn't end with /
          const cleanRoute = routeKey.startsWith('/') ? routeKey : '/' + routeKey;
          const cleanNgrok = globalNgrokUrl.replace(/\/$/, '');
          return cleanNgrok + cleanRoute;
        }
        
        // Fallback to old logic if no global ngrok URL
        const pref = ['ngrok', 'local-proxy'];
        
        // First pass: try to find a successful response (2xx or 3xx for ngrok, only 2xx for localhost)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) {
            if (t === 'ngrok' && info.status >= 200 && info.status < 400) {
              return info.url;
            } else if (t === 'local-proxy' && info.status >= 200 && info.status < 300) {
              return info.url;
            }
          }
        }
        
        // Second pass: return ngrok URL even if not successful (better than localhost error)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) return info.url;
        }
        
        return null;
      }

      async function loadJSON(url){
        const res = await fetch(url, { headers: { 'ngrok-skip-browser-warning':'true' } });
        if(!res.ok) throw new Error('HTTP '+res.status);
        return res.json();
      }

      let routesData = null;
      let preferences = null;
      let promotedRoots = null; // { [baseKey]: '/api/' }
      let globalNgrokUrl = null; // Store the global ngrok URL for Open buttons

      function loadPrefs(){
        try{ return JSON.parse(localStorage.getItem('statusPrefs')||'{}'); }catch{ return {}; }
      }
      function savePrefs(p){ localStorage.setItem('statusPrefs', JSON.stringify(p||{})); }
      function isCollapsed(route){
        preferences = preferences || loadPrefs();
        const c = preferences.collapsedRoutes || {};
        return !!c[route];
      }
      function setCollapsed(route, val){
        preferences = preferences || loadPrefs();
        preferences.collapsedRoutes = preferences.collapsedRoutes || {};
        if (val) preferences.collapsedRoutes[route] = true; else delete preferences.collapsedRoutes[route];
        savePrefs(preferences);
      }
      function loadPromotions(){
        try{ return JSON.parse(localStorage.getItem('routePromotions')||'{}'); }catch{ return {}; }
      }
      function savePromotions(p){ localStorage.setItem('routePromotions', JSON.stringify(p||{})); }

      function routeDepth(r){ return (r||'').split('/').filter(Boolean).length; }
      function normalizeBase(up){
        if (!up) return '';
        
        // Handle nginx variables like $inspire_upstream by treating them as literal keys
        if (up.includes('$')) {
          const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
          if (m && m[0]) return m[0];
          // Fallback: strip protocol and take host token before first '/'
          return up.replace(/^https?:\/\//,'').split('/')[0];
        }
        
        try{ 
          const u = new URL(up.startsWith('http') ? up : `http://${up}`); 
          return `${u.protocol}//${u.hostname}${u.port ? `:${u.port}` : ''}`;
        } catch { 
          return up.replace(/\/$/, ''); 
        }
      }
      function extractHostname(up){
        if (!up) return '';
        if (up.includes('$')) return up;
        try{
          const u = new URL(up.startsWith('http') ? up : `http://${up}`);
          return u.hostname; // ignore port for grouping
        }catch{
          return up.replace(/:\d+.*$/, '').replace(/\/$/, '');
        }
      }
      function addStatusChips(container, route, targets, routes){
        for (const t of targets) {
          const info = (routes.summary?.[t] || {})[route];
          if (!info) continue;
          
          const status = info.status || 0;
          let cls = 'err', reason = '';
          
          if (status >= 200 && status < 300) {
            cls = 'ok';
            reason = 'Working correctly';
          } else if (status >= 300 && status < 400) {
            cls = 'ok';
            reason = 'Redirect (often expected behavior)';
          } else if (status === 404) {
            cls = 'warn';
            reason = 'Not found - check route configuration';
          } else if (status === 0) {
            cls = 'warn';
            reason = 'No response from this target';
          } else if (status >= 400 && status < 500) {
            cls = 'warn';
            reason = 'Client error - check route configuration';
          } else if (status >= 500) {
            cls = 'err';
            reason = 'Server error - upstream service issue';
          }
          
          const labelName = (t === 'local-proxy') ? 'localhost' : t;
          const label = `${labelName}: ${status}`;
          const statusChip = chip(label, cls, reason);
          container.appendChild(statusChip);
        }
      }
      function severityOf(route, targets, routes){
        // ok if ANY target is ok; redirects/0 treated as warn
        let sev='err';
        for (const t of targets){
          const info=(routes.summary?.[t]||{})[route];
          if (!info) continue;
          const s = info.status||0;
          if (s>=200 && s<300) return 'ok';
          if (s>=300 && s<400) sev = sev==='ok'?'ok':'warn';
          else if (s===0) sev = sev==='ok'?'ok':'warn';
        }
        return sev;
      }
      function applyFilter(routeGroups, filterValue, targets, routes){
        const q=(filterValue||'').trim().toLowerCase(); if(!q) return routeGroups;
        const codeOnly = /^\d{3}$/.test(q) ? parseInt(q,10) : null;
        const targetCodeMatch = q.match(/^(ngrok|localhost|local-proxy):(\d{3})$/);
        const targetKey = targetCodeMatch ? (targetCodeMatch[1]==='localhost'?'local-proxy':targetCodeMatch[1]) : null;
        const targetCode = targetCodeMatch ? parseInt(targetCodeMatch[2],10) : null;
        const matches = (route)=>{
          const name=(route||'').toLowerCase();
          if (name.includes(q)) return true;
          if (q==='ok'||q==='warn'||q==='err') return severityOf(route,targets,routes)===q;
          // match upstream base host
          const up = (routes.metadata?.[route]?.upstream || '').toLowerCase();
          if (up && up.includes(q)) return true;
          // status code anywhere
          if (codeOnly!=null){
            for (const t of targets){ const info=(routes.summary?.[t]||{})[route]; if (info && info.status===codeOnly) return true; }
          }
          // specific target:code
          if (targetKey){ const info=(routes.summary?.[targetKey]||{})[route]; if (info && info.status===targetCode) return true; }
          return false;
        };
        return routeGroups.filter(g=> matches(g.route) || (g.children||[]).some(c=>matches(c)) );
      }

      function debounce(fn, wait){ let to=null; return function(...args){ clearTimeout(to); to=setTimeout(()=>fn.apply(this,args), wait); }; }

      function rebuildApps(){
        const routes = routesData;
        const appsEl = document.getElementById('apps');
        appsEl.innerHTML = '';
        const targets = Object.keys(routes.summary||{});
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const src = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          (bySource[src] = bySource[src] || []).push(r);
        });
        function buildGroupsByBase(routesInSource, meta){
          const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/','/api/resolve-conflict','/api/rename-route']);
          const routesList = routesInSource.filter(r=>!systemRoutes.has(r));
          const byBase = new Map();
          routesList.forEach(r=>{
            const up = (meta[r]||{}).upstream||'';
            const baseKey = normalizeBase(up);
            if (!byBase.has(baseKey)) byBase.set(baseKey, []);
            byBase.get(baseKey).push(r);
          });

          promotedRoots = loadPromotions();
          const groups = [];
          byBase.forEach((list, baseKey)=>{
            const unique = Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b));
            const promoted = promotedRoots?.[baseKey] || null;
            if (promoted && unique.includes(promoted)){
              const children = unique.filter(r=> r!==promoted);
              groups.push({ route: promoted, children, baseKey });
              return;
            }
            const depths = unique.map(r=>({ r, d:(r||'').split('/').filter(Boolean).length }));
            const minD = Math.min.apply(null, depths.map(x=>x.d));
            const shallow = depths.filter(x=>x.d===minD).map(x=>x.r);
            if (shallow.length === 1){
              const parent = shallow[0];
              const children = unique.filter(r=> r!==parent);
              groups.push({ route: parent, children, baseKey });
            } else {
              unique.forEach(r=> groups.push({ route:r, children:[], baseKey }));
            }
          });
          
          // Second pass: Handle path-based grouping for cross-upstream route relationships
          const finalGroups = [];
          const processedRoutes = new Set();
          
          // Sort groups by route length to process parents before children
          groups.sort((a, b) => a.route.length - b.route.length);
          
          groups.forEach(group => {
            if (processedRoutes.has(group.route)) return;
            
            // Check if this route should be a child of an existing group
            let foundParent = false;
            for (let existingGroup of finalGroups) {
              if (group.route !== existingGroup.route && 
                  group.route.startsWith(existingGroup.route) && 
                  group.route.length > existingGroup.route.length &&
                  (group.route[existingGroup.route.length] === '/' || existingGroup.route.endsWith('/'))) {
                // This route is a child of an existing group by path prefix
                if (!existingGroup.children.includes(group.route)) {
                  existingGroup.children.push(group.route);
                }
                // Add any children this group had to the parent as well
                group.children.forEach(child => {
                  if (!existingGroup.children.includes(child)) {
                    existingGroup.children.push(child);
                  }
                });
                processedRoutes.add(group.route);
                group.children.forEach(child => processedRoutes.add(child));
                foundParent = true;
                break;
              }
            }
            
            if (!foundParent) {
              finalGroups.push({ ...group });
              processedRoutes.add(group.route);
              group.children.forEach(child => processedRoutes.add(child));
            }
          });
          
          return finalGroups;
        }

        Object.keys(bySource).sort().forEach(source => {
          const groupCard = document.createElement('div');
          groupCard.className = 'card';
          const head = document.createElement('div');
          head.className = 'groupHead';
          const h2 = document.createElement('h2');
          h2.textContent = source;
          const buttonGroup = document.createElement('div');
          buttonGroup.className = 'chips';
          const jsonBtn = document.createElement('button');
          jsonBtn.className = 'btn btn-small';
          jsonBtn.textContent = 'JSON';
          jsonBtn.addEventListener('click', (e)=>{ e.preventDefault(); viewSourceJson(source, bySource[source]); });
          const recBtn = document.createElement('a');
          recBtn.className = 'btn btn-small'; recBtn.href = '#'; recBtn.textContent = 'Recommend';
          recBtn.addEventListener('click', (e)=>{ e.preventDefault(); openRecommendModal(routesData, bySource[source]); });
          buttonGroup.appendChild(jsonBtn);
          buttonGroup.appendChild(recBtn);
          head.appendChild(h2);
          head.appendChild(buttonGroup);
          groupCard.appendChild(head);

          const list = document.createElement('div');
          list.className = 'apps';

          const inThisSource = Object.keys(meta).filter(r => (meta[r]||{}).sourceFile === source);
          let routeGroups = buildGroupsByBase(inThisSource, meta);
          const targetsArr = Object.keys(routes.summary||{});
          const sortEl = document.getElementById('sortMode');
          const filterEl = document.getElementById('routeFilter');
          let sortMode = (preferences?.sortMode) || (sortEl && sortEl.value) || 'status';
          if (sortMode==='manual') { sortMode='status'; preferences.sortMode='status'; savePrefs(preferences); if (sortEl) sortEl.value='status'; }
          const filterVal = (preferences?.filter) || (filterEl && filterEl.value) || '';
          routeGroups = applyFilter(routeGroups, filterVal, targetsArr, routes);
          routeGroups = sortRoutes(routeGroups, sortMode, targetsArr, routes);

          routeGroups.forEach(group => {
            const app = document.createElement('div');
            app.className = 'app';

            // Collapse toggle + collapsed summary bar
            const toggle = document.createElement('button');
            toggle.className = 'collapse-toggle';
            toggle.type = 'button';
            toggle.title = 'Collapse/Expand';
            toggle.textContent = isCollapsed(group.route) ? '‚ñ¢' : '‚ñ£';
            app.appendChild(toggle);
            const collapsedBar = document.createElement('div');
            collapsedBar.className = 'collapsed-bar';
            const rootTag = (group.children && group.children.length>0) ? ' (root)' : '';
            collapsedBar.textContent = `${group.route}${rootTag}`;
            app.appendChild(collapsedBar);
            toggle.addEventListener('click', (e)=>{
              e.stopPropagation();
              const now = !app.classList.contains('collapsed');
              app.classList.toggle('collapsed', now);
              setCollapsed(group.route, now);
              toggle.textContent = now ? '‚ñ¢' : '‚ñ£';
            });

            if (group.children && group.children.length > 0) {
              app.classList.add('expandable-route');
              const header = document.createElement('div');
              header.className = 'route-header';
              const titleSection = document.createElement('div');
              titleSection.className = 'route-title';
              titleSection.innerHTML = `
                <span class="expand-icon">‚ñ∂</span>
                <span class="route-name">${group.route}</span>
                <span class="child-count">(${group.children.length} sub-routes)</span>
              `;
              header.appendChild(titleSection);
              
              // Add Open button to header
              const openBtn = document.createElement('button');
              openBtn.className = 'header-action-btn';
              openBtn.title = 'Open Route';
              openBtn.setAttribute('aria-label','Open Route');
              openBtn.innerHTML = 'üöÄ';
              openBtn.addEventListener('click', (e) => {
                e.preventDefault(); 
                e.stopPropagation();
                const url = chooseOpenUrl(routes, targets, group.route);
                if (url) window.open(url, '_blank', 'noopener');
              });
              header.appendChild(openBtn);
              const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
              const baseChipContainer = document.createElement('div');
              baseChipContainer.className = 'chips';
              baseChipContainer.appendChild(baseChip);
              header.appendChild(baseChipContainer);
              const parentStatusContainer = document.createElement('div');
              parentStatusContainer.className = 'chips parent-status';
              addStatusChips(parentStatusContainer, group.route, targets, routes);
              header.appendChild(parentStatusContainer);
              const summaryChips = document.createElement('div');
              summaryChips.className = 'chips child-summary';
              (group.children||[]).forEach(childRoute=>{
                const sev = severityOf(childRoute, targets, routes);
                const pref = ['ngrok','local-proxy'];
                let code = null;
                for (const t of pref){ const info=(routes.summary?.[t]||{})[childRoute]; if (info && typeof info.status==='number'){ code=info.status; break; } }
                const label = `${childRoute} ${code??''}`.trim();
                const sc = chip(label, `small ${sev}`);
                summaryChips.appendChild(sc);
              });
              header.appendChild(summaryChips);
              // Remove promote chips from parent header - they'll be on child cards instead
              // Only keep the Clear Root button in the root-actions area
              // Root actions removed - auto-grouping only from now on
              const icons = document.createElement('div');
              icons.className = 'icon-actions';
              const diagBtn = document.createElement('button');
              diagBtn.className = 'icon-btn';
              diagBtn.title = 'Diagnose with Calliope';
              diagBtn.setAttribute('aria-label','Diagnose with Calliope');
              diagBtn.textContent = 'ü©∫';
              diagBtn.dataset.route = group.route;
              diagBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopPropagation();
                openDiagnoseModal(group.route, targets, routes);
              });
              icons.appendChild(diagBtn);
              app.appendChild(icons);
              const childrenContainer = document.createElement('div');
              childrenContainer.className = 'route-children hidden';
              group.children.forEach(child => {
                const childApp = document.createElement('div');
                childApp.className = 'child-route';
                const childTitle = document.createElement('div');
                childTitle.className = 'route child-route-name';
                childTitle.textContent = child;
                
                // Add Open button to child route header
                const childOpenBtn = document.createElement('button');
                childOpenBtn.className = 'header-action-btn';
                childOpenBtn.title = 'Open Route';
                childOpenBtn.setAttribute('aria-label','Open Route');
                childOpenBtn.innerHTML = 'üöÄ';
                childOpenBtn.addEventListener('click', (e) => {
                  e.preventDefault(); 
                  e.stopPropagation();
                  const url = chooseOpenUrl(routes, targets, child);
                  if (url) window.open(url, '_blank', 'noopener');
                });
                
                const childHeader = document.createElement('div');
                childHeader.className = 'child-route-header';
                childHeader.appendChild(childTitle);
                childHeader.appendChild(childOpenBtn);
                childApp.appendChild(childHeader);
                const childBaseChip = chip(normalizeBase(meta[child]?.upstream || ''), 'upstream-base');
                const childBaseContainer = document.createElement('div');
                childBaseContainer.className = 'chips';
                childBaseContainer.appendChild(childBaseChip);
                childApp.appendChild(childBaseContainer);
                const childStatusContainer = document.createElement('div');
                childStatusContainer.className = 'chips route-status';
                addStatusChips(childStatusContainer, child, targets, routes);
                childApp.appendChild(childStatusContainer);
                
                // Create a route-actions area for normal actions
                const childIcons = document.createElement('div');
                childIcons.className = 'chips route-actions';
                const childDiagBtn = document.createElement('button');
                childDiagBtn.className = 'btn btn-small';
                childDiagBtn.title = 'Diagnose with Calliope';
                childDiagBtn.setAttribute('aria-label','Diagnose with Calliope');
                childDiagBtn.textContent = 'ü©∫';
                childDiagBtn.dataset.route = child;
                childDiagBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  openDiagnoseModal(child, targets, routes);
                });
                childIcons.appendChild(childDiagBtn);
                childApp.appendChild(childIcons);
                
                // Add dedicated bottom-right promote button per child
                const childActions = document.createElement('div');
                childActions.className = 'root-actions'; // Reuse the same positioning class
                const promoteBtn = document.createElement('button');
                promoteBtn.className = 'btn btn-small';
                promoteBtn.title = 'Make Root Route';
                promoteBtn.setAttribute('aria-label','Make Root Route');
                promoteBtn.innerHTML = 'üéì';
                promoteBtn.addEventListener('click',(e)=>{
                  e.preventDefault();
                  e.stopPropagation(); // Prevent card expansion
                  const base = group.baseKey;
                  if (!promotedRoots) promotedRoots = loadPromotions();
                  promotedRoots[base] = child;
                  savePromotions(promotedRoots);
                  rebuildApps();
                });
                childActions.appendChild(promoteBtn);
                childApp.appendChild(childActions);
                childrenContainer.appendChild(childApp);
              });
              header.addEventListener('click', () => {
                const isExpanded = !childrenContainer.classList.contains('hidden');
                childrenContainer.classList.toggle('hidden', isExpanded);
                header.querySelector('.expand-icon').textContent = isExpanded ? '‚ñ∂' : '‚ñº';
              });

              const filterVal = (preferences?.filter)||'';
              if (filterVal){
                const q=(filterVal||'').trim().toLowerCase();
                const anyMatch = (group.children||[]).some(c=>{
                  const name=(c||'').toLowerCase();
                  if (name.includes(q)) return true;
                  if (q==='ok'||q==='warn'||q==='err') return severityOf(c, targets, routes)===q;
                  const up = (routes.metadata?.[c]?.upstream || '').toLowerCase();
                  if (up && up.includes(q)) return true;
                  return false;
                });
                if (anyMatch){
                  childrenContainer.classList.remove('hidden');
                  header.querySelector('.expand-icon').textContent = '‚ñº';
                }
              }
              app.appendChild(header);
              app.appendChild(childrenContainer);
              applySeverityToApp(app, group.route, targets, routes);
            } else {
              const isPromoted = promotedRoots && promotedRoots[group.baseKey] === group.route;
              if (isPromoted) {
                app.classList.add('expandable-route');
                const header = document.createElement('div');
                header.className = 'route-header';
                const titleSection = document.createElement('div');
                titleSection.className = 'route-title';
                titleSection.innerHTML = `
                  <span class="route-name">${group.route}</span>
                  <span class="child-count">(root)</span>
                `;
                header.appendChild(titleSection);
                const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
                const baseChipContainer = document.createElement('div');
                baseChipContainer.className = 'chips';
                baseChipContainer.appendChild(baseChip);
                header.appendChild(baseChipContainer);
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chips parent-status';
                addStatusChips(statusContainer, group.route, targets, routes);
                header.appendChild(statusContainer);
                const summaryChips = document.createElement('div');
                summaryChips.className = 'chips child-summary';
                header.appendChild(summaryChips);
                // Move Clear Root to bottom-right corner
                // Root actions removed - auto-grouping only from now on
                const icons = document.createElement('div');
                icons.className = 'icon-actions';
                const diagBtn = document.createElement('button');
                diagBtn.className = 'icon-btn';
                diagBtn.title = 'Diagnose with Calliope';
                diagBtn.setAttribute('aria-label','Diagnose with Calliope');
                diagBtn.textContent = 'ü©∫';
                diagBtn.dataset.route = group.route;
                diagBtn.addEventListener('click', (e) => {
                  e.preventDefault(); e.stopPropagation();
                  openDiagnoseModal(group.route, targets, routes);
                });
                icons.appendChild(diagBtn);
                app.appendChild(icons);
                app.appendChild(header);
              } else {
                const title = document.createElement('div');
                title.className = 'route';
                title.textContent = group.route;
                app.appendChild(title);
                const baseChip = chip(normalizeBase(meta[group.route]?.upstream || ''), 'upstream-base');
                const baseContainer = document.createElement('div');
                baseContainer.className = 'chips';
                baseContainer.appendChild(baseChip);
                app.appendChild(baseContainer);
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chips route-status';
                addStatusChips(statusContainer, group.route, targets, routes);
                app.appendChild(statusContainer);
                // Remove promote chips at parent card; actions live on each child
                const actions = document.createElement('div');
                actions.className = 'chips route-actions';
                
                // Add Make Root button for routes without parent root
                const makeRootBtn = document.createElement('button');
                makeRootBtn.className = 'btn btn-small';
                makeRootBtn.title = 'Make Root Route';
                makeRootBtn.setAttribute('aria-label','Make Root Route');
                makeRootBtn.innerHTML = 'üéì';
                makeRootBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  const base = normalizeBase(meta[group.route]?.upstream || '');
                  if (!promotedRoots) promotedRoots = loadPromotions();
                  promotedRoots[base] = group.route;
                  savePromotions(promotedRoots);
                  rebuildApps();
                });
                actions.appendChild(makeRootBtn);
                
                const diagBtn = document.createElement('button');
                diagBtn.className = 'btn btn-small';
                diagBtn.title = 'Diagnose with Calliope';
                diagBtn.setAttribute('aria-label','Diagnose with Calliope');
                diagBtn.textContent = 'ü©∫';
                diagBtn.addEventListener('click', (e) => {
                  e.preventDefault();
                  openDiagnoseModal(group.route, targets, routes);
                });
                actions.appendChild(diagBtn);
                app.appendChild(actions);
              }
              applySeverityToApp(app, group.route, targets, routes);
            }
            if (isCollapsed(group.route)) app.classList.add('collapsed');
            list.appendChild(app);
          });
          groupCard.appendChild(list);
          appsEl.appendChild(groupCard);
        });
      }
      function sortRoutes(routeGroups, sortMode, targets, routes){
        if (sortMode==='alpha') return routeGroups.slice().sort((a,b)=> a.route.localeCompare(b.route));
        if (sortMode==='depth') return routeGroups.slice().sort((a,b)=> routeDepth(a.route)-routeDepth(b.route) || a.route.localeCompare(b.route));
        if (sortMode==='status'){
          const rank={err:0,warn:1,ok:2};
          return routeGroups.slice().sort((a,b)=> (rank[severityOf(a.route,targets,routes)]-rank[severityOf(b.route,targets,routes)]) || a.route.localeCompare(b.route));
        }
        return routeGroups;
      }
      function rememberOrder(rendered){ preferences.routeOrder = rendered.map(g=>g.route); savePrefs(preferences); }
      (async function init(){
        preferences = loadPrefs();
        const routes = await loadJSON('/routes.json');
        routesData = routes;
        
        // Load ngrok URL with multiple fallback strategies
        let ngrokTxt = 'not discovered';
        
        // Strategy 1: Try status.json first (source of truth for health dashboard)
        try {
          const status = await loadJSON('/status.json');
          if (status && status.ngrok && status.ngrok !== 'not discovered' && status.ngrok !== 'null') {
            ngrokTxt = status.ngrok;
          }
        } catch (e) { /* Continue to next strategy */ }
        
        // Strategy 2: If status.json fails or has no ngrok, try health-latest.json
        if (ngrokTxt === 'not discovered') {
          try {
            const healthResp = await fetch('/.artifacts/reports/health-latest.json', { 
              headers: { 'ngrok-skip-browser-warning': 'true' },
              cache: 'no-cache'
            });
            if (healthResp.ok) {
              const healthData = await healthResp.json();
              if (healthData && healthData.ngrok && healthData.ngrok !== 'not discovered' && healthData.ngrok !== 'null') {
                ngrokTxt = healthData.ngrok;
              }
            }
          } catch (e) { /* Continue to next strategy */ }
        }
        
        // Strategy 3: Fall back to routes.json (what we already have)
        if (ngrokTxt === 'not discovered' && routes && routes.ngrok && routes.ngrok !== 'not discovered' && routes.ngrok !== 'null') {
          ngrokTxt = routes.ngrok;
        }
        
        // Strategy 4: Last resort - look for static domain hint in a minimal API call
        if (ngrokTxt === 'not discovered') {
          try {
            const staticDomainResp = await fetch('/api/ai/health', { 
              method: 'GET',
              headers: { 'ngrok-skip-browser-warning': 'true' }
            });
            if (staticDomainResp.ok) {
              const data = await staticDomainResp.json();
              if (data && data.staticNgrokDomain) {
                ngrokTxt = `https://${data.staticNgrokDomain}`;
              }
            }
          } catch (e) { /* Tried our best */ }
        }
        
        // Store globally for Open button functionality
        globalNgrokUrl = ngrokTxt;
        
        // Convert timestamp to local time
        const generatedTime = routes.generatedAt ? new Date(routes.generatedAt).toLocaleString() : '‚Äî';
        document.getElementById('generated').textContent = generatedTime;
        document.getElementById('ngrok').textContent = ngrokTxt;

        const targets = Object.keys(routes.summary||{});
        document.getElementById('targets').textContent = targets.join(', ') || '‚Äî';

        // Group by source file from metadata (data-driven)
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const src = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          (bySource[src] = bySource[src] || []).push(r);
        });

        // Build hierarchical route structure (no hardcoded roots)
        const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/','/api/resolve-conflict','/api/rename-route']);
        const isSystem = (r)=> systemRoutes.has(r);
        const isTechnical = (r)=> r.startsWith('/static/') || r.startsWith('/sockjs-node') || r.startsWith('/node_modules/') || r.startsWith('/@') || r.startsWith('/_next/') || r.startsWith('/src/') || r.startsWith('/.storybook/') || r.startsWith('/sb-') || r==='/' || r==='/favicon.ico' || r==='/asset-manifest.json';
        function normalizeBase(up){
          if (!up) return '';
          if (up.includes('$')){
            const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
            if (m && m[0]) return m[0];
            return up.replace(/^https?:\/\//,'').split('/')[0];
          }
          try{ const u=new URL(up.startsWith('http')?up:`http://${up}`); return `${u.protocol}//${u.hostname}${u.port?`:${u.port}`:''}`; }catch{ return up.replace(/\/$/,''); }
        }
        function buildGroupsByBase(routesInSource, meta){
          const routes = routesInSource.filter(r=>!isSystem(r));
          const byBase = new Map();
          routes.forEach(r=>{
            const up = (meta[r]||{}).upstream||'';
            const baseKey = normalizeBase(up);
            if (!byBase.has(baseKey)) byBase.set(baseKey, []);
            byBase.get(baseKey).push(r);
          });

          promotedRoots = loadPromotions();
          const groups = [];
          byBase.forEach((list, baseKey)=>{
            const unique = Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b));
            const promoted = promotedRoots?.[baseKey] || null;
            if (promoted && unique.includes(promoted)){
              const children = unique.filter(r=> r!==promoted);
              groups.push({ route: promoted, children, baseKey });
              return;
            }
            // Auto-parent ONLY if there is a single shallowest route
            const depths = unique.map(r=>({ r, d:(r||'').split('/').filter(Boolean).length }));
            const minD = Math.min.apply(null, depths.map(x=>x.d));
            const shallow = depths.filter(x=>x.d===minD).map(x=>x.r);
            if (shallow.length === 1){
              const parent = shallow[0];
              const children = unique.filter(r=> r!==parent);
              groups.push({ route: parent, children, baseKey });
            } else {
              // No auto parent; present as standalone with baseKey so user can promote
              unique.forEach(r=> groups.push({ route:r, children:[], baseKey }));
            }
          });
          return groups;
        }
        // Distribute routes by their source file (single pass)
        // Note: avoid duplicating entries across sources
        // meta is keyed by route; each value contains its sourceFile

        // Show conflict management section if there are conflicts
        showConflictManagement(routes);
        
        // Add global conflict status indicator
        updateGlobalConflictIndicator(routes);

        rebuildApps();

        // No manual ordering; default sort is by status
        try { await initAiAssistant(); } catch (e) { /* non-fatal */ }
      })().catch(err => {
        document.getElementById('apps').textContent = 'Error: '+err.message;
      });

      // Controls wiring
      (function initControls(){
        const sortEl=document.getElementById('sortMode');
        const filterEl=document.getElementById('routeFilter');
        preferences = loadPrefs();
        if (sortEl){
          const pref = (preferences.sortMode==='manual') ? 'status' : (preferences.sortMode||'status');
          sortEl.value = pref;
          sortEl.addEventListener('change',(e)=>{ preferences.sortMode=e.target.value; savePrefs(preferences); rebuildApps(); });
        }
        if (filterEl){
          if (preferences.filter) filterEl.value=preferences.filter;
          const debounced = debounce(()=>{ savePrefs(preferences); rebuildApps(); }, 250);
          filterEl.addEventListener('input',(e)=>{ preferences.filter=e.target.value; debounced(); });
        }
      })();

      // Reload configurations functionality
      async function reloadConfigs() {
        const reloadBtn = document.getElementById('reloadConfigs');
        const originalText = reloadBtn.textContent;
        
        try {
          // Show loading state
          reloadBtn.textContent = 'üîÑ Reloading...';
          reloadBtn.disabled = true;
          
          // Force refresh of routes.json with cache busting (no API endpoint exists for scan-apps)
          let scanSuccess = false;
          const timestamp = Date.now();
          const freshRoutes = await fetch(`/routes.json?_t=${timestamp}`, {
            headers: { 'ngrok-skip-browser-warning': 'true' },
            cache: 'no-cache'
          });
          if (freshRoutes.ok) {
            scanSuccess = true;
            console.log('‚úÖ Routes data refreshed');
          }
          
          if (scanSuccess) {
            // Success feedback
            reloadBtn.textContent = '‚úÖ Reloaded!';
            reloadBtn.style.background = '#16402b';
            reloadBtn.style.borderColor = '#2a7f54';
            reloadBtn.style.color = '#a6f3cc';
            
            // Reload the page after short delay to show success
            setTimeout(() => {
              location.reload();
            }, 1000);
          } else {
            throw new Error('Unable to reload configs');
          }
          
        } catch (error) {
          console.error('Config reload failed:', error);
          
          // Error feedback
          reloadBtn.textContent = '‚ùå Failed - Try Manual';
          reloadBtn.style.background = 'rgba(239,68,68,.15)';
          reloadBtn.style.borderColor = '#ef4444';
          reloadBtn.style.color = '#ef4444';
          
          // Show manual instructions
          const instructions = `
To reload manually, run:
node test/scanApps.js
./scripts/smart-build.sh

Or check if config files have syntax errors.
          `.trim();
          
          setTimeout(() => {
            if (confirm(`Automatic reload failed.\n\n${instructions}\n\nWould you like to refresh the page anyway to check if configs were updated externally?`)) {
              location.reload();
            }
          }, 1500);
        }
        
        // Reset button after delay
        setTimeout(() => {
          reloadBtn.textContent = originalText;
          reloadBtn.disabled = false;
          reloadBtn.style.background = '';
          reloadBtn.style.borderColor = '';
          reloadBtn.style.color = '';
        }, 3000);
      }

      // Wire up reload button
      document.getElementById('reloadConfigs').addEventListener('click', reloadConfigs);

      // View JSON for specific source file
      function viewSourceJson(sourceFile, routesInSource) {
        const filteredData = {
          sourceFile: sourceFile,
          routes: {},
          metadata: {},
          generatedAt: routesData.generatedAt,
          ngrok: routesData.ngrok
        };
        
        // Filter routes data to only include routes from this source
        const targetsArr = Object.keys(routesData.summary || {});
        targetsArr.forEach(target => {
          filteredData.routes[target] = {};
          if (routesData.summary && routesData.summary[target]) {
            routesInSource.forEach(route => {
              if (routesData.summary[target][route]) {
                filteredData.routes[target][route] = routesData.summary[target][route];
              }
            });
          }
        });
        
        // Filter metadata to only include routes from this source
        if (routesData.metadata) {
          routesInSource.forEach(route => {
            if (routesData.metadata[route]) {
              filteredData.metadata[route] = routesData.metadata[route];
            }
          });
        }
        
        const modal = document.createElement('div');
        modal.className = 'backdrop';
        modal.innerHTML = `
          <div class="modal large">
            <h2>JSON Data for ${sourceFile}</h2>
            <div class="section">
              <h3>Filtered Routes & Metadata</h3>
              <p>Showing only routes from <strong>${sourceFile}</strong> (${routesInSource.length} routes)</p>
              <pre class="config-display">${JSON.stringify(filteredData, null, 2)}</pre>
            </div>
            <div class="toolbar">
              <button class="btn" onclick="navigator.clipboard.writeText('${JSON.stringify(filteredData, null, 2).replace(/'/g, "\\'")}').then(() => this.textContent = 'Copied!').then(() => setTimeout(() => this.textContent = 'Copy JSON', 1500))">Copy JSON</button>
              <button class="btn" onclick="this.closest('.backdrop').remove()">Close</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
      }

      // Conflict Management Functions
      function showConflictManagement(routes) {
        const conflictCard = document.getElementById('conflictCard');
        const conflictsDiv = document.getElementById('conflicts');
        
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        
        if (!hasConflicts) {
          conflictCard.classList.add('hidden');
          return;
        }
        
        conflictCard.classList.remove('hidden');
        conflictsDiv.innerHTML = '';
        
        // Parse nginx warnings to extract conflict information
        const conflicts = parseConflictWarnings(routes.nginxWarnings || []);
        
        conflicts.forEach(conflict => {
          const conflictDiv = document.createElement('div');
          conflictDiv.className = 'conflict-item';
          conflictDiv.innerHTML = `
            <div class="conflict-header">
              <h3>Route: ${conflict.route}</h3>
              <div class="conflict-status">
                Current winner: <strong>${conflict.winner}</strong>
              </div>
            </div>
            <div class="conflict-options">
              <div class="conflict-configs">
                ${conflict.configs.map(config => `
                  <label class="config-option ${config === conflict.winner ? 'active' : ''}">
                    <input type="radio" name="conflict-${conflict.route}" value="${config}" ${config === conflict.winner ? 'checked' : ''}>
                    <span class="config-name">${config}</span>
                    <div class="config-actions">
                      <button class="btn-small" onclick="viewConfig('${config}')">View</button>
                      <button class="btn-small" onclick="renameRoute('${conflict.route}', '${config}')">Rename Route</button>
                    </div>
                  </label>
                `).join('')}
              </div>
              <div class="conflict-actions">
                <button class="btn" onclick="resolveConflict('${conflict.route}')">Apply Selection</button>
                <button class="btn" onclick="autoFixConflict('${conflict.route}')">Auto-Fix</button>
              </div>
            </div>
          `;
          conflictsDiv.appendChild(conflictDiv);
        });
      }

      function parseConflictWarnings(warnings) {
        const conflicts = [];
        warnings.forEach(warning => {
          // Parse warning like: "Route /api/: NEW CONFLICT - encast.conf wins (first config) over test-conflict.conf"
          const routeMatch = warning.match(/Route ([^:]+):/);
          const winnerMatch = warning.match(/- ([^\\s]+)\\.conf wins.*over ([^\\s,]+(?:\\.conf)?)/);
          
          if (routeMatch && winnerMatch) {
            const route = routeMatch[1];
            const winner = winnerMatch[1] + '.conf';
            const loser = winnerMatch[2].endsWith('.conf') ? winnerMatch[2] : winnerMatch[2] + '.conf';
            
            conflicts.push({
              route,
              winner,
              configs: [winner, loser]
            });
          }
        });
        return conflicts;
      }

      async function resolveConflict(route) {
        const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
        if (!selectedRadio) return;
        
        const newWinner = selectedRadio.value;
        
        try {
          const response = await fetch('/api/resolve-conflict', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ route, winner: newWinner })
          });
          
          if (response.ok) {
            // Refresh the page to show updated conflicts
            location.reload();
          } else {
            alert('Failed to resolve conflict. Check console for details.');
          }
        } catch (error) {
          alert('Error resolving conflict: ' + error.message);
        }
      }

      function viewConfig(configFile) {
        openConfigModal(configFile);
      }

      function renameRoute(route, configFile) {
        const newRoute = prompt(`Rename route ${route} in ${configFile} to:`, route);
        if (newRoute && newRoute !== route) {
          renameRouteInConfig(route, newRoute, configFile);
        }
      }

      function autoFixConflict(route) {
        // Smart auto-fix suggestions based on route type
        const suggestions = getAutoFixSuggestions(route);
        
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2>Auto-Fix Suggestions for ${route}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <p>Here are intelligent suggestions to resolve this conflict:</p>
              ${suggestions.map(s => `
                <div class="suggestion-item">
                  <h3>${s.title}</h3>
                  <p>${s.description}</p>
                  <code>${s.example}</code>
                  <button class="btn" onclick="applySuggestion('${route}', '${s.action}', '${s.params}')">Apply This Fix</button>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      function getAutoFixSuggestions(route) {
        const suggestions = [];
        
        if (route === '/api/') {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Rename one route to be app-specific',
            example: 'location /myapp/api/ { ... }',
            action: 'rename',
            params: '/myapp/api/'
          });
          suggestions.push({
            title: 'Use Versioned API',
            description: 'Add version to make routes unique',
            example: 'location /api/v1/ { ... }',
            action: 'rename', 
            params: '/api/v1/'
          });
        } else if (route === '/admin/') {
          suggestions.push({
            title: 'App-Specific Admin',
            description: 'Make admin path unique to your app',
            example: 'location /myapp/admin/ { ... }',
            action: 'rename',
            params: route.replace('/admin/', '/myapp/admin/')
          });
        } else {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Prepend your app name to make the route unique',
            example: `location /myapp${route} { ... }`,
            action: 'rename',
            params: `/myapp${route}`
          });
        }
        
        suggestions.push({
          title: 'Let First Config Win', 
          description: 'Keep the current winner, no changes needed',
          example: 'No configuration changes required',
          action: 'accept',
          params: ''
        });
        
        return suggestions;
      }

      async function applySuggestion(route, action, params) {
        if (action === 'accept') {
          document.querySelector('.modal').remove();
          return;
        }
        
        if (action === 'rename') {
          const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
          if (!selectedRadio) {
            alert('Please select a config file first');
            return;
          }
          
          const configFile = selectedRadio.value;
          await renameRouteInConfig(route, params, configFile);
          document.querySelector('.modal').remove();
        }
      }

      async function renameRouteInConfig(oldRoute, newRoute, configFile) {
        try {
          const response = await fetch('/api/rename-route', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ oldRoute, newRoute, configFile })
          });
          
          if (response.ok) {
            alert(`Route renamed successfully. Please restart the proxy for changes to take effect.`);
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to rename route: ' + error);
          }
        } catch (error) {
          alert('Error renaming route: ' + error.message);
        }
      }

      function openConfigModal(configFile) {
        // Create and show config viewing modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content large">
            <div class="modal-header">
              <h2>Config File: ${configFile}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <div class="config-actions">
                <button class="btn" onclick="downloadConfig('${configFile}')">Download</button>
                <button class="btn" onclick="enableConfigEdit(this)">Edit</button>
              </div>
              <pre id="config-content" class="config-display">Loading...</pre>
              <textarea id="config-editor" class="config-editor hidden" rows="30"></textarea>
              <div class="edit-actions hidden">
                <button class="btn" onclick="saveConfig('${configFile}')">Save Changes</button>
                <button class="btn" onclick="cancelConfigEdit()">Cancel</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        loadConfigContent(configFile);
      }

      async function loadConfigContent(configFile) {
        try {
          const response = await fetch(`/api/config/${configFile}`);
          const content = await response.text();
          
          if (response.ok) {
            document.getElementById('config-content').textContent = content;
            document.getElementById('config-editor').value = content;
          } else {
            document.getElementById('config-content').textContent = `Error loading config: ${content}`;
          }
        } catch (error) {
          document.getElementById('config-content').textContent = `Error: ${error.message}`;
        }
      }

      function enableConfigEdit(button) {
        document.getElementById('config-content').classList.add('hidden');
        document.getElementById('config-editor').classList.remove('hidden');
        document.querySelector('.edit-actions').classList.remove('hidden');
        button.style.display = 'none';
      }

      function cancelConfigEdit() {
        document.getElementById('config-content').classList.remove('hidden');
        document.getElementById('config-editor').classList.add('hidden');
        document.querySelector('.edit-actions').classList.add('hidden');
        document.querySelector('.config-actions button:nth-child(2)').style.display = '';
      }

      async function saveConfig(configFile) {
        const content = document.getElementById('config-editor').value;
        
        try {
          const response = await fetch(`/api/config/${configFile}`, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: content
          });
          
          if (response.ok) {
            alert('Config saved successfully. Restart the proxy for changes to take effect.');
            document.querySelector('.modal').remove();
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to save config: ' + error);
          }
        } catch (error) {
          alert('Error saving config: ' + error.message);
        }
      }

      function downloadConfig(configFile) {
        const content = document.getElementById('config-content').textContent;
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = configFile;
        a.click();
        URL.revokeObjectURL(url);
      }

      function updateGlobalConflictIndicator(routes) {
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        
        const existingIndicator = document.querySelector('.global-conflict-indicator');
        if (existingIndicator) existingIndicator.remove();
        
        if (hasConflicts) {
          const conflictCount = routes.nginxWarnings ? routes.nginxWarnings.length : 1;
          const indicator = document.createElement('div');
          indicator.className = 'global-conflict-indicator';
          indicator.innerHTML = `
            <div class="conflict-badge">
              ‚ö†Ô∏è ${conflictCount} Route Conflict${conflictCount > 1 ? 's' : ''}
              <button onclick="document.getElementById('conflictCard').scrollIntoView({behavior: 'smooth'})">
                Resolve
              </button>
            </div>
          `;
          document.body.appendChild(indicator);
        }
      }

      function applySeverityToApp(appElement, route, targets, routes) {
        const severity = severityOf(route, targets, routes);
        appElement.classList.add(severity);
      }

      // Modal logic
      function openDiagnoseModal(routeKey, targets, routes){
        // If Calliope is enabled, she overrides manual diagnose with her health flow
        if (document.body.classList.contains('calliope-enabled')){
          try { runCalliopeHealth(routeKey); } catch(e){}
          return;
        }
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Diagnose: <code>${routeKey}</code></h2>
          <div class="section"><h3>Detected Issues</h3><div id="issues"></div></div>
          <div class="section"><h3>Suggested Nginx Snippet</h3><pre id="snippet"></pre></div>
          <div class="section"><h3>Repair Commands</h3><pre id="commands"></pre></div>
          <div class="toolbar"><button class="btn" id="copySnippet">Copy snippet</button><button class="btn" id="copyCmds">Copy commands</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Build issues list
        const issues = [];
        for (const t of targets){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (!info) continue;
          const status = info.status||0;
          if (!(status>=200 && status<300)) issues.push(`${t}: HTTP ${status}`);
          // Note: API conflict detection removed
          if (info.websocket && !info.websocket.ok) issues.push(`${t}: websocket upgrade failed`);
        }
        if (!issues.length) issues.push('No obvious issues detected.');
        modal.querySelector('#issues').innerHTML = `<ul>${issues.map(i=>`<li>${i}</li>`).join('')}</ul>`;

        // Build snippet template
        const name = routeKey.replace(/^\/(.*?)\/?$/, '$1');
        let snippet='';
        if (routeKey === '/api/') {
          snippet = `# Preserve /api prefix to upstream service\nlocation /api/ {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://SERVICE_ALIAS:PORT;\n}`;
        } else if (/^\/[A-Za-z0-9_-]+\/$/.test(routeKey)) {
          snippet = `# Keep prefix, enable HMR\nlocation = ${routeKey.slice(0,-1)} { rewrite ^ ${routeKey} last; }\nlocation ^~ ${routeKey}_next/ {\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_pass http://${name}-app:2000${routeKey}_next/;\n}\nlocation ^~ ${routeKey} {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-Host $host;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header X-Forwarded-Prefix ${routeKey.slice(0,-1)};\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://${name}-app:2000${routeKey};\n}`;
        } else {
          snippet = `# Example mapping\nlocation ^~ ${routeKey} {\n  proxy_pass http://SERVICE_ALIAS:PORT${routeKey};\n}`;
        }
        modal.querySelector('#snippet').textContent = snippet;

        // Commands
        const cmd = `# Copy snippet to apps/${name||'myapp'}.conf and reload\n./scripts/install-app.sh ${name||'myapp'} examples/next/myapp.conf || true\n# Or place the generated snippet into apps/${name||'myapp'}.conf then:\ndocker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#commands').textContent = cmd;

        // Copy handlers
        modal.querySelector('#copySnippet').addEventListener('click',()=>{
          navigator.clipboard.writeText(snippet);
        });
        modal.querySelector('#copyCmds').addEventListener('click',()=>{
          navigator.clipboard.writeText(cmd);
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }

      // Recommend modal ‚Äì aggregates issues and provides generic fixes/snippets
      function openRecommendModal(routes, onlyRoutes){
        const targets = Object.keys(routes.summary||{});
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Recommendations</h2>
          <div class=\"section\"><h3>Detected Issues</h3><div id=\"issues\"></div></div>
          <div class="section"><h3>Standard Fixes</h3><ul id="fixes"></ul></div>
          <div class="section"><h3>Snippets</h3>
            <p><strong>Keep prefix (Next.js basePath)</strong></p>
            <pre id="snKeep"></pre>
            <p><strong>Strip prefix (CRA/Storybook)</strong></p>
            <pre id="snStrip"></pre>
            <p><strong>Preserve /api prefix</strong></p>
            <pre id="snApi"></pre>
          </div>
          <div class="section"><h3>Commands</h3><pre id="cmds"></pre></div>
          <div class="toolbar"><button class="btn" id="copyAll">Copy all</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Group issues by endpoint for readability
        const issuesByRoute = {};
        targets.forEach(t=>{
          const m = routes.summary[t]||{};
          const routeKeys = onlyRoutes && onlyRoutes.length ? onlyRoutes : Object.keys(m);
          routeKeys.forEach(r=>{
            const info = m[r]||{};
            const st = info.status||0;
            const msgs = [];
            if (!(st>=200 && st<300)) msgs.push(`${t}: HTTP ${st}`);
            if (info.websocket && !info.websocket.ok) msgs.push(`${t}: websocket upgrade failed`);
            // Only flag API ownership conflicts if owned by different config
            // Note: API conflict detection removed
            if (msgs.length) {
              issuesByRoute[r] = issuesByRoute[r] || [];
              issuesByRoute[r].push(...msgs);
            }
          });
        });
        const blocks = Object.keys(issuesByRoute).sort().map(r => `<div class=\"section\"><h3>${r}</h3><ul>${issuesByRoute[r].map(i=>`<li>${i}</li>`).join('')}</ul></div>`);
        modal.querySelector('#issues').innerHTML = blocks.length ? blocks.join('') : '<p>No warnings/errors detected.</p>';

        const fixes = [
          'Ensure all dev services join the external "devproxy" network and use service aliases as upstream hosts.',
          'Avoid proxy_pass variables for dev routes; use fixed upstreams. Use trailing slash to strip prefix when needed.',
          'For HMR: set proxy_http_version 1.1 and Upgrade/Connection headers on prefix routes.',
          'For Next.js behind a path: run a basePath-aware dev instance and DO NOT strip the prefix in the proxy.',
          'For CRA/Storybook behind a path: strip the prefix with trailing-slash proxy_pass and configure PUBLIC_URL or builder base/publicPath.',
          'If multiple projects share /api, keep /api mapped to the API app and ensure other apps call a prefixed API or separate domain.',
        ];
        modal.querySelector('#fixes').innerHTML = fixes.map(f=>`<li>${f}</li>`).join('');

        const snKeep = `# Keep prefix (Next.js basePath example)
location = /myapp { rewrite ^ /myapp/ last; }
location ^~ /myapp/_next/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_pass http://myapp-app:2000/myapp/_next/;
}
location ^~ /myapp/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Prefix /myapp;
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://myapp-app:2000/myapp/;
}`;

        const snStrip = `# Strip prefix (CRA/Storybook example)
location ^~ /ui/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://ui-app:3000/;  # trailing slash strips /ui/
}`;

        const snApi = `# Preserve /api prefix to API upstream
location /api/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://api-app:8000;
}`;

        modal.querySelector('#snKeep').textContent = snKeep;
        modal.querySelector('#snStrip').textContent = snStrip;
        modal.querySelector('#snApi').textContent = snApi;

        const cmds = `# Re-scan and update status JSON
node ./test/scanApps.js

# Install a snippet into apps/<name>.conf and reload
./scripts/install-app.sh myapp examples/next/myapp.conf || true
docker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#cmds').textContent = cmds;

        const copyAllBtn = modal.querySelector('#copyAll');
        modal.querySelector('#copyAll').addEventListener('click',()=>{
          const all = [snKeep, snStrip, snApi, cmds].join('\n\n');
          navigator.clipboard.writeText(all).then(()=>{
            copyAllBtn.classList.add('copied');
            const prev = copyAllBtn.textContent;
            copyAllBtn.textContent = 'Copied!';
            setTimeout(()=>{ copyAllBtn.textContent = prev; copyAllBtn.classList.remove('copied'); }, 1500);
          });
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      initTheme();

      // ===== AI Assistant Wiring =====
      // Healing History Management
      let healingHistory = [];
      let isHealing = false;
      
      async function loadHealingHistory() {
        try {
          const response = await fetch('/.artifacts/calliope/healing-log.json');
          if (response.ok) {
            const data = await response.json();
            healingHistory = data.entries || [];
            updateHealingUI();
          } else {
            console.log('No healing history found');
          }
        } catch (e) {
          console.log('Error loading healing history', e);
        }
      }
      
      function updateHealingUI() {
        const badge = document.getElementById('healingBadge');
        const countEl = badge.querySelector('.healing-count');
        const count = healingHistory.length;
        
        // Update badge
        countEl.textContent = count > 99 ? '99+' : count;
        badge.style.display = count > 0 ? 'flex' : 'none';
        
        // Update healing status in header
        const statusEl = document.getElementById('aiHealingStatus');
        const countHeaderEl = document.getElementById('aiHealingCount');
        
        if (isHealing) {
          statusEl.classList.add('active');
          statusEl.querySelector('.ai-healing-label').textContent = 'Healing...';
        } else {
          statusEl.classList.remove('active');
          statusEl.querySelector('.ai-healing-label').textContent = 'Self-Healing';
        }
        
        countHeaderEl.textContent = count > 0 ? `(${count})` : '';
        
        // Update history panel
        const historyList = document.getElementById('healingHistoryList');
        
        if (count === 0) {
          historyList.innerHTML = '<div class="empty-history">No healing actions recorded yet.</div>';
          return;
        }
        
        historyList.innerHTML = '';
        
        // Show most recent entries first
        const recentEntries = [...healingHistory].reverse().slice(0, 20);
        
        recentEntries.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = `healing-entry ${entry.success ? 'success' : 'failure'}`;
          
          const header = document.createElement('div');
          header.className = 'healing-entry-header';
          
          const issue = document.createElement('div');
          issue.className = 'healing-entry-issue';
          issue.textContent = entry.issue || 'Unknown issue';
          
          const timestamp = document.createElement('div');
          timestamp.className = 'healing-entry-timestamp';
          timestamp.textContent = new Date(entry.timestamp).toLocaleString();
          
          header.appendChild(issue);
          header.appendChild(timestamp);
          
          const details = document.createElement('div');
          details.className = 'healing-entry-details';
          
          if (entry.success) {
            details.textContent = `Successfully applied ${entry.solution}`;
          } else {
            details.textContent = entry.details?.error || 'Failed to heal';
          }
          
          const actions = document.createElement('div');
          actions.className = 'healing-entry-actions';
          
          const viewBtn = document.createElement('button');
          viewBtn.textContent = 'View Details';
          viewBtn.addEventListener('click', () => {
            // Open a modal with details
            const detailsStr = JSON.stringify(entry.details || {}, null, 2);
            alert(`Healing Details:\n${detailsStr}`);
          });
          
          actions.appendChild(viewBtn);
          
          entryEl.appendChild(header);
          entryEl.appendChild(details);
          entryEl.appendChild(actions);
          
          historyList.appendChild(entryEl);
        });
      }
      
      async function runSelfHeal() {
        if (isHealing) return;
        
        isHealing = true;
        updateHealingUI();
        
        try {
          // Append a message showing we're starting healing
          appendBubble('assistant', `ü©∫ Starting self-healing process... This might take a moment.`);
          
          const thinking = appendThinking();
          
          // Call the advanced healing API
          const response = await fetch('/api/ai/advanced-heal', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          
          thinking.remove();
          
          if (response.ok) {
            const result = await response.json();
            
            // Format the result as a message
            let message = '‚ú® Self-healing complete!\n\n';
            
            if (result.result.success) {
              message += `${result.result.message || 'The healing was successful.'}\n\n`;
              
              if (result.result.steps) {
                message += 'Steps performed:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}\n`;
                });
              }
              
              if (result.result.appliedStrategies && result.result.appliedStrategies.length > 0) {
                message += '\nApplied strategies:\n';
                result.result.appliedStrategies.forEach(strategy => {
                  message += `- ${strategy.issue}: ${strategy.result.message || strategy.result.success ? 'Success' : 'Failed'}\n`;
                });
              }
              
              message += '\nYour proxy should be working correctly now!';
            } else {
              message += 'The healing process encountered some issues.\n\n';
              
              if (result.result.error) {
                message += `Error: ${result.result.error}\n\n`;
              }
              
              if (result.result.steps) {
                message += 'Steps attempted:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}${step.error ? ` (${step.error})` : ''}\n`;
                });
              }
              
              message += '\nYou might need to manually fix some issues.';
            }
            
            appendBubble('assistant', message);
            
            // Refresh healing history after a delay
            setTimeout(() => {
              loadHealingHistory();
            }, 2000);
            
          } else {
            const errorText = await response.text();
            appendBubble('assistant', `‚ùå Self-healing failed: ${errorText || response.statusText}`);
          }
        } catch (e) {
          appendBubble('assistant', `‚ùå Error during self-healing: ${e.message}`);
        } finally {
          isHealing = false;
          updateHealingUI();
        }
      }
      
      async function initAiAssistant(){
        const drawer = document.getElementById('aiDrawer');
        const tab = document.getElementById('aiTab');
        const statusEl = document.getElementById('aiStatus');
        const indexEl = document.getElementById('aiIndex');
        const chatEl = document.getElementById('aiChat');
        const askBtn = document.getElementById('aiAskBtn');
        const clearBtn = document.getElementById('aiClearBtn');
        const copyBtn = document.getElementById('aiCopyBtn');
        const healBtn = document.getElementById('aiHealBtn');
        const queryEl = document.getElementById('aiQuery');
        
        // Healing history elements
        const healingBadge = document.getElementById('healingBadge');
        const healingHistory = document.getElementById('healingHistory');
        const closeHistoryBtn = document.querySelector('.close-history');

        async function refreshHealth(){
          try {
            const h = await fetch('/api/ai/health');
            if (!h.ok) throw new Error('disabled');
            const hj = await h.json();
            if (statusEl) statusEl.textContent = hj.enabled ? `Enabled${hj.model?` (${hj.model})`:''}` : 'Disabled (no key)';
            // Toggle UI affordances when Calliope is enabled
            const calliopeEnabled = true; // features other than /ask do not require a key
            document.body.classList.toggle('calliope-enabled', calliopeEnabled);
            toggleCalliopeAffordances(calliopeEnabled);
          } catch {
            if (statusEl) statusEl.textContent = 'Unavailable';
          }
          try {
            const s = await fetch('/api/ai/stats');
            if (s.ok){ const sj = await s.json(); if(indexEl) indexEl.textContent = sj.exists ? `${sj.chunks} chunks ‚Ä¢ ${sj.model||''}`.trim() : 'No index'; }
            else if(indexEl) indexEl.textContent = '‚Äî';
          } catch { if(indexEl) indexEl.textContent = '‚Äî'; }
        }

        function toggleCalliopeAffordances(enabled){
          // Hide Recommend and disable Diagnose buttons when enabled; swap Diagnose icon to Calliope
          const recButtons = Array.from(document.querySelectorAll('a.btn.btn-small, button.btn.btn-small')).filter(el=>/Recommend/i.test(el.textContent||''));
          recButtons.forEach(el=> el.style.display = enabled ? 'none' : '');
          const diagIconBtns = Array.from(document.querySelectorAll('.icon-actions .icon-btn'));
          diagIconBtns.forEach(btn=>{
            if (btn.getAttribute('aria-label')==='Diagnose with Calliope' || btn.getAttribute('aria-label')==='Diagnose'){
              if (enabled){
                btn.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="pinkStethBtn" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#ff8fd3"/><stop offset="100%" stop-color="#ff5bbd"/></linearGradient><linearGradient id="pinkMetalGrad" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stop-color="#f0f3f6"/><stop offset="45%" stop-color="#cfd5dc"/><stop offset="100%" stop-color="#8a9099"/></linearGradient></defs><g fill="none" stroke="url(#pinkStethBtn)" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21c-3.2-2.3-5.4-4.1-6.9-5.6c-1.9-1.8-2.2-4.6-.3-6c1.4-1 3.4-.6 4.5.7c.4.5.8 1.1 1.1 1.7c.2-.6.6-1.2 1.1-1.7c1.1-1.3 3.1-1.7 4.5-.7c1.9 1.3 1.6 4.2-.3 6C17.4 16.9 15.2 18.7 12 21"/><circle cx="6.0" cy="6.0" r="1.1" fill="url(#pinkStethBtn)" stroke="none"/><circle cx="18.0" cy="6.0" r="1.1" fill="url(#pinkStethBtn)" stroke="none"/><circle cx="7.4" cy="16.6" r="1.9" fill="url(#pinkMetalGrad)" stroke="none"/><circle cx="7.4" cy="16.6" r="2.2" stroke="url(#pinkStethBtn)"/></g></svg>';
                btn.title='Calliope'; btn.setAttribute('aria-label','Calliope');
                const route = btn.dataset.route || null;
                btn.onclick = (e)=>{ 
                  e.preventDefault(); 
                  e.stopPropagation(); 
                  // Open Calliope chat
                  const drawer = document.getElementById('aiDrawer');
                  drawer.classList.remove('collapsed');
                  document.body.classList.add('ai-open');
                  // Focus the query input
                  setTimeout(() => {
                    const queryEl = document.getElementById('aiQuery');
                    queryEl.focus();
                  }, 100);
                };
              } else {
                btn.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M22.7 19.3l-6-6 2-2 6 6-2 2zM14.9 7.1l2 2L6 20H4v-2l10.9-10.9zM3 17l1 4 4 1-1-4-4-1z"/></svg>';
                btn.title='Diagnose'; btn.setAttribute('aria-label','Diagnose');
                btn.onclick = (e)=> { 
                  e.preventDefault(); 
                  e.stopPropagation();
                  const route = btn.dataset.route || null;
                  if (route) openDiagnoseModal(route, targets, routes);
                };
              }
            }
          });
          // Disable any text Diagnose buttons
          const textDiagBtns = Array.from(document.querySelectorAll('button.btn.btn-small, a.btn')).filter(el=>/Diagnose/i.test(el.textContent||''));
          textDiagBtns.forEach(el=>{ el.disabled = !!enabled; if (enabled) el.classList.add('hidden'); else el.classList.remove('hidden'); });
        }

        async function onAsk(){
          const q = (queryEl.value||'').trim();
          if (!q){ return; }
          askBtn.disabled = true; askBtn.textContent = 'Thinking‚Ä¶';
          // Clear the input immediately so the user can type next question
          queryEl.value = '';
          
          // Show thinking animation during requests too
          const thinking = appendThinking();
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 800));
          
          try{
            // Append user bubble
            appendBubble('user', q);
            const [resp] = await Promise.all([
              fetch('/api/ai/ask', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ query: q }) }),
              minThinkingTime
            ]);
            
            // Remove thinking indicator
            thinking.remove();
            
            const data = await resp.json().catch(()=>null);
            if (!resp.ok){ appendBubble('assistant', (data&&data.error) ? `Error: ${data.error}` : `HTTP ${resp.status}`); }
            else {
              const txt = (data.answer||'').trim();
              appendBubble('assistant', txt);
            }
          } catch(e){ 
            thinking.remove(); 
            appendBubble('assistant', `Request failed: ${e.message}`); 
          }
          finally{ askBtn.disabled = false; askBtn.textContent = 'Ask'; }
        }

        async function onReindex(){
          reindexBtn.disabled = true; reindexBtn.textContent = 'Indexing‚Ä¶';
          try{
            const resp = await fetch('/api/ai/reindex', { method:'POST', headers:{'Content-Type':'application/json'}, body: '{}' });
            const data = await resp.json().catch(()=>null);
            if (!resp.ok){ alert(`Reindex failed: ${(data&&data.error)||('HTTP '+resp.status)}`); }
          } catch(e){ alert('Reindex error: '+e.message); }
          await refreshHealth();
          reindexBtn.disabled = false; reindexBtn.textContent = 'Reindex';
        }

        function appendBubble(who, text){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          
          // Add chat bubble titles
          const titleEl = document.createElement('div');
          titleEl.className = 'bubble-title';
          if (who === 'user') {
            titleEl.innerHTML = 'üßë You';
          } else {
            titleEl.innerHTML = 'ü©∫ Calliope';
          }
          b.appendChild(titleEl);
          
          // Create content area
          const contentEl = document.createElement('div');
          contentEl.className = 'bubble-content';
          
          if (who === 'assistant'){
            try{
              const html = DOMPurify.sanitize(marked.parse(text || ''));
              contentEl.innerHTML = html;
            }catch{ contentEl.textContent = text; }
          } else {
            contentEl.textContent = text;
          }
          b.appendChild(contentEl);
          
          chatEl.appendChild(b);
          
          // Hide placeholder if this is the first user message
          if (who === 'user' && chatEl.children.length === 1) {
            queryEl.placeholder = '';
          }
          
          // Scroll behavior:
          // - For user messages, scroll to bottom so the sent message is visible
          // - For assistant replies, align the top of the new bubble to the top of the chat (if possible)
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }
        
        // Appends raw HTML content in a bubble (for complex elements like tables)
        function appendHTMLContent(who, html){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          // Directly inject the HTML without markdown parsing
          b.innerHTML = DOMPurify.sanitize(html);
          chatEl.appendChild(b);
          // Scroll to show the new content
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }

        function appendThinking(){
          const b = document.createElement('div');
          b.className = 'bubble assistant thinking';
          const span = document.createElement('span');
          span.className = 'dots';
          span.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
          b.appendChild(span);
          chatEl.appendChild(b);
          chatEl.scrollTop = chatEl.scrollHeight;
          return b;
        }

        function ensureAiOpen(){
          const drawer = document.getElementById('aiDrawer');
          if (drawer.classList.contains('collapsed')){
            drawer.classList.remove('collapsed');
            document.body.classList.add('ai-open');
          }
        }

        async function runCalliopeHealth(routeKey){
          ensureAiOpen();
          // First message - acknowledgment
          appendBubble('assistant', `ü©∫ Heya! One sec while I listen to ${routeKey}...`);
          
          // Show thinking indicator with minimum duration for visibility
          const thinking = appendThinking();
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 1200));
          
          try{
            const [resp] = await Promise.all([
              fetch('/api/ai/self-check', { 
                method: 'POST', 
                headers: {'Content-Type':'application/json'}, 
                body: JSON.stringify({ 
                  heal: false, 
                  route: routeKey, 
                  hint: `Focus on route ${routeKey} and its children.` 
                }) 
              }),
              minThinkingTime // Ensure thinking animation shows for at least 1.2s
            ]);
            
            // Remove thinking indicator after minimum time has passed
            thinking.remove();
            
            if (!resp.ok){ 
              appendBubble('assistant', `Hmm, I had trouble with that check (HTTP ${resp.status}). Want me to try again?`); 
              return; 
            }
            
            // Process the response
            const data = await resp.json().catch(()=>null);
            const summary = (data && data.summary) ? data.summary : 'Health check completed.';
            
            // Second message - detailed result
            appendBubble('assistant', summary);
            
            // If route report is available and has child data, show a collapsible details section
            if (data && data.self && data.self.routeReport && data.self.routeReport.probed) {
              const probed = data.self.routeReport.probed;
              
              // Only show details if we have multiple routes
              if (probed.length > 1) {
                // Create collapsible details section
                const detailsHtml = `
                <details>
                  <summary>View route details (${probed.length} paths)</summary>
                  <div style="margin-top: 8px; padding: 8px; background: rgba(125,162,255,.08); border: 1px solid rgba(125,162,255,.18); border-radius: 6px; font-size: 0.9em;">
                    <table style="width: 100%; border-collapse: collapse;">
                      <thead>
                        <tr>
                          <th style="text-align: left; padding: 4px;">Path</th>
                          <th style="text-align: right; padding: 4px;">Status</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${probed.map(item => {
                          const statusClass = item.status >= 200 && item.status < 300 ? 'ok' : 
                                          item.status >= 300 && item.status < 400 ? 'warn' : 'err';
                          return `
                            <tr>
                              <td style="text-align: left; padding: 4px;">${item.path}</td>
                              <td style="text-align: right; padding: 4px;" class="${statusClass}">${item.status || 'no response'}</td>
                            </tr>
                          `;
                        }).join('')}
                      </tbody>
                    </table>
                  </div>
                </details>`;
                
                // Add details as a new bubble
                appendHTMLContent('assistant', detailsHtml);
              }
            }
          } catch(e){ 
            thinking.remove(); 
            appendBubble('assistant', `‚ö†Ô∏è I couldn't finish my check: ${e.message}`); 
          }
        }

        askBtn.addEventListener('click', onAsk);
        clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; queryEl.value=''; queryEl.focus(); });
        copyBtn.addEventListener('click', onCopy);
        queryEl.addEventListener('keydown', (e)=>{
          if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); }
        });
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        tab.addEventListener('click', ()=>{
          const collapsed = drawer.classList.toggle('collapsed');
          document.body.classList.toggle('ai-open', !collapsed);
        });
        askBtn.addEventListener('click', onAsk);
        clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; queryEl.value=''; queryEl.focus(); });
        copyBtn.addEventListener('click', onCopy);
        queryEl.addEventListener('keydown', (e)=>{
          if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); }
        });
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        
        // Healing UI handlers
        healBtn.addEventListener('click', runSelfHeal);
        
        healingBadge.addEventListener('click', (e) => {
          e.stopPropagation();
          healingHistory.classList.toggle('visible');
        });
        
        closeHistoryBtn.addEventListener('click', () => {
          healingHistory.classList.remove('visible');
        });
        
        // Initialize healing history
        try {
          await loadHealingHistory();
        } catch (e) {
          console.log('Error loading healing history', e);
        }
        
        // Hide healing status initially if empty
        const aiHealingStatus = document.getElementById('aiHealingStatus');
        if (healingHistory.length === 0) {
          aiHealingStatus.style.display = 'none';
        }
        
        await refreshHealth();
      }
    </script>
  </body>
  </html>


