<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dev Proxy Status</title>
    <link rel="icon" type="image/svg+xml" href="/status/assets/favicon.svg" />
    <link rel="icon" type="image/png" href="/status/assets/favicon.png" />
    <link rel="shortcut icon" href="/status/assets/favicon.svg" />
    <style>
      :root{--bg:#0c111c;--bg2:#0e1627;--panel:#101827;--panelGlass:rgba(16,24,39,.92);--appBgGlass:rgba(13,20,36,.95);--border:#1f2a44;--muted:#8a9bb7;--text:#e4ecfa;--heading:#cfe0ff;--chip:#1a2440;--chipBg:#132140;--chipBorder:#263455;--chipText:#b8c8e6;--ok:#16c784;--warn:#f59e0b;--err:#ef4444;--lnk:#7fb0ff;--btnBg:rgba(19,42,77,.45);--btnBorder:rgba(58,110,174,.55);--btnText:#cfe0ff;--btnBgHover:rgba(22,52,95,.6);--headerBg:rgba(10,16,30,.55);--codeBg:#0a1223;--codeBorder:#1b2a48;--glowOpacity:.10}
      :root[data-theme="light"]{--bg:#edf2fb;--bg2:#f7faff;--panel:#ffffff;--panelGlass:rgba(255,255,255,.88);--appBgGlass:rgba(255,255,255,.9);--border:#d6e0f5;--muted:#5b6b8a;--text:#0b1220;--heading:#0b1220;--chip:#e8eefc;--chipBg:#eef2ff;--chipBorder:#cddcff;--chipText:#0b1220;--ok:#0f9d6a;--warn:#b7791f;--err:#c24141;--lnk:#2d6cdf;--btnBg:#eef2ff;--btnBorder:#bfd1ff;--btnText:#0b1220;--btnBgHover:#e2e8ff;--headerBg:rgba(255,255,255,.78);--codeBg:#f6f8ff;--codeBorder:#d6e0f5;--glowOpacity:.14}
      *{box-sizing:border-box}
      body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans}
      header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid var(--border);background:var(--headerBg);backdrop-filter:saturate(180%) blur(10px);position:sticky;top:0;z-index:1000;box-shadow:0 10px 30px rgba(0,0,0,.25)}
      header h1{font-size:16px;margin:0;display:flex;gap:10px;align-items:center}
      header h1 span{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--chip);color:var(--text);font-weight:600}
      .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
      .toolbar .field{display:flex;gap:6px;align-items:center}
      .toolbar select,.toolbar input[type="text"]{background:var(--btnBg);border:1px solid var(--btnBorder);color:var(--btnText);border-radius:8px;padding:7px 10px}
      .drag-btn{border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:6px;padding:4px 8px;cursor:pointer}
      .drag-btn:hover{background:var(--btnBgHover)}
      .btn{appearance:none;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600;text-decoration:none;backdrop-filter:saturate(160%) blur(6px);box-shadow:inset 0 1px 0 rgba(255,255,255,.05), 0 4px 18px rgba(0,0,0,.25)}
      .btn:hover{background:var(--btnBgHover)}
      .btn:active{transform:translateY(1px)}
      .btn.copied{background:#16402b;border-color:#2a7f54;color:#a6f3cc}
      .container{max-width:1100px;margin:24px auto;padding:0 16px}
      .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-bottom:16px}
      .card{background:var(--panelGlass);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25);backdrop-filter:saturate(160%) blur(6px);transition:box-shadow .12s ease}
      .card:hover{box-shadow:0 10px 28px rgba(0,0,0,.30)}
      .card h2{margin:0 0 10px 0;font-size:14px;color:var(--heading);letter-spacing:.2px}
      .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
      .label{color:var(--muted)}
      .value{font-weight:600}
      .ok{color:var(--ok)}.warn{color:var(--warn)}.err{color:var(--err)}
      .apps{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px}
      .app{background:var(--appBgGlass);border:1px solid var(--border);border-radius:10px;padding:12px;transition:transform .12s ease, box-shadow .12s ease;box-shadow:inset 0 1px 0 rgba(255,255,255,.02)}
      .app:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .app.ok{border-color:rgba(22,199,132,.7);box-shadow:0 0 0 2px rgba(22,199,132,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.warn{border-color:rgba(245,158,11,.7);box-shadow:0 0 0 2px rgba(245,158,11,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.err{border-color:rgba(239,68,68,.8);box-shadow:0 0 0 2px rgba(239,68,68,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app .route{font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
      .groupHead{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .chip{display:inline-flex;gap:6px;align-items:center;padding:5px 8px;border-radius:999px;background:var(--chipBg);border:1px solid var(--chipBorder);color:var(--chipText);font-weight:600;position:relative}
      .chip.ok{background:rgba(22,199,132,.12);border-color:rgba(22,199,132,.35);color:#8ef0c3}
      .chip.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.35);color:#ffd38a}
      .chip.err{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:#ffb1b1}
      .chip[data-tip]:hover:after{content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:calc(100% + 8px);white-space:pre-wrap;max-width:280px;background:#0a1223;color:#d9e2f1;border:1px solid #1b2a48;border-radius:8px;padding:8px;box-shadow:0 10px 30px rgba(0,0,0,.45);z-index:30}
      .chip[data-tip]:hover:before{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:100%;border:6px solid transparent;border-top-color:#1b2a48}
      .chip a{color:var(--lnk);text-decoration:none}
      .view{margin-top:12px}
      pre{margin:0;background:var(--codeBg, #0a1223);border:1px solid var(--codeBorder, #1b2a48);padding:12px;border-radius:10px;max-height:420px;overflow:auto}
      .switch{display:flex;gap:8px;align-items:center}
      .hidden{display:none}
      /* Modal */
      .backdrop{position:fixed;inset:0;background:rgba(3,8,20,.55);backdrop-filter:saturate(160%) blur(10px);display:flex;align-items:center;justify-content:center;padding:16px;z-index:2000;overflow:auto}
      .modal{max-width:860px;width:min(860px,96vw);background:rgba(16,24,39,.92);backdrop-filter:saturate(160%) blur(6px);border:1px solid #2a3a62;border-radius:12px;box-shadow:0 24px 70px rgba(0,0,0,.65), inset 0 1px 0 rgba(255,255,255,.04);padding:16px;max-height:calc(100vh - 48px);overflow:auto;z-index:2002}
      .modal h2{margin:0 0 8px 0;color:#cfe0ff;font-size:16px}
      .modal .section{margin:10px 0;padding:10px;border:1px dashed #2a3a62;border-radius:8px;background:#0d1424}
      .modal .section h3{margin:0 0 6px 0;font-size:13px;color:#bcd3ff}
      .modal pre{max-height:280px}
      .modal .toolbar{display:flex;gap:8px;justify-content:flex-end;margin-top:10px;position:sticky;bottom:0;background:linear-gradient(180deg, rgba(16,24,39,0), rgba(16,24,39,.85) 30%, rgba(16,24,39,.95));padding-top:12px;border-top:1px solid #2a3a62;backdrop-filter:saturate(160%) blur(6px);z-index:5}

      /* Conflict Management Styles */
      .conflict-item{border:1px solid var(--border);border-radius:12px;padding:20px;margin-bottom:16px;background:var(--panelGlass);backdrop-filter:saturate(160%) blur(6px)}
      .conflict-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
      .conflict-header h3{margin:0;color:var(--heading);font-size:16px}
      .conflict-status{color:var(--muted);font-size:14px}
      .conflict-options{display:flex;flex-direction:column;gap:15px}
      .conflict-configs{display:flex;flex-direction:column;gap:10px}
      .config-option{display:flex;align-items:center;padding:12px;border:2px solid var(--border);border-radius:8px;cursor:pointer;background:var(--appBgGlass);transition:all 0.2s;backdrop-filter:saturate(160%) blur(4px)}
      .config-option:hover{border-color:var(--lnk);transform:translateY(-1px)}
      .config-option.active{border-color:var(--ok);background:rgba(22,199,132,.08)}
      .config-option input[type="radio"]{margin-right:10px}
      .config-name{font-weight:500;flex:1;color:var(--heading)}
      .config-actions{display:flex;gap:8px;margin-left:auto}
      .conflict-actions{display:flex;gap:10px;justify-content:flex-end}
      .btn-small{padding:6px 12px;font-size:12px;border:1px solid var(--border);background:var(--btnBg);color:var(--btnText);border-radius:6px;cursor:pointer;transition:all 0.2s}
      .btn-small:hover{background:var(--btnBgHover);transform:translateY(-1px)}

      /* Config Modal Styles */
      .modal.large{max-width:1200px;width:min(1200px,96vw)}
      .config-modal{color:var(--text)}
      .config-actions{margin-bottom:15px;display:flex;gap:10px}
      .config-display{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:var(--codeBg);color:var(--codeText);max-height:500px;overflow:auto}
      .config-editor{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:#0d1424;color:#d9e2f1;resize:vertical;min-height:400px}
      .edit-actions{margin-top:15px;display:flex;gap:10px;justify-content:flex-end}

      /* Auto-Fix Suggestions Styles */
      .suggestion-item{border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:12px;background:var(--appBgGlass);backdrop-filter:saturate(160%) blur(4px)}
      .suggestion-item h3{margin:0 0 8px 0;color:var(--ok);font-size:14px}
      .suggestion-item p{margin:0 0 8px 0;color:var(--text);font-size:13px}
      .suggestion-item code{display:block;background:var(--codeBg);color:var(--codeText);padding:8px;border-radius:4px;margin:8px 0;font-family:var(--mono, monospace);font-size:12px}
      .suggestion-item .btn{margin-top:8px;font-size:12px}

      /* Global Conflict Indicator */
      .global-conflict-indicator{position:fixed;top:20px;right:20px;z-index:1000;animation:slideIn 0.3s ease-out}
      .conflict-badge{background:rgba(245,158,11,.15);border:2px solid var(--warn);border-radius:8px;padding:12px 16px;color:var(--warn);font-weight:600;display:flex;align-items:center;gap:12px;backdrop-filter:saturate(160%) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .conflict-badge button{background:var(--warn);color:#000;border:none;padding:6px 12px;border-radius:4px;font-weight:600;cursor:pointer;font-size:12px}
      .conflict-badge button:hover{opacity:0.9;transform:translateY(-1px)}
      @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}

      /* Hierarchical Route Styles */
      .expandable-route{position:relative}
      .route-header{cursor:pointer;padding:8px;border-radius:6px;transition:background-color 0.2s;display:flex;align-items:center;justify-content:space-between}
      .route-header:hover{background:rgba(255,255,255,.05)}
      .route-title{display:flex;align-items:center;gap:8px;font-weight:600}
      .expand-icon{transition:transform 0.2s;font-size:12px;width:12px}
      .route-name{font-size:16px}
      .child-count{font-size:12px;color:var(--muted);font-weight:400}
      .route-children{margin-top:8px;margin-left:20px;border-left:2px solid var(--border);padding-left:16px}
      .route-children.hidden{display:none}
      .child-route{margin-bottom:8px;padding:8px;background:var(--appBgGlass);border-radius:6px;border-left:3px solid var(--border)}
      .child-route-name{font-size:14px;color:var(--muted);margin-bottom:4px}

      @media (max-width:768px){
        .conflict-options{gap:10px}
        .config-option{flex-direction:column;align-items:flex-start;gap:10px}
        .config-actions{margin-left:0}
        .conflict-actions{flex-direction:column}
        .suggestion-item{padding:12px}
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        <img src="/status/assets/logo.svg" alt="Dev Tunnel Proxy logo" style="height:40px;vertical-align:middle;margin-right:10px"/>
        <span>Dev Tunnel Proxy</span>
        Status
      </h1>
      <div class="toolbar">
        <div class="field">
          <label class="label">Sort</label>
          <select id="sortMode">
            <option value="manual">Manual</option>
            <option value="alpha">A‚ÄìZ</option>
            <option value="status">By status</option>
            <option value="depth">By depth</option>
          </select>
        </div>
        <div class="field">
          <label class="label">Filter</label>
          <input id="routeFilter" type="text" placeholder="/api, ok, err, mxtk" />
        </div>
        <button class="btn" id="toggleReorder">Reorder</button>
        <a class="btn" href="/health">Health</a>
        <a class="btn" href="/reports/">Reports</a>
        <button class="btn" id="recommend">Recommend</button>
        <div class="switch">
          <button class="btn" id="toggle">Show JSON</button>
        </div>
        <button class="btn" id="themeToggle" title="Toggle theme" aria-label="Toggle theme">üåô</button>
      </div>
    </header>
    <div class="container">
      <div class="grid">
        <div class="card">
          <h2>Overview</h2>
          <div class="row"><div class="label">Generated</div><div class="value" id="generated">‚Äî</div></div>
          <div class="row"><div class="label">Ngrok</div><div class="value" id="ngrok">‚Äî</div></div>
        </div>
        <div class="card">
          <h2>Targets</h2>
          <div class="row"><div class="label">Detected</div><div class="value" id="targets">‚Äî</div></div>
        </div>
      </div>

      <div class="card hidden" id="conflictCard">
        <h2>‚ö†Ô∏è Route Conflicts</h2>
        <p>Multiple configuration files are declaring the same routes. Choose which config should win:</p>
        <div id="conflicts">Loading conflicts...</div>
      </div>

      <div class="card" id="appsCard">
        <h2>Configured Apps</h2>
        <div class="apps" id="apps">Loading‚Ä¶</div>
      </div>

      <div class="card view hidden" id="jsonView">
        <h2>Raw JSON</h2>
        <pre id="routesRaw">Loading‚Ä¶</pre>
      </div>
    </div>

    <script>
      function initTheme(){
        const stored = localStorage.getItem('dtpTheme');
        // Default to dark if nothing stored
        const theme = stored || 'dark';
        document.documentElement.setAttribute('data-theme', theme==='light'?'light':'dark');
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = theme==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', theme==='light'?'Switch to dark':'Switch to light');
      }
      function toggleTheme(){
        const cur = document.documentElement.getAttribute('data-theme')==='light'?'light':'dark';
        const next = cur==='light'?'dark':'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('dtpTheme', next);
        const tbtn = document.getElementById('themeToggle');
        tbtn.textContent = next==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', next==='light'?'Switch to dark':'Switch to light');
      }
      const toggleBtn = document.getElementById('toggle');
      const appsCard = document.getElementById('appsCard');
      const jsonView = document.getElementById('jsonView');
      const recommendBtn = document.getElementById('recommend');
      let showingJson = false;
      toggleBtn.addEventListener('click', () => {
        showingJson = !showingJson;
        appsCard.classList.toggle('hidden', showingJson);
        jsonView.classList.toggle('hidden', !showingJson);
        toggleBtn.textContent = showingJson ? 'Show Apps' : 'Show JSON';
      });
      recommendBtn.addEventListener('click', (e)=>{ e.preventDefault(); if (routesData) openRecommendModal(routesData); });

      function chip(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }

      // Choose best URL to open (ALWAYS prefer ngrok over localhost)
      function chooseOpenUrl(routes, targets, routeKey){
        const pref = ['ngrok', 'local-proxy'];
        
        // First pass: try to find a successful response (2xx or 3xx for ngrok, only 2xx for localhost)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) {
            if (t === 'ngrok' && info.status >= 200 && info.status < 400) {
              return info.url;
            } else if (t === 'local-proxy' && info.status >= 200 && info.status < 300) {
              return info.url;
            }
          }
        }
        
        // Second pass: return ngrok URL even if not successful (better than localhost error)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) return info.url;
        }
        
        return null;
      }

      async function loadJSON(url){
        const res = await fetch(url, { headers: { 'ngrok-skip-browser-warning':'true' } });
        if(!res.ok) throw new Error('HTTP '+res.status);
        return res.json();
      }

      let routesData = null;
      let preferences = null;

      function loadPrefs(){
        try{ return JSON.parse(localStorage.getItem('statusPrefs')||'{}'); }catch{ return {}; }
      }
      function savePrefs(p){ localStorage.setItem('statusPrefs', JSON.stringify(p||{})); }

      function routeDepth(r){ return (r||'').split('/').filter(Boolean).length; }
      function severityOf(route, targets, routes){
        // ok if ANY target is ok; redirects/0 treated as warn
        let sev='err';
        for (const t of targets){
          const info=(routes.summary?.[t]||{})[route];
          if (!info) continue;
          const s = info.status||0;
          if (s>=200 && s<300) return 'ok';
          if (s>=300 && s<400) sev = sev==='ok'?'ok':'warn';
          else if (s===0) sev = sev==='ok'?'ok':'warn';
        }
        return sev;
      }
      function applyFilter(routeGroups, filterValue, targets, routes){
        const q=(filterValue||'').trim().toLowerCase(); if(!q) return routeGroups;
        const matches = (route)=>{
          const name=(route||'').toLowerCase();
          if (name.includes(q)) return true;
          if (q==='ok'||q==='warn'||q==='err') return severityOf(route,targets,routes)===q;
          return false;
        };
        return routeGroups.filter(g=>{
          if (matches(g.route)) return true;
          return (g.children||[]).some(c=>matches(c));
        });
      }
      function sortRoutes(routeGroups, sortMode, targets, routes){
        if (sortMode==='manual'){
          const order = preferences?.routeOrder||[];
          const idx = (k)=>{ const i=order.indexOf(k); return i<0?Number.MAX_SAFE_INTEGER:i; };
          return routeGroups.slice().sort((a,b)=> idx(a.route)-idx(b.route) || a.route.localeCompare(b.route));
        }
        if (sortMode==='alpha') return routeGroups.slice().sort((a,b)=> a.route.localeCompare(b.route));
        if (sortMode==='depth') return routeGroups.slice().sort((a,b)=> routeDepth(a.route)-routeDepth(b.route) || a.route.localeCompare(b.route));
        if (sortMode==='status'){
          const rank={err:0,warn:1,ok:2};
          return routeGroups.slice().sort((a,b)=> (rank[severityOf(a.route,targets,routes)]-rank[severityOf(b.route,targets,routes)]) || a.route.localeCompare(b.route));
        }
        return routeGroups;
      }
      function rememberOrder(rendered){ preferences.routeOrder = rendered.map(g=>g.route); savePrefs(preferences); }
      (async function init(){
        preferences = loadPrefs();
        const routes = await loadJSON('/routes.json');
        routesData = routes;
        const ngrokTxt = (routes.ngrok || 'not discovered');
        document.getElementById('generated').textContent = routes.generatedAt || '‚Äî';
        document.getElementById('ngrok').textContent = ngrokTxt;
        document.getElementById('routesRaw').textContent = JSON.stringify(routes, null, 2);

        const targets = Object.keys(routes.summary||{});
        document.getElementById('targets').textContent = targets.join(', ') || '‚Äî';

        // Group by source file from metadata
        const bySource = {};
        const meta = routes.metadata || {};
        const allRoutes = new Set();
        for (const t of targets) {
          Object.keys(routes.summary[t]||{}).forEach(r => allRoutes.add(r));
        }
        // Build hierarchical route structure
        const { topLevel, hierarchical } = buildRouteHierarchy(Array.from(allRoutes));
        topLevel.forEach(r => {
          const source = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          bySource[source] = bySource[source] || [];
          bySource[source].push(r);
        });

        // Show conflict management section if there are conflicts
        showConflictManagement(routes);
        
        // Add global conflict status indicator
        updateGlobalConflictIndicator(routes);

        const appsEl = document.getElementById('apps');
        appsEl.innerHTML = '';
        Object.keys(bySource).sort().forEach(source => {
          const groupCard = document.createElement('div');
          groupCard.className = 'card';
          const head = document.createElement('div');
          head.className = 'groupHead';
          const h2 = document.createElement('h2');
          h2.textContent = source;
          const recBtn = document.createElement('a');
          recBtn.className = 'btn'; recBtn.href = '#'; recBtn.textContent = 'Recommend';
          recBtn.addEventListener('click', (e)=>{ e.preventDefault(); openRecommendModal(routesData, bySource[source]); });
          head.appendChild(h2);
          head.appendChild(recBtn);
          groupCard.appendChild(head);

          const list = document.createElement('div');
          list.className = 'apps';
          
          // Group routes by parent-child relationships
          let routeGroups = groupRoutesByHierarchy(bySource[source], hierarchical);
          const targetsArr = Object.keys(routes.summary||{});
          // Filter + sort
          const sortEl = document.getElementById('sortMode');
          const filterEl = document.getElementById('routeFilter');
          const sortMode = (preferences?.sortMode) || (sortEl && sortEl.value) || 'manual';
          const filterVal = (preferences?.filter) || (filterEl && filterEl.value) || '';
          routeGroups = applyFilter(routeGroups, filterVal, targetsArr, routes);
          routeGroups = sortRoutes(routeGroups, sortMode, targetsArr, routes);
          
          routeGroups.forEach(group => {
            const app = document.createElement('div');
            app.className = 'app';
            
            if (group.children && group.children.length > 0) {
              // Parent route with children - make it expandable
              app.classList.add('expandable-route');
              
              const header = document.createElement('div');
              header.className = 'route-header';
              header.innerHTML = `
                <div class="route-title">
                  <span class="expand-icon">‚ñ∂</span>
                  <span class="route-name">${group.route}</span>
                  <span class="child-count">(${group.children.length} sub-routes)</span>
                </div>
              `;
              
              const childrenContainer = document.createElement('div');
              childrenContainer.className = 'route-children hidden';
              
              // Add parent route info
              addRouteInfo(app, group.route, targets, routes);
              // Add child summary chips on parent header (worst-state coloring, show HTTP code where applicable)
              const summaryChips = document.createElement('div');
              summaryChips.className = 'chips';
              const childWorst = { err:0, warn:0, ok:0 };
              (group.children||[]).forEach(childRoute=>{
                const sev = severityOf(childRoute, targets, routes);
                childWorst[sev]++;
                // Prefer showing status from ngrok, else local-proxy
                const pref = ['ngrok','local-proxy'];
                let code = null;
                for (const t of pref){ const info=(routes.summary?.[t]||{})[childRoute]; if (info && typeof info.status==='number'){ code=info.status; break; } }
                const label = `${childRoute} ${code??''}`.trim();
                summaryChips.appendChild(chip(label, sev));
              });
              if ((group.children||[]).length){ header.appendChild(summaryChips); }
              
              // Add children
              group.children.forEach(child => {
                const childApp = document.createElement('div');
                childApp.className = 'child-route';
                const childTitle = document.createElement('div');
                childTitle.className = 'route child-route-name';
                childTitle.textContent = child;
                childApp.appendChild(childTitle);
                addRouteInfo(childApp, child, targets, routes);
                childrenContainer.appendChild(childApp);
              });
              
              // Toggle functionality
              header.addEventListener('click', () => {
                const isExpanded = !childrenContainer.classList.contains('hidden');
                childrenContainer.classList.toggle('hidden', isExpanded);
                header.querySelector('.expand-icon').textContent = isExpanded ? '‚ñ∂' : '‚ñº';
              });
              
              // Auto-expand when filter matches any child
              if (filterVal){
                const q=(filterVal||'').trim().toLowerCase();
                const anyMatch = (group.children||[]).some(c=>{
                  const name=(c||'').toLowerCase();
                  if (name.includes(q)) return true;
                  if (q==='ok'||q==='warn'||q==='err') return severityOf(c, targets, routes)===q;
                  return false;
                });
                if (anyMatch){
                  childrenContainer.classList.remove('hidden');
                  header.querySelector('.expand-icon').textContent = '‚ñº';
                }
              }

              app.appendChild(header);
              app.appendChild(childrenContainer);
            } else {
              // Regular standalone route
              const title = document.createElement('div');
              title.className = 'route';
              title.textContent = group.route;
              app.appendChild(title);
              addRouteInfo(app, group.route, targets, routes);
            }
            // Reorder controls
            if (document.body.classList.contains('reorder-mode')){
              const controls=document.createElement('div');
              controls.className='chips';
              const up=document.createElement('button'); up.className='drag-btn'; up.textContent='‚Üë';
              const down=document.createElement('button'); down.className='drag-btn'; down.textContent='‚Üì';
              up.addEventListener('click',()=>{
                const order = preferences.routeOrder||[]; const i=order.indexOf(group.route);
                if (i>0){ [order[i-1],order[i]]=[order[i],order[i-1]]; savePrefs(preferences); location.reload(); }
              });
              down.addEventListener('click',()=>{
                const order = preferences.routeOrder||[]; const i=order.indexOf(group.route);
                if (i>-1 && i<order.length-1){ [order[i+1],order[i]]=[order[i],order[i+1]]; savePrefs(preferences); location.reload(); }
              });
              controls.appendChild(up); controls.appendChild(down);
              app.appendChild(controls);
            }
            list.appendChild(app);
          });
          groupCard.appendChild(list);
          appsEl.appendChild(groupCard);
        });

        // Capture initial order if not set
        if (!(preferences.routeOrder||[]).length){
          const rendered = Array.from(document.querySelectorAll('.app .route')).map(el=>({route:el.textContent.trim()}));
          rememberOrder(rendered);
        }
      })().catch(err => {
        document.getElementById('apps').textContent = 'Error: '+err.message;
      });

      // Controls wiring
      (function initControls(){
        const sortEl=document.getElementById('sortMode');
        const filterEl=document.getElementById('routeFilter');
        const reorderEl=document.getElementById('toggleReorder');
        preferences = loadPrefs();
        if (sortEl){ if (preferences.sortMode) sortEl.value=preferences.sortMode; sortEl.addEventListener('change',(e)=>{ preferences.sortMode=e.target.value; savePrefs(preferences); location.reload(); }); }
        if (filterEl){ if (preferences.filter) filterEl.value=preferences.filter; filterEl.addEventListener('input',(e)=>{ preferences.filter=e.target.value; savePrefs(preferences); location.reload(); }); }
        if (reorderEl){ reorderEl.addEventListener('click',()=>{ document.body.classList.toggle('reorder-mode'); }); }
      })();

      // Conflict Management Functions
      function showConflictManagement(routes) {
        const conflictCard = document.getElementById('conflictCard');
        const conflictsDiv = document.getElementById('conflicts');
        
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        
        if (!hasConflicts) {
          conflictCard.classList.add('hidden');
          return;
        }
        
        conflictCard.classList.remove('hidden');
        conflictsDiv.innerHTML = '';
        
        // Parse nginx warnings to extract conflict information
        const conflicts = parseConflictWarnings(routes.nginxWarnings || []);
        
        conflicts.forEach(conflict => {
          const conflictDiv = document.createElement('div');
          conflictDiv.className = 'conflict-item';
          conflictDiv.innerHTML = `
            <div class="conflict-header">
              <h3>Route: ${conflict.route}</h3>
              <div class="conflict-status">
                Current winner: <strong>${conflict.winner}</strong>
              </div>
            </div>
            <div class="conflict-options">
              <div class="conflict-configs">
                ${conflict.configs.map(config => `
                  <label class="config-option ${config === conflict.winner ? 'active' : ''}">
                    <input type="radio" name="conflict-${conflict.route}" value="${config}" ${config === conflict.winner ? 'checked' : ''}>
                    <span class="config-name">${config}</span>
                    <div class="config-actions">
                      <button class="btn-small" onclick="viewConfig('${config}')">View</button>
                      <button class="btn-small" onclick="renameRoute('${conflict.route}', '${config}')">Rename Route</button>
                    </div>
                  </label>
                `).join('')}
              </div>
              <div class="conflict-actions">
                <button class="btn" onclick="resolveConflict('${conflict.route}')">Apply Selection</button>
                <button class="btn" onclick="autoFixConflict('${conflict.route}')">Auto-Fix</button>
              </div>
            </div>
          `;
          conflictsDiv.appendChild(conflictDiv);
        });
      }

      function parseConflictWarnings(warnings) {
        const conflicts = [];
        warnings.forEach(warning => {
          // Parse warning like: "Route /api/: NEW CONFLICT - encast.conf wins (first config) over test-conflict.conf"
          const routeMatch = warning.match(/Route ([^:]+):/);
          const winnerMatch = warning.match(/- ([^\\s]+)\\.conf wins.*over ([^\\s,]+(?:\\.conf)?)/);
          
          if (routeMatch && winnerMatch) {
            const route = routeMatch[1];
            const winner = winnerMatch[1] + '.conf';
            const loser = winnerMatch[2].endsWith('.conf') ? winnerMatch[2] : winnerMatch[2] + '.conf';
            
            conflicts.push({
              route,
              winner,
              configs: [winner, loser]
            });
          }
        });
        return conflicts;
      }

      async function resolveConflict(route) {
        const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
        if (!selectedRadio) return;
        
        const newWinner = selectedRadio.value;
        
        try {
          const response = await fetch('/api/resolve-conflict', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ route, winner: newWinner })
          });
          
          if (response.ok) {
            // Refresh the page to show updated conflicts
            location.reload();
          } else {
            alert('Failed to resolve conflict. Check console for details.');
          }
        } catch (error) {
          alert('Error resolving conflict: ' + error.message);
        }
      }

      function viewConfig(configFile) {
        openConfigModal(configFile);
      }

      function renameRoute(route, configFile) {
        const newRoute = prompt(`Rename route ${route} in ${configFile} to:`, route);
        if (newRoute && newRoute !== route) {
          renameRouteInConfig(route, newRoute, configFile);
        }
      }

      function autoFixConflict(route) {
        // Smart auto-fix suggestions based on route type
        const suggestions = getAutoFixSuggestions(route);
        
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2>Auto-Fix Suggestions for ${route}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <p>Here are intelligent suggestions to resolve this conflict:</p>
              ${suggestions.map(s => `
                <div class="suggestion-item">
                  <h3>${s.title}</h3>
                  <p>${s.description}</p>
                  <code>${s.example}</code>
                  <button class="btn" onclick="applySuggestion('${route}', '${s.action}', '${s.params}')">Apply This Fix</button>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      function getAutoFixSuggestions(route) {
        const suggestions = [];
        
        if (route === '/api/') {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Rename one route to be app-specific',
            example: 'location /myapp/api/ { ... }',
            action: 'rename',
            params: '/myapp/api/'
          });
          suggestions.push({
            title: 'Use Versioned API',
            description: 'Add version to make routes unique',
            example: 'location /api/v1/ { ... }',
            action: 'rename', 
            params: '/api/v1/'
          });
        } else if (route === '/admin/') {
          suggestions.push({
            title: 'App-Specific Admin',
            description: 'Make admin path unique to your app',
            example: 'location /myapp/admin/ { ... }',
            action: 'rename',
            params: route.replace('/admin/', '/myapp/admin/')
          });
        } else {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Prepend your app name to make the route unique',
            example: `location /myapp${route} { ... }`,
            action: 'rename',
            params: `/myapp${route}`
          });
        }
        
        suggestions.push({
          title: 'Let First Config Win', 
          description: 'Keep the current winner, no changes needed',
          example: 'No configuration changes required',
          action: 'accept',
          params: ''
        });
        
        return suggestions;
      }

      async function applySuggestion(route, action, params) {
        if (action === 'accept') {
          document.querySelector('.modal').remove();
          return;
        }
        
        if (action === 'rename') {
          const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
          if (!selectedRadio) {
            alert('Please select a config file first');
            return;
          }
          
          const configFile = selectedRadio.value;
          await renameRouteInConfig(route, params, configFile);
          document.querySelector('.modal').remove();
        }
      }

      async function renameRouteInConfig(oldRoute, newRoute, configFile) {
        try {
          const response = await fetch('/api/rename-route', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ oldRoute, newRoute, configFile })
          });
          
          if (response.ok) {
            alert(`Route renamed successfully. Please restart the proxy for changes to take effect.`);
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to rename route: ' + error);
          }
        } catch (error) {
          alert('Error renaming route: ' + error.message);
        }
      }

      function openConfigModal(configFile) {
        // Create and show config viewing modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content large">
            <div class="modal-header">
              <h2>Config File: ${configFile}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <div class="config-actions">
                <button class="btn" onclick="downloadConfig('${configFile}')">Download</button>
                <button class="btn" onclick="enableConfigEdit(this)">Edit</button>
              </div>
              <pre id="config-content" class="config-display">Loading...</pre>
              <textarea id="config-editor" class="config-editor hidden" rows="30"></textarea>
              <div class="edit-actions hidden">
                <button class="btn" onclick="saveConfig('${configFile}')">Save Changes</button>
                <button class="btn" onclick="cancelConfigEdit()">Cancel</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        loadConfigContent(configFile);
      }

      async function loadConfigContent(configFile) {
        try {
          const response = await fetch(`/api/config/${configFile}`);
          const content = await response.text();
          
          if (response.ok) {
            document.getElementById('config-content').textContent = content;
            document.getElementById('config-editor').value = content;
          } else {
            document.getElementById('config-content').textContent = `Error loading config: ${content}`;
          }
        } catch (error) {
          document.getElementById('config-content').textContent = `Error: ${error.message}`;
        }
      }

      function enableConfigEdit(button) {
        document.getElementById('config-content').classList.add('hidden');
        document.getElementById('config-editor').classList.remove('hidden');
        document.querySelector('.edit-actions').classList.remove('hidden');
        button.style.display = 'none';
      }

      function cancelConfigEdit() {
        document.getElementById('config-content').classList.remove('hidden');
        document.getElementById('config-editor').classList.add('hidden');
        document.querySelector('.edit-actions').classList.add('hidden');
        document.querySelector('.config-actions button:nth-child(2)').style.display = '';
      }

      async function saveConfig(configFile) {
        const content = document.getElementById('config-editor').value;
        
        try {
          const response = await fetch(`/api/config/${configFile}`, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: content
          });
          
          if (response.ok) {
            alert('Config saved successfully. Restart the proxy for changes to take effect.');
            document.querySelector('.modal').remove();
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to save config: ' + error);
          }
        } catch (error) {
          alert('Error saving config: ' + error.message);
        }
      }

      function downloadConfig(configFile) {
        const content = document.getElementById('config-content').textContent;
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = configFile;
        a.click();
        URL.revokeObjectURL(url);
      }

      function updateGlobalConflictIndicator(routes) {
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        
        const existingIndicator = document.querySelector('.global-conflict-indicator');
        if (existingIndicator) existingIndicator.remove();
        
        if (hasConflicts) {
          const conflictCount = routes.nginxWarnings ? routes.nginxWarnings.length : 1;
          const indicator = document.createElement('div');
          indicator.className = 'global-conflict-indicator';
          indicator.innerHTML = `
            <div class="conflict-badge">
              ‚ö†Ô∏è ${conflictCount} Route Conflict${conflictCount > 1 ? 's' : ''}
              <button onclick="document.getElementById('conflictCard').scrollIntoView({behavior: 'smooth'})">
                Resolve
              </button>
            </div>
          `;
          document.body.appendChild(indicator);
        }
      }

      // Hierarchical route structure helpers
      function buildRouteHierarchy(allRoutes) {
        const hierarchical = new Map();
        
        // Filter to meaningful routes (exclude system routes and technical sub-routes)  
        const meaningfulRoutes = allRoutes.filter(r => 
          !['/health/', '/status/', '/reports/', '/api/config/', '/api/resolve-conflict', '/api/rename-route'].includes(r) &&
          !r.includes('/node_modules/') && !r.includes('/@') && !r.includes('/sockjs-node/') && 
          !r.includes('/storybook-server-channel/') && !r.includes('/_next/') && !r.includes('/src/')
        );
        
        // Build parent-child relationships
        meaningfulRoutes.forEach(route => {
          const parent = findParentRoute(route, meaningfulRoutes);
          if (parent && parent !== route) {
            if (!hierarchical.has(parent)) {
              hierarchical.set(parent, []);
            }
            hierarchical.get(parent).push(route);
          }
        });
        
        // Top level routes are those without parents or are parents themselves
        const topLevel = meaningfulRoutes.filter(r => {
          const parent = findParentRoute(r, meaningfulRoutes);
          return !parent || parent === r || hierarchical.has(r);
        });
        
        return { topLevel: [...new Set(topLevel)], hierarchical };
      }
      
      function findParentRoute(route, allRoutes) {        
        // For API sub-routes like /api/static/, parent is /api/
        if (route.startsWith('/api/') && route !== '/api/') {
          return '/api/';
        }
        
        // Only group very specific cases to avoid excessive sub-routes
        if (route.startsWith('/static/') && route !== '/static/') {
          return '/static/';
        }
        
        return null;
      }
      
      function groupRoutesByHierarchy(routes, hierarchical) {
        const groups = [];
        const processed = new Set();
        
        routes.forEach(route => {
          if (processed.has(route)) return;
          
          const children = hierarchical.get(route) || [];
          const validChildren = children.filter(child => routes.includes(child));
          
          groups.push({
            route: route,
            children: validChildren
          });
          
          processed.add(route);
          validChildren.forEach(child => processed.add(child));
        });
        
        return groups;
      }
      
      function addRouteInfo(appElement, route, targets, routes) {
        const chips = document.createElement('div');
        chips.className = 'chips';
        
        let severity = 'err';
        let hasValidResponse = false;
        
        for (const t of targets) {
          const info = (routes.summary[t] || {})[route];
          if (!info) continue;
          
          const status = info.status || 0;
          
          // More intelligent status interpretation
          const isApiRoute = route.includes('/api');
          const isStaticRoute = route.includes('/static') || route.includes('/node_modules') || route.includes('/sockjs-node');
          const isPaymentRoute = route.includes('/payment');
          
          let cls, reason;
          
          if (status >= 200 && status < 300) {
            cls = 'ok';
            hasValidResponse = true;
            reason = 'Working correctly';
          } else if (status >= 300 && status < 400) {
            cls = 'ok'; // Redirects are often expected
            hasValidResponse = true;
            reason = 'Redirect (often expected behavior)';
          } else if (status === 404) {
            // 404 is not always an error - depends on route type
            if (isStaticRoute) {
              cls = 'warn';
              reason = 'Static resource not found (may be dynamically loaded)';
            } else if (isApiRoute || isPaymentRoute) {
              // For API/payment routes, check if the service is actually up
              cls = 'warn';
              reason = 'Endpoint returned 404 - check if service expects different path or method';
            } else {
              cls = 'err';
              reason = 'Route not found';
            }
          } else if (status === 0) {
            cls = 'warn';
            reason = 'No response from this target (connection failed)';
          } else if (status >= 400 && status < 500) {
            cls = 'warn';
            reason = 'Client error - check route configuration';
          } else if (status >= 500) {
            cls = 'err';
            reason = 'Server error - upstream service issue';
          }
          
          const labelName = (t === 'local-proxy') ? 'localhost' : t;
          const label = `${labelName}: ${status}`;
          chips.appendChild(chip(label, cls, reason));
          
          // WebSocket status for development routes
          if (info.websocket && route !== '/api/' && !isStaticRoute) {
            if (!info.websocket.ok && status >= 200 && status < 300) {
              chips.appendChild(chip('ws fail', 'warn', 'WebSocket upgrade failed - may affect hot reload'));
            } else if (info.websocket.ok) {
              chips.appendChild(chip('ws ok', 'ok', 'WebSocket connection successful'));
            }
          }
          
          // Update overall severity (green if ANY target is good)
          if (cls === 'ok') severity = 'ok';
          else if (cls === 'warn' && severity !== 'ok') severity = 'warn';
        }
        
        appElement.appendChild(chips);
        
        // Hide noisy technical-only routes completely
        const noisy = route.includes('/node_modules/') || route.includes('/@') || route.includes('/sockjs-node/') ||
                      route.includes('/storybook-server-channel/') || route.includes('/_next/') || route === '/static/' || route === '/.storybook/';
        if (noisy) return;

        // Add action buttons
        const diag = document.createElement('div');
        diag.className = 'chips';
        
        const openBtn = document.createElement('a');
        openBtn.className = 'btn';
        openBtn.textContent = 'Open';
        openBtn.href = '#';
        openBtn.addEventListener('click', (e) => {
          e.preventDefault();
          const url = chooseOpenUrl(routes, targets, route);
          if (url) window.open(url, '_blank', 'noopener');
        });
        
        const diagBtn = document.createElement('a');
        diagBtn.className = 'btn';
        diagBtn.textContent = 'Diagnose';
        diagBtn.href = '#';
        diagBtn.addEventListener('click', (e) => {
          e.preventDefault();
          openDiagnoseModal(route, targets, routes);
        });
        
        diag.appendChild(openBtn);
        diag.appendChild(diagBtn);
        appElement.appendChild(diag);
        
        // Apply severity styling
        appElement.classList.add(severity);
      }

      // Modal logic
      function openDiagnoseModal(routeKey, targets, routes){
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Diagnose: <code>${routeKey}</code></h2>
          <div class="section"><h3>Detected Issues</h3><div id="issues"></div></div>
          <div class="section"><h3>Suggested Nginx Snippet</h3><pre id="snippet"></pre></div>
          <div class="section"><h3>Repair Commands</h3><pre id="commands"></pre></div>
          <div class="toolbar"><button class="btn" id="copySnippet">Copy snippet</button><button class="btn" id="copyCmds">Copy commands</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Build issues list
        const issues = [];
        for (const t of targets){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (!info) continue;
          const status = info.status||0;
          if (!(status>=200 && status<300)) issues.push(`${t}: HTTP ${status}`);
          // Note: API conflict detection removed
          if (info.websocket && !info.websocket.ok) issues.push(`${t}: websocket upgrade failed`);
        }
        if (!issues.length) issues.push('No obvious issues detected.');
        modal.querySelector('#issues').innerHTML = `<ul>${issues.map(i=>`<li>${i}</li>`).join('')}</ul>`;

        // Build snippet template
        const name = routeKey.replace(/^\/(.*?)\/?$/, '$1');
        let snippet='';
        if (routeKey === '/api/') {
          snippet = `# Preserve /api prefix to upstream service\nlocation /api/ {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://SERVICE_ALIAS:PORT;\n}`;
        } else if (/^\/[A-Za-z0-9_-]+\/$/.test(routeKey)) {
          snippet = `# Keep prefix, enable HMR\nlocation = ${routeKey.slice(0,-1)} { rewrite ^ ${routeKey} last; }\nlocation ^~ ${routeKey}_next/ {\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_pass http://${name}-app:2000${routeKey}_next/;\n}\nlocation ^~ ${routeKey} {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-Host $host;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header X-Forwarded-Prefix ${routeKey.slice(0,-1)};\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://${name}-app:2000${routeKey};\n}`;
        } else {
          snippet = `# Example mapping\nlocation ^~ ${routeKey} {\n  proxy_pass http://SERVICE_ALIAS:PORT${routeKey};\n}`;
        }
        modal.querySelector('#snippet').textContent = snippet;

        // Commands
        const cmd = `# Copy snippet to apps/${name||'myapp'}.conf and reload\n./scripts/install-app.sh ${name||'myapp'} examples/next/myapp.conf || true\n# Or place the generated snippet into apps/${name||'myapp'}.conf then:\ndocker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#commands').textContent = cmd;

        // Copy handlers
        modal.querySelector('#copySnippet').addEventListener('click',()=>{
          navigator.clipboard.writeText(snippet);
        });
        modal.querySelector('#copyCmds').addEventListener('click',()=>{
          navigator.clipboard.writeText(cmd);
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }

      // Recommend modal ‚Äì aggregates issues and provides generic fixes/snippets
      function openRecommendModal(routes, onlyRoutes){
        const targets = Object.keys(routes.summary||{});
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Recommendations</h2>
          <div class=\"section\"><h3>Detected Issues</h3><div id=\"issues\"></div></div>
          <div class="section"><h3>Standard Fixes</h3><ul id="fixes"></ul></div>
          <div class="section"><h3>Snippets</h3>
            <p><strong>Keep prefix (Next.js basePath)</strong></p>
            <pre id="snKeep"></pre>
            <p><strong>Strip prefix (CRA/Storybook)</strong></p>
            <pre id="snStrip"></pre>
            <p><strong>Preserve /api prefix</strong></p>
            <pre id="snApi"></pre>
          </div>
          <div class="section"><h3>Commands</h3><pre id="cmds"></pre></div>
          <div class="toolbar"><button class="btn" id="copyAll">Copy all</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Group issues by endpoint for readability
        const issuesByRoute = {};
        targets.forEach(t=>{
          const m = routes.summary[t]||{};
          const routeKeys = onlyRoutes && onlyRoutes.length ? onlyRoutes : Object.keys(m);
          routeKeys.forEach(r=>{
            const info = m[r]||{};
            const st = info.status||0;
            const msgs = [];
            if (!(st>=200 && st<300)) msgs.push(`${t}: HTTP ${st}`);
            if (info.websocket && !info.websocket.ok) msgs.push(`${t}: websocket upgrade failed`);
            // Only flag API ownership conflicts if owned by different config
            // Note: API conflict detection removed
            if (msgs.length) {
              issuesByRoute[r] = issuesByRoute[r] || [];
              issuesByRoute[r].push(...msgs);
            }
          });
        });
        const blocks = Object.keys(issuesByRoute).sort().map(r => `<div class=\"section\"><h3>${r}</h3><ul>${issuesByRoute[r].map(i=>`<li>${i}</li>`).join('')}</ul></div>`);
        modal.querySelector('#issues').innerHTML = blocks.length ? blocks.join('') : '<p>No warnings/errors detected.</p>';

        const fixes = [
          'Ensure all dev services join the external "devproxy" network and use service aliases as upstream hosts.',
          'Avoid proxy_pass variables for dev routes; use fixed upstreams. Use trailing slash to strip prefix when needed.',
          'For HMR: set proxy_http_version 1.1 and Upgrade/Connection headers on prefix routes.',
          'For Next.js behind a path: run a basePath-aware dev instance and DO NOT strip the prefix in the proxy.',
          'For CRA/Storybook behind a path: strip the prefix with trailing-slash proxy_pass and configure PUBLIC_URL or builder base/publicPath.',
          'If multiple projects share /api, keep /api mapped to the API app and ensure other apps call a prefixed API or separate domain.',
        ];
        modal.querySelector('#fixes').innerHTML = fixes.map(f=>`<li>${f}</li>`).join('');

        const snKeep = `# Keep prefix (Next.js basePath example)
location = /myapp { rewrite ^ /myapp/ last; }
location ^~ /myapp/_next/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_pass http://myapp-app:2000/myapp/_next/;
}
location ^~ /myapp/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Prefix /myapp;
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://myapp-app:2000/myapp/;
}`;

        const snStrip = `# Strip prefix (CRA/Storybook example)
location ^~ /ui/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://ui-app:3000/;  # trailing slash strips /ui/
}`;

        const snApi = `# Preserve /api prefix to API upstream
location /api/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://api-app:8000;
}`;

        modal.querySelector('#snKeep').textContent = snKeep;
        modal.querySelector('#snStrip').textContent = snStrip;
        modal.querySelector('#snApi').textContent = snApi;

        const cmds = `# Re-scan and update status JSON
node ./test/scanApps.js

# Install a snippet into apps/<name>.conf and reload
./scripts/install-app.sh myapp examples/next/myapp.conf || true
docker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#cmds').textContent = cmds;

        const copyAllBtn = modal.querySelector('#copyAll');
        modal.querySelector('#copyAll').addEventListener('click',()=>{
          const all = [snKeep, snStrip, snApi, cmds].join('\n\n');
          navigator.clipboard.writeText(all).then(()=>{
            copyAllBtn.classList.add('copied');
            const prev = copyAllBtn.textContent;
            copyAllBtn.textContent = 'Copied!';
            setTimeout(()=>{ copyAllBtn.textContent = prev; copyAllBtn.classList.remove('copied'); }, 1500);
          });
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      initTheme();
    </script>
  </body>
  </html>


