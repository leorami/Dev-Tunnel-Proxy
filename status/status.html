<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dev Proxy Status</title>
    <link rel="icon" type="image/svg+xml" href="/status/assets/favicon.svg" />
    <link rel="icon" type="image/png" href="/status/assets/favicon.png" />
    <link rel="shortcut icon" href="/status/assets/favicon.svg" />
    <script>
      // Default the global flag early so handlers never see undefined
      window.__calliopeEnabled = false;
    </script>
    <style>
      :root{--bg:#0c111c;--bg2:#0e1627;--panel:#101827;--panelGlass:rgba(16,24,39,.92);--appBgGlass:rgba(13,20,36,.95);--border:#1f2a44;--muted:#8a9bb7;--text:#e4ecfa;--heading:#cfe0ff;--chip:#1a2440;--chipBg:#132140;--chipBorder:#263455;--chipText:#b8c8e6;--ok:#16c784;--warn:#f59e0b;--err:#ef4444;--lnk:#7fb0ff;--btnBg:rgba(19,42,77,.45);--btnBorder:rgba(58,110,174,.55);--btnText:#cfe0ff;--btnBgHover:rgba(22,52,95,.6);--headerBg:rgba(10,16,30,.55);--codeBg:#0a1223;--codeBorder:#1b2a48;--glowOpacity:.10;--summaryGap:24px}
      :root[data-theme="light"]{--bg:#edf2fb;--bg2:#f7faff;--panel:#ffffff;--panelGlass:rgba(255,255,255,.88);--appBgGlass:rgba(255,255,255,.9);--border:#d6e0f5;--muted:#5b6b8a;--text:#0b1220;--heading:#0b1220;--chip:#e8eefc;--chipBg:#eef2ff;--chipBorder:#cddcff;--chipText:#0b1220;--ok:#0f9d6a;--warn:#b7791f;--err:#c24141;--lnk:#2d6cdf;--btnBg:#eef2ff;--btnBorder:#bfd1ff;--btnText:#0b1220;--btnBgHover:#e2e8ff;--headerBg:rgba(255,255,255,.78);--codeBg:#f6f8ff;--codeBorder:#d6e0f5;--glowOpacity:.14}
      *{box-sizing:border-box}
      body{margin:0;background:linear-gradient(180deg,var(--bg),var(--bg2));color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica Neue,Arial,Noto Sans}
      header{padding:16px 20px 12px 20px;border-bottom:1px solid var(--border);background:var(--headerBg);backdrop-filter:saturate(180%) blur(10px);position:sticky;top:0;z-index:1000;box-shadow:0 10px 30px rgba(0,0,0,.25)}
      .header-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .header-actions{display:flex;gap:8px;align-items:center}
      header h1{font-size:16px;margin:0;display:flex;gap:10px;align-items:center}
      header h1 span{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--chip);color:var(--text);font-weight:600}
      .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding-top:4px}
      .toolbar.centered{justify-content:center;margin:20px auto 18px}
      .toolbar .field{display:flex;gap:6px;align-items:center}
      .toolbar select,.toolbar input[type="text"]{background:var(--btnBg);border:1px solid var(--btnBorder);color:var(--btnText);border-radius:8px;padding:7px 10px}
      .btn{appearance:none;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText);border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:600;text-decoration:none;text-align:center;backdrop-filter:saturate(160%) blur(6px);box-shadow:inset 0 1px 0 rgba(255,255,255,.05), 0 4px 18px rgba(0,0,0,.25)}
      .btn:hover{background:var(--btnBgHover)}
      .btn:active{transform:translateY(1px)}
      .btn.copied{background:#16402b;border-color:#2a7f54;color:#a6f3cc}
      .content{width: 100%}
      .container{max-width:1100px;margin:16px auto;padding:0 16px}
      .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;margin-bottom:16px}
      .content{padding:0 16px}
      .summaryRow{position:sticky;top:calc(var(--headerH, 64px) + var(--summaryGap, 12px));z-index:2004;background:var(--headerBg);backdrop-filter:saturate(180%) blur(8px);border-radius: 12px;}
      .appsHeader{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;background:var(--headerBg);border:1px solid var(--border);border-radius:10px;padding:8px 12px}
      .appsHeader .toolbar{padding-top:0}
      .card{background:var(--panelGlass);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.25);backdrop-filter:saturate(160%) blur(6px);transition:box-shadow .12s ease; font-size: 12px}
      .card:hover{box-shadow:0 10px 28px rgba(0,0,0,.30)}
      .card h2{margin:0 0 10px 0;font-size:14px;color:var(--heading);letter-spacing:.2px; padding: 0 0 8px 0}
      .row{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
      .apps-controls{justify-content:flex-start}
      .field{display:inline-block;margin-right:10px}
      .label{color:var(--muted)}
      .value{font-weight:600}
      .ok{color:var(--ok)}.warn{color:var(--warn)}.err{color:var(--err)}
      .apps{display:grid;grid-template-columns:repeat(2, 1fr);gap:12px;grid-auto-rows:min-content;align-items:start;width:100%;max-width:100%}
      .app{background:var(--appBgGlass);border:1px solid var(--border);border-radius:10px;padding:12px;transition:transform .12s ease, box-shadow .12s ease;box-shadow:inset 0 1px 0 rgba(255,255,255,.02);position:relative;min-width:0;height:auto}
      .app .config-label{position:absolute;bottom:8px;right:8px;font-size:10px;color:var(--muted);opacity:0.6;font-weight:600;padding:2px 6px;background:var(--codeBg);border-radius:4px;border:1px solid var(--codeBorder)}
      /* When grouped by config file, force single column layout */
      .apps.grouped-layout{grid-template-columns:1fr !important}
      .config-group-card{background:var(--panelGlass);border:2px solid var(--border);border-radius:12px;padding:16px;height:fit-content;box-sizing:border-box;margin-bottom:16px}
      .config-group-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--border)}
      .config-group-header h2{margin:0;font-size:15px;color:var(--heading);font-weight:700}
      .config-route-count{font-size:12px;color:var(--muted);background:var(--chip);padding:4px 10px;border-radius:999px;font-weight:600}
      .config-routes-container{display:flex;flex-direction:column;gap:12px}
      .config-routes-container .app{background:var(--panel);box-shadow:0 2px 8px rgba(0,0,0,.15)}
      .config-routes-container .app .config-label{display:none}
      
      /* Compact View Styles - More aggressive spacing reduction */
      body[data-view="compact"] .card{padding:10px;font-size:11px}
      body[data-view="compact"] .card h2{font-size:13px;margin-bottom:8px;padding-bottom:6px}
      body[data-view="compact"] .app{padding:8px;font-size:11px}
      body[data-view="compact"] .app .route{font-size:12px}
      body[data-view="compact"] .chip{padding:3px 6px;font-size:10px;gap:3px}
      body[data-view="compact"] .chips{gap:4px;margin-top:4px}
      body[data-view="compact"] .apps{gap:8px}
      body[data-view="compact"] .groupHead{margin-bottom:6px}
      body[data-view="compact"] .row{margin:4px 0}
      .app:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .app.ok{border-color:rgba(22,199,132,.7);box-shadow:0 0 0 2px rgba(22,199,132,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.warn{border-color:rgba(245,158,11,.7);box-shadow:0 0 0 2px rgba(245,158,11,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app.err{border-color:rgba(239,68,68,.8);box-shadow:0 0 0 2px rgba(239,68,68,var(--glowOpacity)), 0 8px 24px rgba(0,0,0,.20)}
      .app .route{font-weight:700}
      .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
      .groupHead{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .groupHead .chips{gap:6px}
      .groupHead .btn-small{font-size:12px;padding:6px 10px}
      .chip{display:inline-flex;gap:6px;align-items:center;padding:5px 8px;border-radius:999px;background:var(--chipBg);border:1px solid var(--chipBorder);color:var(--chipText);position:relative}
      .chip.ok{background:rgba(22,199,132,.12);border-color:rgba(22,199,132,.35);color:#0f9d6a;font-weight:700}
      .chip.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.35);color:#b7791f;font-weight:700}
      .chip.err{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:#c24141;font-weight:700}
      .chip[data-tip]:hover:after{content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:calc(100% + 8px);white-space:pre-wrap;max-width:280px;background:#0a1223;color:#d9e2f1;border:1px solid #1b2a48;border-radius:8px;padding:8px;box-shadow:0 10px 30px rgba(0,0,0,.45);z-index:30}
      .chip[data-tip]:hover:before{content:"";position:absolute;left:50%;transform:translateX(-50%);bottom:100%;border:6px solid transparent;border-top-color:#1b2a48}
      .chip a{color:var(--lnk);text-decoration:none}
      .view{margin-top:12px}
      pre{margin:0;background:var(--codeBg, #0a1223);border:1px solid var(--codeBorder, #1b2a48);padding:12px;border-radius:10px;max-height:420px;overflow:auto}
      .switch{display:flex;gap:8px;align-items:center}
      .hidden{display:none}
      .summaryChips{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
      .chip strong{font-weight:700;margin-right:6px}
      .overviewCard{margin-bottom:8px;padding:12px 16px}
      /* Modal */
      .backdrop,.overlay{position:fixed;inset:0;background:rgba(3,8,20,.55);backdrop-filter:saturate(160%) blur(10px);display:flex;align-items:center;justify-content:center;padding:16px;z-index:3000;overflow:auto}
      .modal{max-width:860px;width:min(860px,96vw);background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:0 24px 70px rgba(0,0,0,.65);padding:20px;max-height:calc(100vh - 48px);overflow:auto;z-index:3002}
      .modal h2{margin:0 0 8px 0;color:var(--heading);font-size:16px}
      .modal .section{margin:10px 0;padding:10px;border:1px dashed var(--border);border-radius:8px;background:var(--codeBg)}
      .modal .section h3{margin:0 0 6px 0;font-size:13px;color:var(--heading)}
      .modal pre{max-height:280px}
      .modal .toolbar{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}

      /* Notifications modal */
      .notif-header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-bottom:16px}
      .notif-header .title{display:flex;flex-direction:column;gap:2px}
      .notif-header .title small{color:var(--muted);font-size:12px}
      .notif-actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
      .notif-list{display:flex;flex-direction:column;gap:10px}
      .notif-item{border:1px solid var(--border);border-radius:10px;padding:14px;background:var(--bg2)}
      .notif-item.recycled{opacity:.72}
      .notif-row{display:flex;align-items:center;justify-content:space-between;gap:12px}
      .notif-summary{display:flex;flex-direction:column;gap:4px}
      .notif-summary .line1{font-weight:700;color:var(--heading);font-size:13px}
      .notif-summary .line2{color:var(--muted);font-size:12px}
      .notif-controls{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}
      .notif-pill{display:inline-flex;align-items:center;gap:6px;padding:5px 8px;border-radius:999px;background:var(--chipBg);border:1px solid var(--chipBorder);color:var(--chipText);font-size:12px}
      .notif-pill.ok{background:rgba(22,199,132,.12);border-color:rgba(22,199,132,.35);color:var(--ok);font-weight:700}
      .notif-pill.warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.35);color:var(--warn);font-weight:700}
      .notif-pill.err{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:var(--err);font-weight:700}
      .notif-divider{height:1px;background:var(--border);margin:10px 0}
      .notif-empty{padding:14px;border:1px dashed var(--border);border-radius:10px;color:var(--muted);background:var(--bg2);text-align:center}
      .notif-wiz{display:flex;flex-direction:column;gap:16px}
      .notif-steps{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:4px}
      .notif-step{display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border-radius:999px;border:1px solid var(--border);background:var(--bg2);color:var(--muted);font-size:12px;cursor:default;user-select:none}
      .notif-step.active{color:var(--lnk);border-color:rgba(96,165,250,.45);background:rgba(96,165,250,.10);font-weight:600}
      .notif-step.completed{cursor:pointer}
      .notif-step.completed:hover{border-color:var(--lnk);background:rgba(96,165,250,.05)}
      .notif-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
      @media (max-width: 720px){
        .notif-grid{grid-template-columns:1fr}
      }
      .notif-field{background:var(--bg2);padding:12px;border-radius:10px;border:1px solid var(--border)}
      .notif-field label{display:block;color:var(--heading);font-size:12px;margin-bottom:8px;font-weight:600}
      .notif-field input[type="text"], .notif-field input[type="email"], .notif-field textarea, .notif-field select{width:100%;padding:10px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--text)}
      .notif-field textarea{min-height:96px;resize:vertical}
      .notif-field .hint{margin-top:6px;color:var(--muted);font-size:11px;line-height:1.4}
      .notif-radioRow{display:flex;gap:8px;flex-wrap:wrap}
      .notif-radio{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:var(--panel);cursor:pointer;transition:all 0.15s ease}
      .notif-radio:hover{border-color:var(--lnk);background:rgba(96,165,250,.05)}
      .notif-radio input{accent-color:#60a5fa;cursor:pointer}
      .notif-inlineNote{color:var(--muted);font-size:12px}

      /* Conflict Management Styles */
      .conflict-item{border:1px solid var(--border);border-radius:12px;padding:20px;margin-bottom:16px;background:var(--panelGlass);backdrop-filter:saturate(160%) blur(6px)}
      .conflict-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px}
      .conflict-header h3{margin:0;color:var(--heading);font-size:16px}
      .conflict-status{color:var(--muted);font-size:14px}
      .conflict-options{display:flex;flex-direction:column;gap:15px}
      .conflict-configs{display:flex;flex-direction:column;gap:10px}
      .config-option{display:flex;align-items:center;padding:12px;border:2px solid var(--border);border-radius:8px;cursor:pointer;background:var(--appBgGlass);transition:all 0.2s;backdrop-filter:saturate(160%) blur(4px)}
      .config-option:hover{border-color:var(--lnk);transform:translateY(-1px)}
      .config-option.active{border-color:var(--ok);background:rgba(22,199,132,.08)}
      .config-option input[type="radio"]{margin-right:10px}
      .config-name{font-weight:500;flex:1;color:var(--heading)}
      .config-actions{display:flex;gap:8px;margin-left:auto}
      .conflict-actions{display:flex;gap:10px;justify-content:flex-end}
      .btn-small{padding:6px 12px;font-size:12px;border:1px solid var(--border);background:var(--btnBg);color:var(--btnText);border-radius:6px;cursor:pointer;transition:all 0.2s}
      .btn-small:hover{background:var(--btnBgHover);transform:translateY(-1px)}
      .btn-small:disabled{opacity:.45;cursor:not-allowed;transform:none}

      /* Config Modal Styles */
      .modal.large{max-width:1200px;width:min(1200px,96vw)}
      .config-modal{color:var(--text)}
      .config-actions{margin-bottom:15px;display:flex;gap:10px}
      .config-display{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:var(--codeBg);color:var(--codeText);max-height:500px;overflow:auto}
      .config-editor{width:100%;font-family:var(--mono, 'SF Mono', Consolas, monospace);font-size:13px;line-height:1.5;border:1px solid var(--codeBorder);border-radius:8px;padding:12px;background:#0d1424;color:#d9e2f1;resize:vertical;min-height:400px}
      .edit-actions{margin-top:15px;display:flex;gap:10px;justify-content:flex-end}

      /* Auto-Fix Suggestions Styles */
      .suggestion-item{border:1px solid var(--border);border-radius:8px;padding:16px;margin-bottom:12px;background:var(--appBgGlass);backdrop-filter:saturate(160%) blur(4px)}
      .suggestion-item h3{margin:0 0 8px 0;color:var(--ok);font-size:14px}
      .suggestion-item p{margin:0 0 8px 0;color:var(--text);font-size:13px}
      .suggestion-item code{display:block;background:var(--codeBg);color:var(--codeText);padding:8px;border-radius:4px;margin:8px 0;font-family:var(--mono, monospace);font-size:12px}
      .suggestion-item .btn{margin-top:8px;font-size:12px}

      /* Global Conflict Indicator */
      .global-conflict-indicator{position:fixed;top:20px;right:20px;z-index:1000;animation:slideIn 0.3s ease-out}
      .conflict-badge{background:rgba(245,158,11,.15);border:2px solid var(--warn);border-radius:8px;padding:12px 16px;color:var(--warn);font-weight:600;display:flex;align-items:center;gap:12px;backdrop-filter:saturate(160%) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.25)}
      .conflict-badge button{background:var(--warn);color:#000;border:none;padding:6px 12px;border-radius:4px;font-weight:600;cursor:pointer;font-size:12px}
      .conflict-badge button:hover{opacity:0.9;transform:translateY(-1px)}
      @keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}
      
      /* Healing Badge */
      .healing-badge{position:absolute;top:-12px;right:-12px;width:24px;height:24px;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);border-radius:50%;box-shadow:0 2px 5px rgba(0,0,0,.3);display:flex;align-items:center;justify-content:center;color:white;font-weight:bold;font-size:12px;cursor:pointer;transition:transform .2s ease;opacity:.85}
      .healing-badge:hover{opacity:1;transform:scale(1.15)}
      .healing-badge.active{animation:pulse 1.5s infinite}
      @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
      
      /* Healing History Panel */
      .healing-history{position:absolute;top:60px;right:48px;width:320px;background:var(--panelGlass);border:1px solid var(--border);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.4);backdrop-filter:saturate(160%) blur(6px);z-index:2010;padding:12px;display:none}
      .healing-history.visible{display:block}
      .healing-history h3{margin:0 0 10px 0;font-size:14px;display:flex;align-items:center;justify-content:space-between}
      .healing-history h3 button{background:none;border:none;cursor:pointer;font-size:16px;color:var(--muted);line-height:1}
      .healing-history-list{max-height:300px;overflow-y:auto}
      .healing-entry{margin-bottom:8px;padding:8px;border-radius:8px;background:rgba(125,162,255,.07);border:1px solid rgba(125,162,255,.15)}
      .healing-entry.success{border-color:rgba(22,199,132,.25);background:rgba(22,199,132,.07)}
      .healing-entry.failure{border-color:rgba(239,68,68,.25);background:rgba(239,68,68,.07)}
      .healing-entry-header{display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px}
      .healing-entry-issue{font-weight:bold}
      .healing-entry-timestamp{color:var(--muted);font-size:11px}
      .healing-entry-details{font-size:12px;margin-top:4px;word-break:break-word}
      .healing-entry-actions{display:flex;gap:8px;margin-top:6px}
      .healing-entry-actions button{font-size:11px;padding:3px 6px;border-radius:4px;cursor:pointer;border:1px solid var(--btnBorder);background:var(--btnBg);color:var(--btnText)}
      .healing-entry-actions button:hover{background:var(--btnBgHover)}
      
      /* Healing Status Indicator in AI header */
      .ai-healing-status{font-size:12px;padding:4px 8px;border-radius:999px;display:inline-flex !important;align-items:center;gap:6px;border:1px solid var(--btnBorder);font-weight:700}
      .ai-healing-status .pulse{display:none}
      .ai-healing-count{color:var(--muted);font-size:11px}
      :root{--ai-ready:#16c784;--ai-healing:#ff5bbd;--ai-audit:#8b5cf6;--ai-coding:#3b82f6;--ai-offline:#ef4444}
      @keyframes chipGlow{0%{box-shadow:0 0 0 0 rgba(255,255,255,.0)}50%{box-shadow:0 0 18px 2px rgba(255,255,255,.22)}100%{box-shadow:0 0 0 0 rgba(255,255,255,.0)}}
      .ai-healing-status.status-ready{background:rgba(22,199,132,.7);border-color:rgba(22,199,132,.85);color:#fff !important}
      .ai-healing-status.status-healing{background:#ff5bbd;border-color:#ff5bbd;color:#fff !important;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-auditing{background:#8b5cf6;border-color:#8b5cf6;color:#fff !important;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-coding{background:#3b82f6;border-color:#3b82f6;color:#fff !important;animation:chipGlow 1.6s ease-in-out infinite}
      .ai-healing-status.status-offline{background:#ef4444;border-color:#ef4444;color:#fff !important}

      /* Hierarchical Route Styles */
      .expandable-route{position:relative}
      .route-header{cursor:pointer;padding:8px;border-radius:6px;transition:background-color 0.2s;display:flex;align-items:center;justify-content:space-between;position:relative}
      .route-header:hover{background:rgba(255,255,255,.05)}
      .route-title{display:flex;align-items:center;gap:8px;font-weight:600}
      .expand-icon{transition:transform 0.2s;font-size:12px;width:12px}
      .route-chips-section{padding:8px;display:flex;flex-direction:column;gap:6px}
      .route-name{font-size:16px}
      .child-count{font-size:12px;color:var(--muted);font-weight:400}
      .route-children{margin-top:8px;margin-left:20px;border-left:2px solid var(--border);padding-left:16px}
      .route-children.hidden{display:none}
      .child-route{margin-bottom:8px;padding:8px;background:var(--appBgGlass);border-radius:6px;border-left:3px solid var(--border)}
      .child-route-name{font-size:14px;color:var(--muted)}
      .child-route-header{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:6px;transition:background-color 0.2s}
      .child-route-header:hover{background:rgba(255,255,255,.05)}
      .header-action-btn{background:none;border:none;color:var(--textSecondary);cursor:pointer;padding:4px 8px;border-radius:4px;transition:all 0.2s ease;font-size:14px}
      .header-action-btn:hover{background:rgba(255,255,255,.1);color:var(--text)}
      .route-header{display:flex;gap:6px;padding:8px;position:relative}
      .route-header:first-child{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
      .route-title{flex:1;display:flex;align-items:center;gap:8px}
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .chip.small{font-size:11px;padding:2px 6px;border-radius:10px}
      .chip.upstream-base{background:var(--chip);color:var(--muted);font-size:11px;font-weight:400}
      .chip.promoted-indicator{background:rgba(22,199,132,.2);border-color:rgba(22,199,132,.5);color:#16c784;font-size:10px;font-weight:700;margin-left:8px;padding:2px 6px}
      .btn-small{padding:4px 8px;font-size:11px;min-height:24px}
      .route-header .chips{display:flex;flex-wrap:wrap;gap:4px;align-items:center}
      .parent-status .chip{margin-right:4px}
      .child-summary{margin-top:2px}
      .child-summary .chip{background:var(--btnBg);border-color:var(--btnBorder);font-size:10px;padding:1px 4px}
      .route-controls{margin-top:4px}
      .route-controls .btn{margin-right:6px}
      .route-actions{position:absolute;top:8px;right:8px;display:flex;gap:6px;flex-wrap:wrap;z-index:10}
      .route-actions .btn{margin-right:6px;min-width:60px}
      /* Action buttons container */
      .action-buttons-container{display:flex;gap:6px;align-items:center;z-index:10}
      
      /* Universal circular button style */
      .circular-action-btn{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border:1.5px solid var(--btnBorder);background:white;color:var(--btnText);border-radius:999px;font-size:14px;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05);transition:background 0.2s ease}
      .circular-action-btn:hover{background:#f0f0f0}
      .circular-action-btn svg{width:18px;height:18px;display:block}
      .circular-action-btn img{width:16px;height:16px;display:block}
      
      /* Legacy styles for compatibility */
      .icon-actions{position:absolute;top:8px;right:42px;display:flex;gap:8px;align-items:center}
      .icon-actions .icon-btn{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border:1.5px solid var(--btnBorder);background:white;color:var(--btnText);border-radius:999px;font-size:14px;line-height:1;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.05);transition:background 0.2s ease}
      .icon-actions .icon-btn:hover{background:#f0f0f0}
      .icon-actions .icon-btn svg{width:18px;height:18px;display:block}
      .root-actions{position:absolute;top:8px;right:8px;display:flex;gap:8px;align-items:center}

      /* Hover scroll helpers */
      .hover-scroll{overflow:auto}

      /* AI Drawer */
      :root{--aiWidth:clamp(360px, 32vw, 512px)}
      .ai-drawer{position:fixed;right:0;height:calc(88vh - (var(--headerH, 64px) + var(--summaryH, 0px)));width:var(--aiWidth);padding:8px 8px;z-index:2005;background:var(--panelGlass);border-left:1px solid var(--border);border-radius:12px 0 0 12px;box-shadow:-8px 0 24px rgba(0,0,0,.35);backdrop-filter:saturate(160%) blur(8px);display:flex;flex-direction:column;transition:transform .18s ease}
      .ai-drawer.collapsed{transform:translateX(calc(100% + 16px));border-left:none;box-shadow:none}
      .ai-drawer.collapsed .ai-header,.ai-drawer.collapsed .ai-content{opacity:0;pointer-events:none}
      /* Bottom-sheet mode for small screens */
      .ai-drawer.bottom-sheet{left:0;right:0;bottom:0;top:auto;width:auto;height:min(33vh, 420px);border-left:none;border-top:1px solid var(--border);border-radius:12px 12px 0 0;box-shadow:0 -8px 24px rgba(0,0,0,.35)}
      .ai-drawer.bottom-sheet.collapsed{transform:translateY(100%)}
      .ai-tab{position:absolute;left:-36px;top:15%;transform:translateY(-50%);background:var(--btnBg);border:1px solid var(--btnBorder);border-right:none;border-radius:10px 0 0 10px;color:var(--btnText);padding:12px 8px;font-size:13px;font-weight:700;cursor:pointer;box-shadow:-6px 6px 18px rgba(0,0,0,.25);display:flex;flex-direction:column;align-items:center;gap:8px}
      .ai-tab .icon-steth{display:flex;align-items:center;justify-content:center}
      .ai-tab .icon-steth img{width:20px;height:20px;display:block;transform: rotate(270deg);}
      .ai-tab .label{letter-spacing:.3px;writing-mode:vertical-rl;text-orientation:mixed;transform: rotate(180deg);}
      .ai-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border)}
      .ai-header h2{margin:0;font-size:14px;color:var(--heading)}
      .ai-meta{display:flex;gap:12px;font-size:12px;color:var(--muted);flex-wrap:wrap}
      .ai-content{display:flex;flex-direction:column;padding:10px 12px;gap:10px;height:100%;}
      .ai-row{display:flex;gap:8px;align-items:center}
      .ai-chat{flex:1;min-height:120px;border:1px solid var(--codeBorder);border-radius:10px;background:var(--codeBg);padding:10px;overflow:auto}
      .bubble{max-width:85%;padding:8px 12px;border-radius:14px;margin:12px 0;line-height:1.45}
      .bubble.user{margin-left:auto;background:rgba(125,162,255,.22);border:1px solid rgba(125,162,255,.35)}
      .bubble.assistant{margin-right:auto;background:linear-gradient(180deg, rgba(255,143,211,.12), rgba(255,91,189,.10));border:1px solid rgba(255,143,211,.45)}
      /* Gentle bubble entrance */
      @keyframes bubbleIn{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}
      .bubble{animation:bubbleIn .18s ease-out}
      .bubble-title{font-size:11px;font-weight:600;color:var(--muted);margin-bottom:6px;padding-bottom:4px;border-bottom:1px solid rgba(255,255,255,.1)}
      .bubble-content{margin-top:0; overflow-wrap:anywhere; word-break:break-word}
      .bubble-content pre{white-space:pre-wrap; word-break:break-word}
      .bubble-content a{word-break:break-all}
      .ai-healing-history{display:flex;align-items:center;gap:4px;font-size:12px;color:var(--muted);background:rgba(125,162,255,.1);border:1px solid rgba(125,162,255,.3);padding:2px 8px;border-radius:12px;cursor:pointer;transition:all 0.2s ease}
      .ai-healing-history:hover{background:rgba(125,162,255,.2);border-color:rgba(125,162,255,.5)}
      .bubble p{margin:.4em 0}
      .bubble ul,.bubble ol{margin:.35em 0 .35em .9em}
      .bubble ul ul,.bubble ol ol{margin-left:.9em}
      .bubble li{margin:.25em 0}
      .bubble pre{margin:.5em 0;background:var(--codeBg);border:1px solid var(--codeBorder);padding:10px;border-radius:10px;overflow:auto}
      .bubble code{background:rgba(125,162,255,.15);border:1px solid rgba(125,162,255,.25);padding:0 4px;border-radius:4px}
      .ai-input{display:flex;flex-direction:column;gap:8px}
      .ai-input textarea{resize:vertical;min-height:44px;max-height:160px;font-family:var(--font-body);border:1px solid var(--codeBorder);border-radius:10px;background:var(--codeBg);color:var(--text);caret-color:var(--text)}
      .ai-input textarea::placeholder{font-family:var(--font-body);color:var(--muted)}
      .ai-input textarea:focus{outline:none;border-color:var(--lnk);box-shadow:0 0 0 2px rgba(125,176,255,.25)}
      .ai-actions{display:flex;gap:8px;justify-content:flex-end;position:sticky;bottom:0;padding-top:8px;border-top:1px solid var(--border)}
      /* Thinking indicator */
      .bubble.thinking{background:transparent;border:1px dashed var(--btnBorder);opacity:.85}
      .dots{display:inline-flex;gap:4px;vertical-align:middle}
      .dot{width:6px;height:6px;border-radius:50%;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);opacity:.6;animation:dotPulse 1s infinite ease-in-out}
      /* Inline chat status at top of chat */
      .ai-chat-status{position:sticky;top:0;z-index:1;display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted);background:linear-gradient(180deg, rgba(0,0,0,.15), transparent);padding:6px 4px;margin-bottom:4px}
      .ai-chat-status .pulse{width:6px;height:6px;border-radius:50%;background:linear-gradient(180deg,#ff8fd3,#ff5bbd);animation:dotPulse 1s infinite ease-in-out}
      .dot:nth-child(2){animation-delay:.15s}
      .dot:nth-child(3){animation-delay:.3s}
      @keyframes dotPulse{0%,80%,100%{transform:scale(.6);opacity:.4}40%{transform:scale(1);opacity:1}}

      /* Mobile: bottom drawer behavior + compact headers */
      @media (max-width: 768px){
        .ai-drawer{left:12px;right:12px;top:auto;bottom:12px;width:auto;height:min(50vh, calc(100vh - (var(--headerH, 64px) + 24px)));border-radius:12px}
        .ai-drawer.collapsed{transform:translateY(calc(100% - 28px));border-left:1px solid var(--border)}
        .ai-tab{left:50%;top:auto;bottom:-28px;transform:translate(-50%, 0);border-right:1px solid var(--btnBorder);border-left:1px solid var(--btnBorder)}
        .summaryRow h2{display:none}
        .appsHeader h2{display:none}
        .appsHeader .toolbar{width:100%}
        /* Keep buttons visible and reduce chat height on small screens */
        .ai-content{overflow:hidden}
        .ai-chat{flex:none;max-height:38vh}
      }

      /* Layout container centering */
      .content{max-width:1280px;margin:0 auto;padding:0 16px}
      @media (max-width: 768px){
        #aiDrawer.ai-drawer{position:fixed;left:0;right:0;bottom:0;top:auto;width:auto;height:min(33vh, 420px)}
        #aiDrawer.ai-drawer.collapsed{transform:translateY(100%)}
      }

      @media (min-width:1400px){
        .apps{grid-template-columns:repeat(3, 1fr)}
      }
      @media (min-width:900px) and (max-width:1399px){
        .apps{grid-template-columns:repeat(2, 1fr) !important}
      }
      @media (max-width:899px){
        .grid{grid-template-columns:1fr}
        .apps{grid-template-columns:1fr !important}
        .container{padding:0 8px}
        .content{padding:0 8px}
        .app{margin:0;max-width:100%}
        .header-row{flex-wrap:wrap;gap:8px}
        .header-actions{gap:6px}
        .ai-drawer{height: calc(78vh - (var(--headerH, 64px) + var(--summaryH, 0px)));}
        /* On medium screens, keep input/actions in view by limiting chat height */
        .ai-content{overflow:hidden}
        .ai-chat{flex:none;max-height:48vh}
      }
      /* reserved for legacy global diagnose button (removed) */
      #aiDiagnoseGlobal{display:none}
      @media (max-width:768px){
        .conflict-options{gap:10px}
        .config-option{flex-direction:column;align-items:flex-start;gap:10px}
        .config-actions{margin-left:0}
        .conflict-actions{flex-direction:column}
        .suggestion-item{padding:12px}
        .toolbar{gap:6px}
        .toolbar .field{width:100%}
        .toolbar select,.toolbar input[type="text"]{width:100%}
        .route-header{padding:6px}
        .child-route{padding:6px}
      }
      /* Header nav + actions grouping */
      .header-actions{display:flex;align-items:center;gap:8px}
      .header-actions .tab{background:var(--btnBg);}
      .header-actions .tab.active{background:#1a2a4b;border-color:#36568c}
      .header-actions .action{background:#0f2242;border-color:#2a4a7e}
      :root[data-theme="light"] .header-actions .action{background:#eef2ff;border-color:#bfd1ff;color:#0b1220}
      .header-actions .divider{display:inline-block;width:10px;height:28px;margin:0 6px;border-left:1px solid var(--border)}
      header h1 .brand{font-weight:700;color:var(--heading);background:transparent;padding:0;border-radius:0}
      :root[data-theme="light"] .header-actions .tab.active{background:#d9e2ff;border-color:#bfd1ff;color:#0b1220}
      :root:not([data-theme="light"]) .header-actions .tab.active{background:#1a2a4b;border-color:#36568c;color:#cfe0ff}
      /* Remove page-specific header overrides; rely on shared common.css */
    </style>
    <link rel="stylesheet" href="/status/common.css" />
    <script src="/status/config.js"></script>
    <script src="/status/common.js"></script>
  </head>
  <body data-page="status">
    <script>window.addEventListener('DOMContentLoaded', function(){ try{ window.DTP && DTP.attachHeader && DTP.attachHeader('status'); }catch{} try{ window.DTP && DTP.initTheme && DTP.initTheme(); }catch{} });</script>
    <header>
      <div class="header-row">
        <h1>
          <img src="/status/assets/logo.svg" alt="Dev Tunnel Proxy logo" style="height:40px;vertical-align:middle;margin-right:10px"/>
          <span class="brand">Dev Tunnel Proxy</span>
        </h1>
        <div class="header-actions">
          <a class="btn tab active" href="/status">Status</a>
          <a class="btn tab" href="/health">Health</a>
          <a class="btn tab" href="/reports">Reports</a>
          <a class="btn tab" href="/dashboard/">Dashboard</a>
          <span class="divider" aria-hidden="true"></span>
          <button class="btn action" id="reloadConfigs" title="Reload all configurations and rescan apps">üîÑ</button>
          <button class="btn action" id="themeToggle" title="Toggle theme" aria-label="Toggle theme">üåô</button>
          <button class="btn action" id="calliopeOpen" title="Toggle Calliope" aria-label="Toggle Calliope" aria-pressed="false">
            <img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;vertical-align:middle;">
          </button>
        </div>
      </div>
      
    </header>
    <div class="content">
      <div class="container">
        <div class="card overviewCard">
          <div class="summaryChips" id="summaryChips"></div>
        </div>
        
        <!-- Notifications Service Card (macOS only) -->
        <div class="card" id="notificationsCard" style="display: none;">
          <h2 style="margin:0">Notifications Service</h2>
          <div style="margin-top: 12px;">
            <div id="notificationsServiceStatus" style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
              <span id="notificationsServiceText" style="flex: 1; min-width: 200px;">Checking...</span>
              <div style="display: flex; gap: 8px;">
                <div class="chip" id="notificationsServiceChip" style="cursor: pointer; user-select: none;">
                  <span>Loading...</span>
                </div>
                <div class="chip" id="notificationsLogsChip" style="cursor: pointer; user-select: none; display: none;">
                  <span>üìã Logs</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="ai-drawer collapsed" id="aiDrawer">
          <!-- Healing History Panel -->
          <div class="healing-history" id="healingHistory">
            <h3>
              Self-Healing History
              <button class="close-history">&times;</button>
            </h3>
            <div class="healing-history-list" id="healingHistoryList">
              <!-- Healing entries will be populated here -->
              <div class="empty-history">No healing actions recorded yet.</div>
            </div>
          </div>
          <div class="ai-header">
            <h2>
              <span class="icon-steth-header" aria-hidden="true">
                <img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope Stethoscope" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;">
              </span>
              Calliope
            </h2>
            <div class="ai-meta">
              <span class="ai-healing-history" id="aiHealingHistory">
                <span class="ai-healing-history-label">Healing History</span>
              </span>
              <span class="ai-healing-status" id="aiHealingStatus">
                <span class="pulse"></span>
                <span class="ai-healing-status-label" id="aiHealingStatusLabel">Healing</span>
                <span class="ai-healing-count" style="display:none" id="aiHealingCount"></span>
              </span>
            </div>
          </div>
          <div class="ai-content">
            <div id="aiChat" class="ai-chat hover-scroll"></div>
            <div class="ai-input">
              <textarea id="aiQuery" class="hover-scroll" rows="3" placeholder="Ask about proxy/network issues" style="padding: 12px;"></textarea>
              <div class="ai-actions">
                <button class="btn" id="aiCopyBtn" title="Copy conversation to clipboard">Copy</button>
                <button class="btn" id="aiClearBtn" title="Clear conversation">Clear</button>
                <button class="btn" id="aiAskBtn">Ask</button>
                <button class="btn" id="aiHealBtn" data-role="selfcheck" title="Self-Check" aria-label="Self-Check">Self‚ÄëCheck</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card" id="appsCard">
          <h2 style="margin:0">Configured Apps</h2>

          <div class="card hidden" id="conflictCard" data-dismissible="true">
            <h2>‚ö†Ô∏è Route Conflicts</h2>
            <p>Multiple configuration files are declaring the same routes. Choose which config should win:</p>
            <div id="conflicts">Loading conflicts...</div>
          </div>
    
            <div class="card appsHeader">
            <div class="toolbar">
              <div class="field">
                <label class="label">Group By</label>
                <select id="groupByMode">
                  <option value="none">None</option>
                  <option value="config">Config File</option>
                </select>
              </div>
              <div class="field">
                <label class="label">Sort</label>
                <select id="sortMode">
                  <option value="alpha">A‚ÄìZ</option>
                  <option value="status">By status</option>
                  <option value="depth">By depth</option>
                </select>
              </div>
              <div class="field">
                <label class="label">Filter</label>
                <input id="routeFilter" type="text" placeholder="/api, ok, warn, err, 200, ngrok:200" />
              </div>
            </div>
          </div>
          <div class="apps" id="apps">Loading‚Ä¶</div>
        </div>

      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script>
      // Debug logging setup (must be defined before any function uses it)
      const DEBUG = (function(){
        try{
          const qs = new URLSearchParams(location.search);
          if ((qs.get('debug')||'').toString() === '1') return true;
          const v = localStorage.getItem('calliope_debug');
          return v === '1' || v === 'true';
        }catch{}
        return false;
      })();
      const logDebug = (...args)=>{ try{ if (DEBUG) console.debug(...args); }catch{} };
      const logInfo = (...args)=>{ try{ console.info(...args); }catch{} };
      const logWarn = (...args)=>{ try{ console.warn(...args); }catch{} };
      const logError = (...args)=>{ try{ console.error(...args); }catch{} };

      function initTheme(){
        const stored = localStorage.getItem('dtpTheme');
        // Default to dark if nothing stored
        const theme = stored || 'dark';
        document.documentElement.setAttribute('data-theme', theme==='light'?'light':'dark');
        const tbtn = document.getElementById('themeToggle') || document.getElementById('themeToggleFallback');
        tbtn.textContent = theme==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', theme==='light'?'Switch to dark':'Switch to light');
      }
      function measureStickyHeights(){
        const headerEl = document.querySelector('header');
        const summaryEl = document.querySelector('.summaryRow');
        const headerH = headerEl ? headerEl.getBoundingClientRect().height : 64;
        const summaryH = summaryEl ? summaryEl.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--headerH', headerH + 'px');
        document.documentElement.style.setProperty('--summaryH', summaryH + 'px');
      }
      function toggleTheme(){
        const cur = document.documentElement.getAttribute('data-theme')==='light'?'light':'dark';
        const next = cur==='light'?'dark':'light';
        document.documentElement.setAttribute('data-theme', next);
        localStorage.setItem('dtpTheme', next);
        const tbtn = document.getElementById('themeToggle') || document.getElementById('themeToggleFallback');
        tbtn.textContent = next==='light' ? 'üåô' : '‚òÄÔ∏è';
        tbtn.setAttribute('title', next==='light'?'Switch to dark':'Switch to light');
      }
      // Make logo/title clickable for branding
      (function enableHomeClicks(){
        const brand=document.querySelector('header h1');
        if (brand){ brand.style.cursor='pointer'; brand.addEventListener('click',()=>{ location.reload(); }); }
      })();
      window.addEventListener('load', measureStickyHeights);
      window.addEventListener('resize', measureStickyHeights);

      function chip(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }
      function chipEl(label, cls, tip){
        const s = document.createElement('span');
        s.className = 'chip '+(cls||'');
        s.textContent = label;
        if (tip) s.setAttribute('data-tip', tip);
        return s;
      }

      // Choose best URL to open (ALWAYS use ngrok URL + route)
      function chooseOpenUrl(routes, targets, routeKey){
        // ALWAYS use the global ngrok URL if available
        if (globalNgrokUrl && globalNgrokUrl !== 'not discovered') {
          // Ensure route starts with / and ngrok URL doesn't end with /
          const cleanRoute = routeKey.startsWith('/') ? routeKey : '/' + routeKey;
          const cleanNgrok = globalNgrokUrl.replace(/\/$/, '');
          return cleanNgrok + cleanRoute;
        }
        
        // Fallback to old logic if no global ngrok URL
        const pref = ['ngrok', 'local-proxy'];
        
        // First pass: try to find a successful response (2xx or 3xx for ngrok, only 2xx for localhost)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) {
            if (t === 'ngrok' && info.status >= 200 && info.status < 400) {
              return info.url;
            } else if (t === 'local-proxy' && info.status >= 200 && info.status < 300) {
              return info.url;
            }
          }
        }
        
        // Second pass: return ngrok URL even if not successful (better than localhost error)
        for (const t of pref){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (info && info.url) return info.url;
        }
        
        return null;
      }

      async function loadJSON(url){
        const res = await fetch(url, { headers: { 'ngrok-skip-browser-warning':'true' } });
        if(!res.ok) throw new Error('HTTP '+res.status);
        return res.json();
      }

      let routesData = null;
      let preferences = null;
      let promotedRoots = null; // { [baseKey]: '/api/' }
      let globalNgrokUrl = null; // Store the global ngrok URL for Open buttons

      function loadPrefs(){
        try{ return JSON.parse(localStorage.getItem('statusPrefs')||'{}'); }catch{ return {}; }
      }
      function savePrefs(p){ localStorage.setItem('statusPrefs', JSON.stringify(p||{})); }
      function loadPromotions(){
        try{ return JSON.parse(localStorage.getItem('routePromotions')||'{}'); }catch{ return {}; }
      }
      function savePromotions(p){ localStorage.setItem('routePromotions', JSON.stringify(p||{})); }
      
      function togglePromotion(route, configFile) {
        const promotions = loadPromotions();
        if (!promotions[configFile]) promotions[configFile] = {};
        
        if (promotions[configFile][route]) {
          // Demote: remove from promotions
          delete promotions[configFile][route];
          // Clean up empty config entries
          if (Object.keys(promotions[configFile]).length === 0) {
            delete promotions[configFile];
          }
        } else {
          // Promote: add to promotions
          promotions[configFile][route] = true;
        }
        
        savePromotions(promotions);
        rebuildApps(); // Refresh the UI
      }

      // -------------------------------
      // Notifications (per-route)
      // -------------------------------
      const NOTIF_STORE_LOCAL_KEY = 'routeNotificationsV1';
      const NOTIF_BRIDGE_BASE = 'http://127.0.0.1:17888';
      const NOTIF_TEST_ENDPOINT = `${NOTIF_BRIDGE_BASE}/test`;
      const NOTIF_SERVICE_STATUS_ENDPOINT = `${NOTIF_BRIDGE_BASE}/service/status`;
      const NOTIF_SERVICE_INSTALL_ENDPOINT = `${NOTIF_BRIDGE_BASE}/service/install`;
      const NOTIF_SERVICE_UNINSTALL_ENDPOINT = `${NOTIF_BRIDGE_BASE}/service/uninstall`;
      const NOTIF_STORE_API_PATH = 'notifications'; // GET/POST (best-effort; UI falls back to localStorage)

      // Modal Dialog System (replaces browser alert/confirm)
      function showDialog(options) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'overlay';
          overlay.style.zIndex = '9999';
          
          const dialog = document.createElement('div');
          dialog.className = 'modal';
          dialog.style.cssText = 'max-width: 500px; z-index: 10000;';
          
          const title = document.createElement('h2');
          title.textContent = options.title || 'Notification';
          title.style.marginBottom = '16px';
          dialog.appendChild(title);
          
          const message = document.createElement('div');
          message.style.cssText = 'margin-bottom: 20px; line-height: 1.5; white-space: pre-wrap;';
          message.textContent = options.message || '';
          dialog.appendChild(message);
          
          const toolbar = document.createElement('div');
          toolbar.className = 'toolbar';
          toolbar.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end;';
          
          if (options.type === 'confirm') {
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = options.cancelText || 'Cancel';
            cancelBtn.style.background = 'var(--btnBg)';
            cancelBtn.onclick = () => {
              overlay.remove();
              resolve(false);
            };
            toolbar.appendChild(cancelBtn);
          }
          
          const okBtn = document.createElement('button');
          okBtn.className = 'btn';
          okBtn.textContent = options.okText || 'OK';
          okBtn.onclick = () => {
            overlay.remove();
            resolve(true);
          };
          toolbar.appendChild(okBtn);
          
          dialog.appendChild(toolbar);
          overlay.appendChild(dialog);
          document.body.appendChild(overlay);
          
          // Focus OK button
          okBtn.focus();
          
          // ESC to close
          const handleEsc = (e) => {
            if (e.key === 'Escape') {
              overlay.remove();
              resolve(false);
              document.removeEventListener('keydown', handleEsc);
            }
          };
          document.addEventListener('keydown', handleEsc);
        });
      }

      function notifKeyForRoute(route, source) {
        return `${source || 'unknown'}::${route || ''}`;
      }

      function loadNotificationsStoreLocal(){
        try { return JSON.parse(localStorage.getItem(NOTIF_STORE_LOCAL_KEY) || '{}'); } catch { return {}; }
      }
      function saveNotificationsStoreLocal(store){
        localStorage.setItem(NOTIF_STORE_LOCAL_KEY, JSON.stringify(store || {}));
      }
      function apiPathForNotifications(){
        try {
          if (window.DTP && window.DTP.config && typeof window.DTP.config.apiPath === 'function') {
            return window.DTP.config.apiPath(NOTIF_STORE_API_PATH);
          }
        } catch {}
        return `/devproxy/api/${NOTIF_STORE_API_PATH}`;
      }
      async function loadNotificationsStore(){
        // Prefer API if present, fall back to local storage
        const url = apiPathForNotifications();
        try {
          const res = await fetch(url, { headers: { 'ngrok-skip-browser-warning':'true' } });
          if (res.ok) {
            const json = await res.json();
            // Cache locally as well (makes the UI resilient when API is offline)
            saveNotificationsStoreLocal(json);
            return json;
          }
        } catch {}
        return loadNotificationsStoreLocal();
      }
      async function saveNotificationsStore(store){
        // Always persist locally first
        saveNotificationsStoreLocal(store);
        const url = apiPathForNotifications();
        try {
          await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'ngrok-skip-browser-warning':'true'
            },
            body: JSON.stringify(store || {})
          });
        } catch {}
      }

      function makeNotifId(){
        try { return `n_${crypto.randomUUID()}`; } catch { return `n_${Date.now()}_${Math.random().toString(16).slice(2)}`; }
      }
      function splitRecipients(raw){
        return (raw||'')
          .split(/[,\n\t ]+/)
          .map(s=>s.trim())
          .filter(Boolean);
      }
      function joinRecipients(list){
        return (list||[]).join(', ');
      }
      function guessContainerFromUpstream(up){
        const host = extractHostname(up || '');
        if (!host || host.startsWith('$')) return '';
        return host;
      }
      function listKnownContainersFromRoutes(){
        const names = new Set();
        const md = routesData?.metadata || {};
        for (const r of Object.keys(md)) {
          const up = md[r]?.upstream || '';
          const host = extractHostname(up);
          if (!host) continue;
          if (host.startsWith('$')) continue;
          names.add(host);
        }
        return Array.from(names).sort((a,b)=>a.localeCompare(b));
      }
      function defaultMessageFor({ route, proxyExternallyAccessible, containerState }){
        const proxyLabel = proxyExternallyAccessible ? 'externally accessible' : 'local-only';
        const st = (containerState || 'running').toLowerCase();
        const subject = `Dev Tunnel Proxy: ${route} is ${st} (${proxyLabel})`;
        const body = [
          `Route: ${route}`,
          `Proxy: ${proxyLabel}`,
          `Status: ${st}`,
        ].join('\n');
        return { subject, body };
      }

      // -------------------------------
      // Notifications Service Card (Main Page)
      // -------------------------------
      async function checkServiceStatus() {
        try {
          const resp = await fetch(NOTIF_SERVICE_STATUS_ENDPOINT);
          if (!resp.ok) return null;
          const data = await resp.json();
          return data;
        } catch {
          return null;
        }
      }

      async function installService() {
        try {
          const resp = await fetch(NOTIF_SERVICE_INSTALL_ENDPOINT, { method: 'POST' });
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data?.error || `HTTP ${resp.status}`);
          }
          return data;
        } catch (e) {
          throw new Error(`Failed to install service: ${e?.message || e}`);
        }
      }

      async function uninstallService() {
        try {
          const resp = await fetch(NOTIF_SERVICE_UNINSTALL_ENDPOINT, { method: 'POST' });
          const data = await resp.json();
          if (!resp.ok) {
            throw new Error(data?.error || `HTTP ${resp.status}`);
          }
          return data;
        } catch (e) {
          throw new Error(`Failed to uninstall service: ${e?.message || e}`);
        }
      }

      function isMacOS() {
        return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      }

      async function initNotificationsServiceCard() {
        const card = document.getElementById('notificationsCard');
        const statusText = document.getElementById('notificationsServiceText');
        const serviceChip = document.getElementById('notificationsServiceChip');
        const logsChip = document.getElementById('notificationsLogsChip');

        // Only show on macOS
        if (!isMacOS()) {
          card.style.display = 'none';
          return;
        }

        card.style.display = 'block';

        // Check service status
        const status = await checkServiceStatus();
        
        if (!status) {
          statusText.innerHTML = '‚ö†Ô∏è Bridge not running. Start: <code style="background: var(--codeBg, #f5f5f5); padding: 2px 6px; border-radius: 4px; font-size: 11px;">node macos/notifications-bridge.js</code>';
          serviceChip.style.display = 'none';
          logsChip.style.display = 'none';
          return;
        }

        // Update UI based on status
        if (status.installed && status.running) {
          statusText.innerHTML = '‚úÖ <strong>Running</strong> as background service';
          serviceChip.innerHTML = '<span>Uninstall</span>';
          serviceChip.className = 'chip warn';
          logsChip.style.display = 'flex';
          
          serviceChip.onclick = async () => {
            const confirmed = await showDialog({
              type: 'confirm',
              title: 'Uninstall Background Service',
              message: 'Stop and uninstall the notifications engine background service?',
              okText: 'Uninstall',
              cancelText: 'Cancel'
            });
            if (!confirmed) return;
            
            serviceChip.innerHTML = '<span>Uninstalling...</span>';
            serviceChip.style.pointerEvents = 'none';
            
            try {
              await uninstallService();
              await showDialog({
                title: '‚úÖ Service Uninstalled',
                message: 'Background service uninstalled successfully.'
              });
              initNotificationsServiceCard(); // Refresh
            } catch (e) {
              await showDialog({
                title: '‚ùå Uninstall Failed',
                message: e.message
              });
              serviceChip.innerHTML = '<span>Uninstall</span>';
              serviceChip.style.pointerEvents = 'auto';
            }
          };
        } else {
          statusText.innerHTML = '‚≠ï Not installed as background service';
          serviceChip.innerHTML = '<span>Install</span>';
          serviceChip.className = 'chip ok';
          logsChip.style.display = 'none';
          
          serviceChip.onclick = async () => {
            const confirmed = await showDialog({
              type: 'confirm',
              title: 'Install Background Service',
              message: 'Install the notifications engine as a background service (LaunchAgent)?\n\nIt will automatically start on login and monitor your notification rules.',
              okText: 'Install',
              cancelText: 'Cancel'
            });
            if (!confirmed) return;
            
            serviceChip.innerHTML = '<span>Installing...</span>';
            serviceChip.style.pointerEvents = 'none';
            
            try {
              await installService();
              await showDialog({
                title: '‚úÖ Service Installed',
                message: 'Background service installed and started successfully!\n\nLogs: ./.artifacts/notifications-engine.log'
              });
              initNotificationsServiceCard(); // Refresh
            } catch (e) {
              await showDialog({
                title: '‚ùå Install Failed',
                message: e.message
              });
              serviceChip.innerHTML = '<span>Install</span>';
              serviceChip.style.pointerEvents = 'auto';
            }
          };
        }

        // Logs chip handler
        if (status.logPath) {
          logsChip.onclick = async () => {
            await showLogsModal(status.logPath, status.errPath);
          };
        }
      }

      async function showLogsModal(logPath, errPath) {
        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        overlay.style.zIndex = '9999';
        
        const modal = document.createElement('div');
        modal.className = 'modal large';
        modal.style.cssText = 'max-width: min(900px, 90vw); max-height: 85vh; display: flex; flex-direction: column;';
        
        const title = document.createElement('h2');
        title.textContent = 'üìã Notifications Engine Logs';
        title.style.marginBottom = '16px';
        modal.appendChild(title);
        
        const info = document.createElement('div');
        info.style.cssText = 'margin-bottom: 16px; padding: 16px; background: var(--codeBg); border-radius: 8px; line-height: 1.6;';
        info.innerHTML = `
          <div style="margin-bottom: 12px;"><strong>Log Files:</strong></div>
          <div style="margin-bottom: 8px;">
            <strong>Output:</strong><br>
            <code style="background: var(--cardBg); padding: 4px 8px; border-radius: 4px; display: inline-block; margin-top: 4px; font-size: 11px;">${logPath}</code>
          </div>
          <div>
            <strong>Errors:</strong><br>
            <code style="background: var(--cardBg); padding: 4px 8px; border-radius: 4px; display: inline-block; margin-top: 4px; font-size: 11px;">${errPath}</code>
          </div>
        `;
        modal.appendChild(info);
        
        const commands = document.createElement('div');
        commands.style.cssText = 'margin-bottom: 16px; padding: 16px; background: var(--cardBg); border-radius: 8px;';
        commands.innerHTML = `
          <div style="margin-bottom: 12px;"><strong>View in Terminal:</strong></div>
          <div style="margin-bottom: 8px;">
            <div style="font-size: 12px; margin-bottom: 4px;">Follow output log:</div>
            <code style="background: var(--codeBg); padding: 8px; border-radius: 4px; display: block; font-size: 11px; overflow-x: auto;">tail -f ${logPath}</code>
          </div>
          <div style="margin-bottom: 8px;">
            <div style="font-size: 12px; margin-bottom: 4px;">Follow error log:</div>
            <code style="background: var(--codeBg); padding: 8px; border-radius: 4px; display: block; font-size: 11px; overflow-x: auto;">tail -f ${errPath}</code>
          </div>
          <div>
            <div style="font-size: 12px; margin-bottom: 4px;">View last 50 lines:</div>
            <code style="background: var(--codeBg); padding: 8px; border-radius: 4px; display: block; font-size: 11px; overflow-x: auto;">tail -50 ${logPath}</code>
          </div>
        `;
        modal.appendChild(commands);
        
        const toolbar = document.createElement('div');
        toolbar.className = 'toolbar';
        toolbar.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end; margin-top: auto;';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn';
        closeBtn.textContent = 'Close';
        closeBtn.onclick = () => overlay.remove();
        toolbar.appendChild(closeBtn);
        
        modal.appendChild(toolbar);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // ESC to close
        const handleEsc = (e) => {
          if (e.key === 'Escape') {
            overlay.remove();
            document.removeEventListener('keydown', handleEsc);
          }
        };
        document.addEventListener('keydown', handleEsc);
        
        closeBtn.focus();
      }

      async function openNotificationsModal(ctx){
        const route = ctx?.route;
        const source = ctx?.source || ctx?.meta?.sourceFile || 'unknown';
        const upstream = ctx?.meta?.upstream || routesData?.metadata?.[route]?.upstream || '';
        const routeKey = notifKeyForRoute(route, source);

        const store = await loadNotificationsStore();
        if (!store.routes) store.routes = {};
        if (!store.routes[routeKey]) {
          store.routes[routeKey] = { route, source, notifications: [] };
          await saveNotificationsStore(store);
        }

        const backdrop = document.createElement('div');
        backdrop.className = 'backdrop';

        const modal = document.createElement('div');
        modal.className = 'modal';

        // Close on backdrop click
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) backdrop.remove();
        });

        let view = { mode: 'list', editingId: null, step: 0, draft: null };

        function getRouteNotifications(){
          const arr = store.routes?.[routeKey]?.notifications || [];
          return Array.isArray(arr) ? arr : [];
        }
        function setRouteNotifications(arr){
          store.routes[routeKey].notifications = arr;
        }

        function upsertNotification(notif){
          const all = getRouteNotifications();
          const idx = all.findIndex(n => n.id === notif.id);
          if (idx >= 0) all[idx] = notif;
          else all.push(notif);
          setRouteNotifications(all);
        }

        function removeNotification(id){
          const all = getRouteNotifications().filter(n => n.id !== id);
          setRouteNotifications(all);
        }

        function summarize(n){
          const p = n?.conditions?.proxyExternallyAccessible ? 'Proxy: external' : 'Proxy: local-only';
          const s = (n?.conditions?.containerState || 'running').toLowerCase();
          const act = (n?.action?.type || 'text').toLowerCase();
          const rec = (n?.action?.recipients || []);
          const recStr = Array.isArray(rec) ? joinRecipients(rec) : (rec || '');
          return {
            line1: `Status: ${s}`,
            line2: `${p} ‚Ä¢ ${act.toUpperCase()} ‚Üí ${recStr || 'recipient(s)'}`
          };
        }

        async function sendTestNotification(n){
          const actType = (n?.action?.type || 'text').toLowerCase();
          if (actType !== 'text') {
            await showDialog({
              title: 'Test Not Available',
              message: 'Only Text notifications can be tested right now.'
            });
            return;
          }

          const rec = n?.action?.recipients || [];
          const recipients = Array.isArray(rec)
            ? rec.map(r => String(r).trim()).filter(Boolean)
            : String(rec).split(',').map(r => r.trim()).filter(Boolean);

          if (!recipients.length) {
            await showDialog({
              title: 'No Recipients',
              message: 'Add at least one recipient before sending a test.'
            });
            return;
          }

          const subj = (n?.message?.subject || 'Dev Tunnel Proxy notification').toString();
          const body = (n?.message?.body || '').toString();

          const testSubject = `TEST: ${subj}`;
          const testBody = body
            ? `This is a test notification for ${route}.\n\n${body}`
            : `This is a test notification for ${route}.`;

          const ok = await showDialog({
            type: 'confirm',
            title: 'Send Test Notification',
            message: `Send a test to:\n\n${recipients.join(', ')}\n\nRoute: ${route}`,
            okText: 'Send Test',
            cancelText: 'Cancel'
          });
          if (!ok) return;

          try {
            const resp = await fetch(NOTIF_TEST_ENDPOINT, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                recipients,
                subject: testSubject,
                message: testBody
              })
            });

            let payload = null;
            try { payload = await resp.json(); } catch {}

            if (resp.ok) {
              await showDialog({
                title: '‚úÖ Test Sent',
                message: `Test notification sent to ${recipients.join(', ')}!\n\nIf this is your first time, macOS may have prompted for automation permission.\n\nTo grant permission:\n1. Open System Settings ‚Üí Privacy & Security ‚Üí Automation\n2. Look for "node" in the list\n3. Check the box next to "Messages"`
              });
            } else {
              const detail = payload?.error || JSON.stringify(payload || {}) || `HTTP ${resp.status}`;
              const helpText = detail.includes('not authorized') || detail.includes('permission')
                ? '\n\nüîê Permission Issue:\n1. Open System Settings ‚Üí Privacy & Security ‚Üí Automation\n2. Look for "node" and enable "Messages"\n\nOr run: open "x-apple.systempreferences:com.apple.preference.security?Privacy_Automation"'
                : '\n\nIs the macOS notifications bridge running?\nRun: node macos/notifications-bridge.js';
              await showDialog({
                title: '‚ùå Test Failed',
                message: `${detail}${helpText}`
              });
            }
          } catch (e) {
            await showDialog({
              title: '‚ùå Test Failed',
              message: `${e?.message || e}\n\nIs the macOS notifications bridge running?\nRun: node macos/notifications-bridge.js`
            });
          }
        }

        function render(){
          modal.innerHTML = '';

          // Header
          const header = document.createElement('div');
          header.className = 'notif-header';

          const title = document.createElement('div');
          title.className = 'title';
          title.innerHTML = `<h2 style="margin:0">Notifications</h2><small>${source} ‚Ä¢ <span style="font-family:var(--mono, monospace)">${route}</span></small>`;
          header.appendChild(title);

          const actions = document.createElement('div');
          actions.className = 'notif-actions';

          const addBtn = document.createElement('button');
          addBtn.className = 'btn';
          addBtn.textContent = '+';
          addBtn.title = 'Add notification';
          addBtn.addEventListener('click', () => {
            startWizard(null);
          });

          const closeBtn = document.createElement('button');
          closeBtn.className = 'btn';
          closeBtn.textContent = '√ó';
          closeBtn.title = 'Close';
          closeBtn.addEventListener('click', () => backdrop.remove());

          if (view.mode === 'wizard') actions.appendChild(closeBtn);
          else {
            actions.appendChild(addBtn);
            actions.appendChild(closeBtn);
          }
          header.appendChild(actions);
          modal.appendChild(header);

          const divider = document.createElement('div');
          divider.className = 'notif-divider';
          modal.appendChild(divider);

          if (view.mode === 'wizard') {
            renderWizard();
            return;
          }

          // List
          const list = document.createElement('div');
          list.className = 'notif-list';

          const all = getRouteNotifications();
          const active = all.filter(n => !n.recycledAt);
          const recycled = all.filter(n => !!n.recycledAt);

          if (active.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'notif-empty';
            empty.innerHTML = `No notifications configured for this route yet.`;
            list.appendChild(empty);
          } else {
            active.forEach(n => list.appendChild(renderNotificationItem(n, false)));
          }

          if (recycled.length > 0) {
            const recHdr = document.createElement('div');
            recHdr.className = 'notif-inlineNote';
            recHdr.style.marginTop = '6px';
            recHdr.textContent = `Recycled (${recycled.length})`;
            list.appendChild(recHdr);
            recycled.forEach(n => list.appendChild(renderNotificationItem(n, true)));
          }

          modal.appendChild(list);
        }

        function renderNotificationItem(n, isRecycled){
          const wrap = document.createElement('div');
          wrap.className = 'notif-item' + (isRecycled ? ' recycled' : '');

          const row = document.createElement('div');
          row.className = 'notif-row';

          const summary = document.createElement('div');
          summary.className = 'notif-summary';
          const s = summarize(n);
          summary.innerHTML = `<div class="line1">${escapeHtml(s.line1)}</div><div class="line2">${escapeHtml(s.line2.trim())}</div>`;
          row.appendChild(summary);

          const controls = document.createElement('div');
          controls.className = 'notif-controls';

          const enabledPill = document.createElement('span');
          enabledPill.className = 'notif-pill ' + (n.enabled ? 'ok' : 'warn');
          enabledPill.innerHTML = n.enabled ? '‚úÖ enabled' : '‚è∏ disabled';
          controls.appendChild(enabledPill);

          const toggleBtn = document.createElement('button');
          toggleBtn.className = 'btn-small';
          toggleBtn.textContent = n.enabled ? '‚è∏' : '‚ñ∂';
          toggleBtn.title = n.enabled ? 'Disable' : 'Enable';
          toggleBtn.addEventListener('click', async (e) => {
            e.preventDefault(); e.stopPropagation();
            n.enabled = !n.enabled;
            n.updatedAt = new Date().toISOString();
            upsertNotification(n);
            await saveNotificationsStore(store);
            render();
          });
          controls.appendChild(toggleBtn);

          const editBtn = document.createElement('button');
          editBtn.className = 'btn-small';
          editBtn.textContent = '‚úèÔ∏è';
          editBtn.title = 'Edit';
          editBtn.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            startWizard(n);
          });
          controls.appendChild(editBtn);

          const testBtn = document.createElement('button');
          testBtn.className = 'btn-small';
          testBtn.textContent = 'üß™';
          testBtn.title = 'Send test';
          testBtn.disabled = !!n.recycledAt || ((n?.action?.type || 'text').toLowerCase() !== 'text');
          testBtn.addEventListener('click', async (e) => {
            e.preventDefault(); e.stopPropagation();
            await sendTestNotification(n);
          });
          controls.appendChild(testBtn);

          const recycleBtn = document.createElement('button');
          recycleBtn.className = 'btn-small';
          recycleBtn.textContent = isRecycled ? '‚Ü∫' : '‚ôªÔ∏è';
          recycleBtn.title = isRecycled ? 'Restore' : 'Recycle';
          recycleBtn.addEventListener('click', async (e) => {
            e.preventDefault(); e.stopPropagation();
            if (isRecycled) {
              delete n.recycledAt;
            } else {
              n.recycledAt = new Date().toISOString();
            }
            n.updatedAt = new Date().toISOString();
            upsertNotification(n);
            await saveNotificationsStore(store);
            render();
          });
          controls.appendChild(recycleBtn);

          row.appendChild(controls);
          wrap.appendChild(row);

          // pills row
          const pills = document.createElement('div');
          pills.style.marginTop = '8px';
          pills.style.display = 'flex';
          pills.style.gap = '8px';
          pills.style.flexWrap = 'wrap';
          const p1 = document.createElement('span');
          p1.className = 'notif-pill';
          p1.textContent = (n.conditions?.proxyExternallyAccessible ? 'üåê External' : 'üè† Local');
          const p3 = document.createElement('span');
          p3.className = 'notif-pill';
          p3.textContent = `üìä ${(n.conditions?.containerState || 'running').charAt(0).toUpperCase() + (n.conditions?.containerState || 'running').slice(1)}`;
          const p4 = document.createElement('span');
          p4.className = 'notif-pill';
          p4.textContent = `üí¨ ${(n.action?.type || 'text').toUpperCase()}`;
          pills.appendChild(p1); pills.appendChild(p3); pills.appendChild(p4);
          wrap.appendChild(pills);

          return wrap;
        }

        function startWizard(existing){
          view.mode = 'wizard';
          view.step = 0;
          const base = existing ? JSON.parse(JSON.stringify(existing)) : null;
          const proxyDefault = !!(globalNgrokUrl && globalNgrokUrl !== 'not discovered');

          view.draft = base || {
            id: makeNotifId(),
            enabled: true,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            conditions: {
              proxyExternallyAccessible: proxyDefault,
              containerState: 'running'
            },
            action: {
              type: 'text',
              recipients: []
            },
            message: {
              subject: '',
              body: ''
            },
            _touched: { subject: false, body: false }
          };

          // Ensure recipients are in array form
          if (!Array.isArray(view.draft.action.recipients)) {
            view.draft.action.recipients = splitRecipients(view.draft.action.recipients || '');
          }

          // Apply defaults for message if empty
          const dm = defaultMessageFor({
            route,
            proxyExternallyAccessible: view.draft.conditions.proxyExternallyAccessible,
            containerState: view.draft.conditions.containerState
          });
          if (!view.draft.message.subject) view.draft.message.subject = dm.subject;
          if (!view.draft.message.body) view.draft.message.body = dm.body;
          render();
        }

        function renderWizard(){
          const w = document.createElement('div');
          w.className = 'notif-wiz';

          const steps = document.createElement('div');
          steps.className = 'notif-steps';
          ['Conditions', 'Action', 'Message'].forEach((name, idx) => {
            const s = document.createElement('div');
            const isCompleted = idx < view.step;
            const isActive = view.step === idx;
            s.className = 'notif-step' + (isActive ? ' active' : '') + (isCompleted ? ' completed' : '');
            s.textContent = `${idx+1}. ${name}`;
            if (isCompleted) {
              s.addEventListener('click', () => {
                view.step = idx;
                render();
              });
            }
            steps.appendChild(s);
          });
          w.appendChild(steps);

          const draft = view.draft;

          if (view.step === 0) {
            const grid = document.createElement('div');
            grid.className = 'notif-grid';

            // Proxy externally accessible
            const f1 = document.createElement('div');
            f1.className = 'notif-field';
            f1.innerHTML = `<label>Proxy (externally accessible)</label>`;
            const rr = document.createElement('div');
            rr.className = 'notif-radioRow';
            const yes = radioChip('proxyExternal', 'Yes', draft.conditions.proxyExternallyAccessible === true);
            const no = radioChip('proxyExternal', 'No', draft.conditions.proxyExternallyAccessible === false);
            rr.appendChild(yes.wrap); rr.appendChild(no.wrap);
            f1.appendChild(rr);
            f1.appendChild(hint('Trigger only when the proxy is externally accessible (e.g., ngrok) or local-only.'));
            grid.appendChild(f1);

            // Endpoint Status
            const f3 = document.createElement('div');
            f3.className = 'notif-field';
            f3.innerHTML = `<label>Endpoint Status</label>`;
            const rr2 = document.createElement('div');
            rr2.className = 'notif-radioRow';
            ['running','stopped'].forEach((s) => {
              const chip = radioChip('containerState', s[0].toUpperCase()+s.slice(1), (draft.conditions.containerState||'running') === s);
              rr2.appendChild(chip.wrap);
            });
            f3.appendChild(rr2);
            f3.appendChild(hint('Trigger when the upstream endpoint is running (responding) or stopped (not responding).'));
            grid.appendChild(f3);

            w.appendChild(grid);

            // Wire radios
            yes.input.addEventListener('change', () => {
              draft.conditions.proxyExternallyAccessible = true;
              maybeUpdateDefaults();
            });
            no.input.addEventListener('change', () => {
              draft.conditions.proxyExternallyAccessible = false;
              maybeUpdateDefaults();
            });
            rr2.querySelectorAll('input[name="containerState"]').forEach((inp) => {
              inp.addEventListener('change', () => {
                draft.conditions.containerState = inp.value;
                maybeUpdateDefaults();
              });
            });
          }

          if (view.step === 1) {
            const grid = document.createElement('div');
            grid.className = 'notif-grid';

            const f1 = document.createElement('div');
            f1.className = 'notif-field';
            f1.innerHTML = `<label>Action type</label>`;
            const rr = document.createElement('div');
            rr.className = 'notif-radioRow';
            const text = radioChip('actionType', 'Text (default)', (draft.action.type||'text') === 'text');
            const email = radioChip('actionType', 'Email (disabled)', (draft.action.type||'text') === 'email');
            email.input.disabled = true;
            email.wrap.style.opacity = '.55';
            rr.appendChild(text.wrap); rr.appendChild(email.wrap);
            f1.appendChild(rr);
            f1.appendChild(hint('Email is planned, but currently disabled.'));
            grid.appendChild(f1);

            const f2 = document.createElement('div');
            f2.className = 'notif-field';
            f2.innerHTML = `<label>Recipients</label>`;
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.placeholder = '+15125551212, +15125559876';
            inp.value = joinRecipients(draft.action.recipients || []);
            inp.addEventListener('input', () => {
              draft.action.recipients = splitRecipients(inp.value);
            });
            f2.appendChild(inp);
            f2.appendChild(hint('One (required) or more recipients. Separate values with commas or spaces.'));
            grid.appendChild(f2);

            w.appendChild(grid);

            text.input.addEventListener('change', () => {
              draft.action.type = 'text';
            });
          }

          if (view.step === 2) {
            const grid = document.createElement('div');
            grid.className = 'notif-grid';

            const f1 = document.createElement('div');
            f1.className = 'notif-field';
            f1.innerHTML = `<label>Subject</label>`;
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.value = draft.message.subject || '';
            inp.addEventListener('input', () => {
              draft.message.subject = inp.value;
              draft._touched = draft._touched || { subject:false, body:false };
              draft._touched.subject = true;
            });
            f1.appendChild(inp);
            f1.appendChild(hint('Default subject is generated from the selected conditions.'));
            grid.appendChild(f1);

            const f2 = document.createElement('div');
            f2.className = 'notif-field';
            f2.innerHTML = `<label>Message</label>`;
            const ta = document.createElement('textarea');
            ta.value = draft.message.body || '';
            ta.addEventListener('input', () => {
              draft.message.body = ta.value;
              draft._touched = draft._touched || { subject:false, body:false };
              draft._touched.body = true;
            });
            f2.appendChild(ta);
            f2.appendChild(hint('Default message is generated from the selected conditions.'));
            grid.appendChild(f2);

            w.appendChild(grid);
          }

          const toolbar = document.createElement('div');
          toolbar.className = 'toolbar';

          const cancel = document.createElement('button');
          cancel.className = 'btn';
          cancel.textContent = 'Cancel';
          cancel.addEventListener('click', () => {
            view.mode = 'list';
            view.draft = null;
            render();
          });

          const next = document.createElement('button');
          next.className = 'btn';
          next.textContent = view.step === 2 ? 'Save' : 'Next';
          next.addEventListener('click', async () => {
            const err = validateStep(view.step, view.draft);
            if (err) { 
              await showDialog({
                title: 'Validation Error',
                message: err
              });
              return;
            }
            if (view.step < 2) { view.step++; render(); return; }
            // Save
            const n = view.draft;
            n.updatedAt = new Date().toISOString();
            // Normalize
            n.action.recipients = Array.isArray(n.action.recipients) ? n.action.recipients : splitRecipients(n.action.recipients || '');
            delete n._touched;
            upsertNotification(n);
            await saveNotificationsStore(store);
            view.mode = 'list';
            view.draft = null;
            render();
          });

          const resetDefaults = document.createElement('button');
          resetDefaults.className = 'btn';
          resetDefaults.textContent = 'Reset defaults';
          resetDefaults.title = 'Regenerate subject/message from the current conditions';
          resetDefaults.addEventListener('click', () => {
            const dm = defaultMessageFor({
              route,
              proxyExternallyAccessible: draft.conditions.proxyExternallyAccessible,
              containerState: draft.conditions.containerState
            });
            draft.message.subject = dm.subject;
            draft.message.body = dm.body;
            draft._touched = { subject: false, body: false };
            render();
          });

          toolbar.appendChild(cancel);
          if (view.step === 2) toolbar.appendChild(resetDefaults);
          toolbar.appendChild(next);
          w.appendChild(toolbar);

          modal.appendChild(w);
        }

        function validateStep(step, d){
          if (step === 0) {
            if (d.conditions.proxyExternallyAccessible !== true && d.conditions.proxyExternallyAccessible !== false) return 'Select whether the proxy must be externally accessible.';
            if (!d.conditions.containerState) return 'Pick a status.';
          }
          if (step === 1) {
            const rec = d.action.recipients || [];
            const list = Array.isArray(rec) ? rec : splitRecipients(rec);
            if (list.length === 0) return 'Add at least one recipient.';
            
            // Check for duplicate notifications with same conditions and action
            const all = getRouteNotifications();
            const duplicate = all.find(n => {
              // Skip checking against itself if editing
              if (n.id === d.id) return false;
              // Skip recycled notifications
              if (n.recycledAt) return false;
              // Check if conditions match
              const conditionsMatch = 
                n.conditions?.proxyExternallyAccessible === d.conditions?.proxyExternallyAccessible &&
                n.conditions?.containerState === d.conditions?.containerState;
              // Check if action type matches
              const actionTypeMatch = (n.action?.type || 'text') === (d.action?.type || 'text');
              // Check if recipients overlap
              const nRecipients = Array.isArray(n.action?.recipients) ? n.action.recipients : splitRecipients(n.action?.recipients || '');
              const dRecipients = Array.isArray(rec) ? rec : list;
              const recipientsOverlap = nRecipients.some(r => dRecipients.includes(r));
              
              return conditionsMatch && actionTypeMatch && recipientsOverlap;
            });
            
            if (duplicate) {
              const proxyLabel = duplicate.conditions?.proxyExternallyAccessible ? 'external' : 'local-only';
              const statusLabel = (duplicate.conditions?.containerState || 'running').toLowerCase();
              return `You already have a notification configured for these conditions (${proxyLabel}, ${statusLabel}) with overlapping recipients. Please use different conditions or recipients.`;
            }
          }
          if (step === 2) {
            if (!(d.message.subject||'').trim()) return 'Subject is required.';
            if (!(d.message.body||'').trim()) return 'Message is required.';
          }
          return null;
        }

        function maybeUpdateDefaults(){
          const d = view.draft;
          if (!d) return;
          const dm = defaultMessageFor({
            route,
            proxyExternallyAccessible: d.conditions.proxyExternallyAccessible,
            containerState: d.conditions.containerState
          });
          const touched = d._touched || { subject:false, body:false };
          if (!touched.subject) d.message.subject = dm.subject;
          if (!touched.body) d.message.body = dm.body;
        }

        function radioChip(name, label, checked){
          const wrap = document.createElement('label');
          wrap.className = 'notif-radio';
          const input = document.createElement('input');
          input.type = 'radio';
          input.name = name;
          input.value = label.toLowerCase();
          input.checked = !!checked;
          const span = document.createElement('span');
          span.textContent = label;
          wrap.appendChild(input); wrap.appendChild(span);
          return { wrap, input };
        }
        function hint(text){
          const h = document.createElement('div');
          h.className = 'hint';
          h.textContent = text;
          return h;
        }
        function escapeHtml(str){
          return (str||'').replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }

        backdrop.appendChild(modal);
        document.body.appendChild(backdrop);
        render();
      }

      function routeDepth(r){ return (r||'').split('/').filter(Boolean).length; }
      function normalizeBase(up){
        if (!up) return '';
        
        // Handle nginx variables like $inspire_upstream by treating them as literal keys
        if (up.includes('$')) {
          const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
          if (m && m[0]) return m[0];
          // Fallback: strip protocol and take host token before first '/'
          return up.replace(/^https?:\/\//,'').split('/')[0];
        }
        
        try{ 
          const u = new URL(up.startsWith('http') ? up : `http://${up}`); 
          return `${u.protocol}//${u.hostname}${u.port ? `:${u.port}` : ''}`;
        } catch { 
          return up.replace(/\/$/, ''); 
        }
      }
      function extractHostname(up){
        if (!up) return '';
        if (up.includes('$')) return up;
        try{
          const u = new URL(up.startsWith('http') ? up : `http://${up}`);
          return u.hostname; // ignore port for grouping
        }catch{
          return up.replace(/:\d+.*$/, '').replace(/\/$/, '');
        }
      }
      function addStatusChips(container, route, targets, routes){
        for (const t of targets) {
          const info = (routes.summary?.[t] || {})[route];
          if (!info) continue;
          
          const status = info.status || 0;
          let cls = 'err', reason = '';
          // Treat 2xx as ok; 308 Permanent Redirect is also OK for prefixed routes
          if (status >= 200 && status < 300) { cls = 'ok'; reason = 'Working correctly'; }
          else if (status === 308) { cls = 'ok'; reason = 'Permanent redirect'; }
          else if (status >= 300 && status < 400) { cls = 'warn'; reason = 'Redirect'; }
          else if (status === 404) { cls = 'warn'; reason = 'Not found - check route configuration'; }
          else if (status === 0) { cls = 'warn'; reason = 'No response from this target'; }
          else if (status >= 400 && status < 500) { cls = 'warn'; reason = 'Client error - check route configuration'; }
          else if (status >= 500) { cls = 'err'; reason = 'Server error - upstream service issue'; }
          
          const labelName = (t === 'local-proxy') ? 'localhost' : t;
          const label = `${labelName}: ${status}`;
          const statusChip = chip(label, cls, reason);
          container.appendChild(statusChip);
        }
      }
      function severityOf(route, targets, routes){
        // ok if ANY target is ok; treat 308 as ok, other 3xx/0 as warn
        let sev='err';
        for (const t of targets){
          const info=(routes.summary?.[t]||{})[route];
          if (!info) continue;
          const s = info.status||0;
          if (s>=200 && s<300) return 'ok';
          if (s===308) return 'ok';
          if (s>=300 && s<400) sev = sev==='ok'?'ok':'warn';
          else if (s===0) sev = sev==='ok'?'ok':'warn';
        }
        return sev;
      }
      function applyFilter(routeGroups, filterValue, targets, routes){
        const q=(filterValue||'').trim().toLowerCase(); if(!q) return routeGroups;
        const codeOnly = /^\d{3}$/.test(q) ? parseInt(q,10) : null;
        const targetCodeMatch = q.match(/^(ngrok|localhost|local-proxy):(\d{3})$/);
        const targetKey = targetCodeMatch ? (targetCodeMatch[1]==='localhost'?'local-proxy':targetCodeMatch[1]) : null;
        const targetCode = targetCodeMatch ? parseInt(targetCodeMatch[2],10) : null;
        const matches = (route)=>{
          const name=(route||'').toLowerCase();
          if (name.includes(q)) return true;
          if (q==='ok'||q==='warn'||q==='err') return severityOf(route,targets,routes)===q;
          // match upstream base host
          const up = (routes.metadata?.[route]?.upstream || '').toLowerCase();
          if (up && up.includes(q)) return true;
          // status code anywhere
          if (codeOnly!=null){
            for (const t of targets){ const info=(routes.summary?.[t]||{})[route]; if (info && info.status===codeOnly) return true; }
          }
          // specific target:code
          if (targetKey){ const info=(routes.summary?.[targetKey]||{})[route]; if (info && info.status===targetCode) return true; }
          return false;
        };
        return routeGroups.filter(g=> matches(g.route) || (g.children||[]).some(c=>matches(c)) );
      }

      function debounce(fn, wait){ let to=null; return function(...args){ clearTimeout(to); to=setTimeout(()=>fn.apply(this,args), wait); }; }

      // Simple masonry layout helper that orders cards by height
      function applyMasonryLayout(){
        const appsEl = document.getElementById('apps');
        if (!appsEl) return;
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        // Only apply masonry on multi-column layouts
        if (vw < 900) return;
        
        requestAnimationFrame(() => {
          const cards = Array.from(appsEl.children);
          if (cards.length === 0) return;
          
          // Sort cards by height (shortest first) to better pack the grid
          const cardHeights = cards.map(card => ({
            element: card,
            height: card.offsetHeight || 0
          }));
          
          // Reorder: short cards first tend to pack better with CSS Grid dense
          cardHeights.sort((a, b) => a.height - b.height);
          
          // Reattach in sorted order
          cardHeights.forEach(item => {
            appsEl.appendChild(item.element);
          });
        });
      }

      function createRouteCard(item, targetsArr, routes, meta) {
        const app = document.createElement('div');
        app.className = 'app';
        const route = item.route;
        const source = item.source;

        // Create header with route name
        const header = document.createElement('div');
        header.className = 'route-header';
        
        const titleSection = document.createElement('div');
        titleSection.className = 'route-title';
        titleSection.innerHTML = `<span class="route-name">${route}</span>`;
        header.appendChild(titleSection);
        
        // Create action buttons container
        const actionContainer = document.createElement('div');
        actionContainer.className = 'action-buttons-container';
        
        function createActionButton(type, options = {}) {
          const btn = document.createElement('button');
          btn.className = 'circular-action-btn';
          btn.type = 'button';
          btn.title = options.title || '';
          btn.setAttribute('aria-label', options.ariaLabel || options.title || '');
          if (options.innerHTML) btn.innerHTML = options.innerHTML;
          else btn.textContent = options.text || '';
          if (options.dataset) {
            Object.entries(options.dataset).forEach(([key, value]) => {
              btn.dataset[key] = value;
            });
          }
          return btn;
        }

        // Notifications button (left of existing actions)
        const notifyBtn = createActionButton('notifications', {
          title: 'Notifications',
          innerHTML: 'üîî',
          dataset: { route, source }
        });
        notifyBtn.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          openNotificationsModal({ route, source, meta: routes?.metadata?.[route] || null });
        });
        actionContainer.appendChild(notifyBtn);
        
        // Open button
        const openBtn = createActionButton('open', {
          title: 'Open Route',
          innerHTML: 'üöÄ',
          dataset: { route }
        });
        openBtn.addEventListener('click', (e) => {
          e.preventDefault(); 
          e.stopPropagation();
          const url = chooseOpenUrl(routes, targetsArr, route);
          if (url) window.open(url, '_blank', 'noopener');
        });
        actionContainer.appendChild(openBtn);
        
        // Promote/Demote button
        const promotions = loadPromotions();
        const isPromoted = promotions?.[source]?.[route] || false;
        const promoteBtn = createActionButton('promote', {
          title: isPromoted ? 'Demote (ungroup children)' : 'Promote (group children under this route)',
          innerHTML: isPromoted ? 'üìç' : 'üìå',
          dataset: { route, source }
        });
        promoteBtn.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          togglePromotion(route, source);
        });
        actionContainer.appendChild(promoteBtn);
        
        // Dashboard button
        const dashBtn = createActionButton('dashboard', {
          title: 'Open Dashboard (route-focused)',
          innerHTML: 'üìä',
          dataset: { route }
        });
        dashBtn.addEventListener('click', (e) => {
          e.preventDefault(); e.stopPropagation();
          const base = (globalNgrokUrl && globalNgrokUrl !== 'not discovered') ? globalNgrokUrl.replace(/\/$/, '') : '';
          const url = base ? `${base}${route.startsWith('/')?route:'/'+route}` : '';
          const qp = new URLSearchParams();
          if (route) qp.set('route', route);
          if (url) qp.set('url', url);
          window.open(`/dashboard/?${qp.toString()}`,'_blank','noopener');
        });
        actionContainer.appendChild(dashBtn);
        
        // Calliope button
        const calliopeBtn = createActionButton('calliope', {
          title: 'Diagnose with Calliope',
          innerHTML: '<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;">',
          dataset: { route }
        });
        calliopeBtn.onclick = function(e){
          e.preventDefault(); e.stopPropagation();
          try { runCalliopeHealth(route); } catch(_) {
            const drawer = document.getElementById('aiDrawer');
            if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
          }
        };
        actionContainer.appendChild(calliopeBtn);
        
        header.appendChild(actionContainer);
        
        // Create chips section
        const chipsSection = document.createElement('div');
        chipsSection.className = 'route-chips-section';
        
        // Config file chip and upstream on same row (config first)
        const baseContainer = document.createElement('div');
        baseContainer.className = 'chips';
        baseContainer.style.display = 'flex';
        baseContainer.style.alignItems = 'center';
        baseContainer.style.gap = '8px';
        
        // Add config file chip first
        const configChip = document.createElement('span');
        configChip.className = 'chip';
        configChip.style.fontSize = '10px';
        configChip.style.opacity = '0.7';
        configChip.textContent = source.replace(/\.conf$/, '');
        configChip.title = `From ${source}`;
        baseContainer.appendChild(configChip);
        
        // Then upstream chip
        const baseChip = chip(normalizeBase(meta[route]?.upstream || ''), 'upstream-base');
        baseContainer.appendChild(baseChip);
        
        chipsSection.appendChild(baseContainer);
        
        // Status chips
        const statusContainer = document.createElement('div');
        statusContainer.className = 'chips route-status';
        addStatusChips(statusContainer, route, targetsArr, routes);
        chipsSection.appendChild(statusContainer);
        
        // Append elements
        app.appendChild(header);
        app.appendChild(chipsSection);
        
        // Add a dedicated row for the children badge (will be populated if this is a promoted parent)
        const badgeRow = document.createElement('div');
        badgeRow.className = 'badge-row';
        badgeRow.style.cssText = 'display:flex;justify-content:flex-end;align-items:center;min-height:32px;margin-top:8px;';
        app.appendChild(badgeRow);
        
        // Store reference to badge row for promoted parents
        app._badgeRow = badgeRow;
        
        // Apply severity styling
        applySeverityToApp(app, route, targetsArr, routes);
        
        return app;
      }

      function rebuildApps(){
        const routes = routesData;
        const appsEl = document.getElementById('apps');
        appsEl.innerHTML = '';
        const targets = Object.keys(routes.summary||{});
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const srcFull = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          const src = srcFull.split('/').pop();
          (bySource[src] = bySource[src] || []).push(r);
        });
        // Responsive columns are handled by CSS media queries
        function buildGroupsByBase(routesInSource, meta, configFile){
          const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/',window.DTP.config.apiPath('resolve-conflict'),window.DTP.config.apiPath('rename-route')]);
          const routesList = routesInSource.filter(r=>!systemRoutes.has(r));
          
          // SIMPLIFIED: No auto-promotion, only manual promotions within same config file
          promotedRoots = loadPromotions();
          const groups = [];
          const processedRoutes = new Set();
          
          // Sort routes by path for consistent processing
          const sortedRoutes = Array.from(new Set(routesList)).sort((a,b)=> a.localeCompare(b));
          
          // Check for manually promoted routes in this config file
          const promotedInConfig = promotedRoots?.[configFile] || {};
          
          sortedRoutes.forEach(route => {
            if (processedRoutes.has(route)) return;
            
            // Check if this route is manually promoted as a parent
            if (promotedInConfig[route]) {
              // Find all routes that start with this route (children)
              const children = sortedRoutes.filter(r => 
                r !== route && 
                r.startsWith(route) && 
                (r[route.length] === '/' || route.endsWith('/'))
              );
              
              groups.push({ route, children, baseKey: configFile });
              processedRoutes.add(route);
              children.forEach(child => processedRoutes.add(child));
            }
          });
          
          // Add remaining routes as standalone (no grouping)
          sortedRoutes.forEach(route => {
            if (!processedRoutes.has(route)) {
              groups.push({ route, children: [], baseKey: configFile });
            }
          });
          
          return groups;
        }

        // NEW APPROACH: Flatten all routes into individual cards
        const allRoutes = [];
        Object.keys(bySource).forEach(source => {
          const inThisSource = Object.keys(meta).filter(r => {
            const srcFull = (meta[r]||{}).sourceFile || '';
            const base = srcFull.split('/').pop();
            return base === source;
          });
          // Add each route with its source file
          inThisSource.forEach(route => {
            if (!route.match(/^\/(health|status|reports|api\/config|api\/resolve-conflict|api\/rename-route)/)) {
              allRoutes.push({ route, source });
            }
          });
        });

        // Apply filtering
        const targetsArr = Object.keys(routes.summary||{});
        const sortEl = document.getElementById('sortMode');
        const groupByEl = document.getElementById('groupByMode');
        const filterEl = document.getElementById('routeFilter');
        let sortMode = (preferences?.sortMode) || (sortEl && sortEl.value) || 'status';
        if (sortMode==='manual') { sortMode='status'; preferences.sortMode='status'; savePrefs(preferences); if (sortEl) sortEl.value='status'; }
        const filterVal = (preferences?.filter) || (filterEl && filterEl.value) || '';
        
        let filteredRoutes = allRoutes;
        if (filterVal) {
          const filterParts = filterVal.split(/[,\s]+/).filter(Boolean);
          filteredRoutes = allRoutes.filter(item => {
            return filterParts.some(part => {
              const lower = part.toLowerCase();
              // Check route path
              if (item.route.toLowerCase().includes(lower)) return true;
              // Check status keywords
              if (lower === 'ok' || lower === 'warn' || lower === 'err') {
                return severityOf(item.route, targetsArr, routes) === lower;
              }
              // Check status codes
              if (/^\d+$/.test(lower)) {
                const code = parseInt(lower);
                return targetsArr.some(t => {
                  const info = (routes.summary?.[t]||{})[item.route];
                  return info && info.status === code;
                });
              }
              // Check target:code format
              if (lower.includes(':')) {
                const [targetKey, targetCode] = lower.split(':');
                const info = (routes.summary?.[targetKey]||{})[item.route];
                return info && info.status === parseInt(targetCode);
              }
              // Check upstream
              const upstream = (meta[item.route]||{}).upstream || '';
              if (upstream.toLowerCase().includes(lower)) return true;
              return false;
            });
          });
        }

        // Check grouping preference
        const groupByMode = (preferences?.groupByMode) || (groupByEl && groupByEl.value) || 'none';
        
        // Toggle grouped layout class on apps container
        if (groupByMode === 'config') {
          appsEl.classList.add('grouped-layout');
        } else {
          appsEl.classList.remove('grouped-layout');
        }
        
        // Apply sorting
        const sortFunction = (a, b) => {
          if (sortMode === 'alpha') {
            return a.route.localeCompare(b.route);
          } else if (sortMode === 'status') {
            const rank = {err: 0, warn: 1, ok: 2};
            const sevA = severityOf(a.route, targetsArr, routes);
            const sevB = severityOf(b.route, targetsArr, routes);
            return (rank[sevA] - rank[sevB]) || a.route.localeCompare(b.route);
          } else if (sortMode === 'depth') {
            const depthA = (a.route||'').split('/').filter(Boolean).length;
            const depthB = (b.route||'').split('/').filter(Boolean).length;
            return (depthA - depthB) || a.route.localeCompare(b.route);
          }
          return 0;
        };

        // Render based on grouping mode
        if (groupByMode === 'config') {
          // Group by config file
          const grouped = {};
          filteredRoutes.forEach(item => {
            if (!grouped[item.source]) grouped[item.source] = [];
            grouped[item.source].push(item);
          });
          
          // Sort config files alphabetically
          const sortedSources = Object.keys(grouped).sort();
          
          // For each config file
          sortedSources.forEach(source => {
            // Sort routes within this group
            grouped[source].sort(sortFunction);
            
            // Create config file container card
            const configCard = document.createElement('div');
            configCard.className = 'card config-group-card';
            
            // Config file header
            const configHeader = document.createElement('div');
            configHeader.className = 'config-group-header';
            configHeader.innerHTML = `<h2>${source.replace(/\.conf$/, '')}</h2><span class="config-route-count">${grouped[source].length} route${grouped[source].length !== 1 ? 's' : ''}</span>`;
            configCard.appendChild(configHeader);
            
            // Routes container within this config
            const routesContainer = document.createElement('div');
            routesContainer.className = 'config-routes-container';
            
            grouped[source].forEach(item => {
              const app = createRouteCard(item, targetsArr, routes, meta);
              routesContainer.appendChild(app);
            });
            
            configCard.appendChild(routesContainer);
            appsEl.appendChild(configCard);
          });
        } else {
          // Flat view with optional manual promotions
          filteredRoutes.sort(sortFunction);
          
          // Check for promoted routes and group their children
          const promotions = loadPromotions();
          const processedRoutes = new Set();
          
          filteredRoutes.forEach(item => {
            if (processedRoutes.has(item.route)) return;
            
            const configFile = item.source;
            const isPromoted = promotions?.[configFile]?.[item.route] || false;
            
            if (isPromoted) {
              // Find children of this promoted route
              const children = filteredRoutes.filter(child => 
                child.route !== item.route &&
                child.source === configFile &&
                child.route.startsWith(item.route) &&
                (child.route[item.route.length] === '/' || item.route.endsWith('/'))
              );
              
              // Create parent card
              const parentCard = createRouteCard(item, targetsArr, routes, meta);
              parentCard.classList.add('promoted-parent');
              parentCard.style.position = 'relative';
              
              // Add visual indicator that this is a parent with children
              if (children.length > 0) {
                parentCard.style.borderLeft = '4px solid var(--ok)';
                parentCard.style.boxShadow = '0 0 0 1px rgba(22,199,132,0.2), 0 6px 24px rgba(0,0,0,.25)';
                
                // Add collapsible badge to the dedicated badge row
                const badge = document.createElement('div');
                badge.className = 'children-toggle-badge';
                badge.style.cssText = 'background:rgba(22,199,132,0.8);color:#fff;padding:6px 10px;border-radius:6px;font-size:11px;font-weight:700;cursor:pointer;display:flex;align-items:center;gap:8px;transition:background 0.2s, transform 0.2s;';
                badge.innerHTML = `<span>${children.length} child${children.length > 1 ? 'ren' : ''}</span><span class="chevron" style="transition:transform 0.2s;">‚ñº</span>`;
                
                // Add badge to the badge row (row 5)
                parentCard._badgeRow.appendChild(badge);
                
                // Create children container INSIDE parent card (new rows below row 5)
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'promoted-children';
                childrenContainer.style.cssText = 'display:none;padding-top:16px;border-top:1px solid var(--border);flex-direction:column;gap:8px;';
                
                children.forEach(child => {
                  const childCard = createRouteCard(child, targetsArr, routes, meta);
                  childCard.classList.add('promoted-child');
                  childCard.style.opacity = '0.9';
                  childCard.style.background = 'var(--panel)';
                  childCard.style.border = '1px solid var(--border)';
                  childrenContainer.appendChild(childCard);
                  processedRoutes.add(child.route);
                });
                
                parentCard.appendChild(childrenContainer);
                
                // Set up badge click handler
                badge.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  const isExpanded = childrenContainer.style.display === 'flex';
                  childrenContainer.style.display = isExpanded ? 'none' : 'flex';
                  badge.querySelector('.chevron').style.transform = isExpanded ? 'rotate(0deg)' : 'rotate(180deg)';
                  badge.style.background = isExpanded ? 'rgba(22,199,132,0.8)' : 'rgba(127,176,255,0.8)';
                });
                
                badge.addEventListener('mouseenter', () => {
                  badge.style.transform = 'scale(1.05)';
                });
                
                badge.addEventListener('mouseleave', () => {
                  badge.style.transform = 'scale(1)';
                });
              }
              
              appsEl.appendChild(parentCard);
              processedRoutes.add(item.route);
            } else {
              // Regular route card
              const app = createRouteCard(item, targetsArr, routes, meta);
              appsEl.appendChild(app);
              processedRoutes.add(item.route);
            }
          });
        }

      }
      function sortRoutes(routeGroups, sortMode, targets, routes){
        if (sortMode==='alpha') return routeGroups.slice().sort((a,b)=> a.route.localeCompare(b.route));
        if (sortMode==='depth') return routeGroups.slice().sort((a,b)=> routeDepth(a.route)-routeDepth(b.route) || a.route.localeCompare(b.route));
        if (sortMode==='status'){
          const rank={err:0,warn:1,ok:2};
          return routeGroups.slice().sort((a,b)=> (rank[severityOf(a.route,targets,routes)]-rank[severityOf(b.route,targets,routes)]) || a.route.localeCompare(b.route));
        }
        return routeGroups;
      }
      function rememberOrder(rendered){ preferences.routeOrder = rendered.map(g=>g.route); savePrefs(preferences); }

      // Bootstrap Calliope enabled flag ASAP so global handlers have a value
      (async function bootstrapCalliopeEnabled(){
        try{
          const resp = await fetch(window.DTP.config.apiPath('ai/health'), { headers: { 'ngrok-skip-browser-warning': 'true' } });
          if (resp.ok){
            const j = await resp.json();
            window.__calliopeEnabled = !!j.enabled;
            document.body.classList.toggle('calliope-enabled', window.__calliopeEnabled);
          } else {
            window.__calliopeEnabled = false;
            document.body.classList.remove('calliope-enabled');
          }
        }catch{
          window.__calliopeEnabled = false;
          document.body.classList.remove('calliope-enabled');
        }
      })();

      (async function init(){
        preferences = loadPrefs();
        const routes = await loadJSON('/routes.json');
        routesData = routes;
        
        // Load ngrok URL with multiple fallback strategies
        let ngrokTxt = 'not discovered';
        
        // Strategy 1: Try status.json first (source of truth for health dashboard)
        try {
          const status = await loadJSON('/status.json');
          if (status && status.ngrok && status.ngrok !== 'not discovered' && status.ngrok !== 'null') {
            ngrokTxt = status.ngrok;
          }
        } catch (e) { /* Continue to next strategy */ }
        
        // Strategy 2: If status.json fails or has no ngrok, try health-latest.json
        if (ngrokTxt === 'not discovered') {
          try {
            const healthResp = await fetch('/.artifacts/reports/health-latest.json', { 
              headers: { 'ngrok-skip-browser-warning': 'true' },
              cache: 'no-cache'
            });
            if (healthResp.ok) {
              const healthData = await healthResp.json();
              if (healthData && healthData.ngrok && healthData.ngrok !== 'not discovered' && healthData.ngrok !== 'null') {
                ngrokTxt = healthData.ngrok;
              }
            }
          } catch (e) { /* Continue to next strategy */ }
        }
        
        // Strategy 3: Fall back to routes.json (what we already have)
        if (ngrokTxt === 'not discovered' && routes && routes.ngrok && routes.ngrok !== 'not discovered' && routes.ngrok !== 'null') {
          ngrokTxt = routes.ngrok;
        }
        
        // Strategy 4: Last resort - look for static domain hint in a minimal API call
        if (ngrokTxt === 'not discovered') {
          try {
            const staticDomainResp = await fetch(window.DTP.config.apiPath('ai/health'), { 
              method: 'GET',
              headers: { 'ngrok-skip-browser-warning': 'true' }
            });
            if (staticDomainResp.ok) {
              const data = await staticDomainResp.json();
              if (data && data.staticNgrokDomain) {
                ngrokTxt = `https://${data.staticNgrokDomain}`;
              }
            }
          } catch (e) { /* Tried our best */ }
        }
        
        // Store globally for Open button functionality
        globalNgrokUrl = ngrokTxt;
        
        // Build overview chips row with bold labels
        const summaryWrap = document.getElementById('summaryChips');
        summaryWrap.innerHTML = '';
        const generatedTime = routes.generatedAt ? new Date(routes.generatedAt).toLocaleString() : '‚Äî';
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Generated:</strong> ${generatedTime}`;
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Proxy URL:</strong> ${ngrokTxt}`;
        const targets = Object.keys(routes.summary||{});
        summaryWrap.appendChild(chipEl(``, '')); summaryWrap.lastChild.innerHTML = `<strong>Targets:</strong> ${targets.join(', ') || '‚Äî'}`;

        // Group by source file from metadata (data-driven)
        const meta = routes.metadata || {};
        const bySource = {};
        Object.keys(meta).forEach(r => {
          const srcFull = (meta[r] && meta[r].sourceFile) || 'unknown.conf';
          const src = srcFull.split('/').pop();
          (bySource[src] = bySource[src] || []).push(r);
        });

        // Fetch override conflicts and mark sources that can be resolved
        let conflicts = [];
        try{
          const c = await fetch(window.DTP.config.apiPath('overrides/conflicts'), { headers: { 'ngrok-skip-browser-warning': 'true' } });
          if (c.ok){ const j = await c.json(); conflicts = Array.isArray(j.conflicts) ? j.conflicts : []; }
        }catch{}
        const conflictByName = new Set(conflicts.map(x=> x && x.filename).filter(Boolean));
        window.conflictByName = conflictByName;

        // Build hierarchical route structure (no hardcoded roots)
        const systemRoutes = new Set(['/health/','/status/','/reports/','/api/config/',window.DTP.config.apiPath('resolve-conflict'),window.DTP.config.apiPath('rename-route')]);
        const isSystem = (r)=> systemRoutes.has(r);
        const isTechnical = (r)=> r.startsWith('/static/') || r.startsWith('/sockjs-node') || r.startsWith('/node_modules/') || r.startsWith('/@') || r.startsWith('/_next/') || r.startsWith('/src/') || r.startsWith('/.storybook/') || r.startsWith('/sb-') || r==='/' || r==='/favicon.ico' || r==='/asset-manifest.json';
        function normalizeBase(up){
          if (!up) return '';
          if (up.includes('$')){
            const m = up.match(/\$[A-Za-z_][A-Za-z0-9_]*/);
            if (m && m[0]) return m[0];
            return up.replace(/^https?:\/\//,'').split('/')[0];
          }
          try{ const u=new URL(up.startsWith('http')?up:`http://${up}`); return `${u.protocol}//${u.hostname}${u.port?`:${u.port}`:''}`; }catch{ return up.replace(/\/$/,''); }
        }
        // buildGroupsByBase function removed - duplicate definition, now defined inside rebuildApps()
        // Distribute routes by their source file (single pass)
        // Note: avoid duplicating entries across sources
        // meta is keyed by route; each value contains its sourceFile

        // Provide early stub so Diagnose clicks before assistant init are queued
        try{
          if (!window.runCalliopeHealth){
            window.runCalliopeHealth = function(route){
              try{ const d = document.getElementById('aiDrawer'); if (d){ d.classList.remove('collapsed'); document.body.classList.add('ai-open'); } }catch{}
              window.__pendingDiagnoseRoute = route || null;
            };
          }
        }catch{}

        // Show conflict management section if there are conflicts
        showConflictManagement(routes);
        
        // Add global conflict status indicator
        updateGlobalConflictIndicator(routes);

          // Start Calliope UI immediately so Diagnose clicks work even while apps load
          try { initAiAssistant(); } catch (e) { /* non-fatal */ }

          rebuildApps();
          
          // Apply masonry layout after grid is built
          setTimeout(() => applyMasonryLayout(), 100);

          // No manual ordering; default sort is by status
          try { await initAiAssistant(); } catch (e) { /* non-fatal */ }
      })().catch(err => {
        document.getElementById('apps').textContent = 'Error: '+err.message;
      });

      // Fallback: ensure Calliope tab toggles drawer even if other init fails
      try{
        document.addEventListener('click', function(e){
          try{
            const tabEl = e.target && (e.target.closest && e.target.closest('#calliopeOpen'));
            if (!tabEl) return;
            e.preventDefault();
            e.stopPropagation();
            const drawer = document.getElementById('aiDrawer');
            if (!drawer) return;
            const isCollapsed = drawer.classList.contains('collapsed');
            if (isCollapsed){
              drawer.classList.remove('collapsed');
              document.body.classList.add('ai-open');
              // Save state
              try { localStorage.setItem('dtpCalliopeOpen', 'true'); } catch {}
              // Position drawer correctly when opening
              setTimeout(() => {
                const headers = document.querySelectorAll('header');
                let header = null;
                for (const h of headers) {
                  const style = getComputedStyle(h);
                  if (style.display !== 'none' && style.visibility !== 'hidden') {
                    header = h;
                    break;
                  }
                }
                const topGap = 16;
                const h = (header && header.offsetHeight) ? header.offsetHeight : 72;
                const top = h + topGap;
                drawer.style.top = top + 'px';
                drawer.style.height = `calc(100vh - ${top + topGap}px)`;
              }, 50);
            } else {
              drawer.classList.add('collapsed');
              document.body.classList.remove('ai-open');
              // Save state
              try { localStorage.setItem('dtpCalliopeOpen', 'false'); } catch {}
            }
            // Update button state
            const nowOpen = !drawer.classList.contains('collapsed');
            tabEl.classList.toggle('active', nowOpen);
            tabEl.setAttribute('aria-pressed', String(nowOpen));
            tabEl.setAttribute('title', nowOpen ? 'Close Calliope' : 'Open Calliope');
          }catch{}
        }, true);
      }catch{}

      // Controls wiring
      (function initControls(){
        const sortEl=document.getElementById('sortMode');
        const groupByEl=document.getElementById('groupByMode');
        const filterEl=document.getElementById('routeFilter');
        const selfCheckBtn=document.getElementById('aiSelfCheckGlobal');
        preferences = loadPrefs();
        if (groupByEl){
          const groupPref = preferences.groupByMode || 'none';
          groupByEl.value = groupPref;
          groupByEl.addEventListener('change',(e)=>{ preferences.groupByMode=e.target.value; savePrefs(preferences); rebuildApps(); setTimeout(() => { applyMasonryLayout(); try { if (typeof window.toggleCalliopeAffordances === 'function') window.toggleCalliopeAffordances(true); } catch(e) {} }, 100); });
        }
        if (sortEl){
          const pref = (preferences.sortMode==='manual') ? 'status' : (preferences.sortMode||'status');
          sortEl.value = pref;
          sortEl.addEventListener('change',(e)=>{ preferences.sortMode=e.target.value; savePrefs(preferences); rebuildApps(); setTimeout(() => { applyMasonryLayout(); try { if (typeof window.toggleCalliopeAffordances === 'function') window.toggleCalliopeAffordances(true); } catch(e) {} }, 100); });
        }
        if (filterEl){
          if (preferences.filter) filterEl.value=preferences.filter;
          const debounced = debounce(()=>{ savePrefs(preferences); rebuildApps(); setTimeout(() => { applyMasonryLayout(); try { if (typeof window.toggleCalliopeAffordances === 'function') window.toggleCalliopeAffordances(true); } catch(e) {} }, 100); }, 250);
          filterEl.addEventListener('input',(e)=>{ preferences.filter=e.target.value; debounced(); });
        }
        
        // Reapply masonry on window resize
        window.addEventListener('resize', debounce(() => { applyMasonryLayout(); }, 300));
        if (selfCheckBtn){
          selfCheckBtn.addEventListener('click', ()=>{
            try{
              // Mark intent so init can honor it if handler isn't ready yet
              window.__pendingSelfCheck = true;
              // Try immediately if available; otherwise pending flag will trigger later
              if (window.CalliopeUI && window.CalliopeUI.greetAndSelfCheck){
                window.CalliopeUI.greetAndSelfCheck();
                window.__pendingSelfCheck = false;
              }
            }catch{}
          });
        }
      })();

      // Reload configurations functionality
      async function reloadConfigs() {
        const reloadBtn = document.getElementById('reloadConfigs');
        const originalText = reloadBtn.textContent;
        
        try {
          // Show loading state
          reloadBtn.textContent = 'üîÑ Reloading...';
          reloadBtn.disabled = true;
          
          // Force refresh of routes.json with cache busting (no API endpoint exists for scan-apps)
          let scanSuccess = false;
          const timestamp = Date.now();
          const freshRoutes = await fetch(`/routes.json?_t=${timestamp}`, {
            headers: { 'ngrok-skip-browser-warning': 'true' },
            cache: 'no-cache'
          });
          if (freshRoutes.ok) {
            scanSuccess = true;
            logInfo('‚úÖ Routes data refreshed');
          }
          
          if (scanSuccess) {
            // Success feedback
            reloadBtn.textContent = '‚úÖ Reloaded!';
            reloadBtn.style.background = '#16402b';
            reloadBtn.style.borderColor = '#2a7f54';
            reloadBtn.style.color = '#a6f3cc';
            
            // Reload the page after short delay to show success
            setTimeout(() => {
              location.reload();
            }, 1000);
          } else {
            throw new Error('Unable to reload configs');
          }
          
        } catch (error) {
          console.error('Config reload failed:', error);
          
          // Error feedback
          reloadBtn.textContent = '‚ùå Failed - Try Manual';
          reloadBtn.style.background = 'rgba(239,68,68,.15)';
          reloadBtn.style.borderColor = '#ef4444';
          reloadBtn.style.color = '#ef4444';
          
          // Show manual instructions
          const instructions = `
To reload manually, run:
node test/scanApps.js
./scripts/smart-build.sh

Or check if config files have syntax errors.
          `.trim();
          
          setTimeout(() => {
            if (confirm(`Automatic reload failed.\n\n${instructions}\n\nWould you like to refresh the page anyway to check if configs were updated externally?`)) {
              location.reload();
            }
          }, 1500);
        }
        
        // Reset button after delay
        setTimeout(() => {
          reloadBtn.textContent = originalText;
          reloadBtn.disabled = false;
          reloadBtn.style.background = '';
          reloadBtn.style.borderColor = '';
          reloadBtn.style.color = '';
        }, 3000);
      }

      // Wire up reload button
      document.getElementById('reloadConfigs').addEventListener('click', reloadConfigs);

      // View JSON for specific source file
      function viewSourceJson(sourceFile, routesInSource) {
        const filteredData = {
          sourceFile: sourceFile,
          routes: {},
          metadata: {},
          generatedAt: routesData.generatedAt,
          ngrok: routesData.ngrok
        };
        
        // Filter routes data to only include routes from this source
        const targetsArr = Object.keys(routesData.summary || {});
        targetsArr.forEach(target => {
          filteredData.routes[target] = {};
          if (routesData.summary && routesData.summary[target]) {
            routesInSource.forEach(route => {
              if (routesData.summary[target][route]) {
                filteredData.routes[target][route] = routesData.summary[target][route];
              }
            });
          }
        });
        
        // Filter metadata to only include routes from this source
        if (routesData.metadata) {
          routesInSource.forEach(route => {
            if (routesData.metadata[route]) {
              filteredData.metadata[route] = routesData.metadata[route];
            }
          });
        }
        
        const modal = document.createElement('div');
        modal.className = 'backdrop';
        modal.innerHTML = `
          <div class="modal large">
            <h2>JSON Data for ${sourceFile}</h2>
            <div class="section">
              <h3>Filtered Routes & Metadata</h3>
              <p>Showing only routes from <strong>${sourceFile}</strong> (${routesInSource.length} routes)</p>
              <pre class="config-display">${JSON.stringify(filteredData, null, 2)}</pre>
            </div>
            <div class="toolbar">
              <button class="btn" onclick="navigator.clipboard.writeText('${JSON.stringify(filteredData, null, 2).replace(/'/g, "\\'")}').then(() => this.textContent = 'Copied!').then(() => setTimeout(() => this.textContent = 'Copy JSON', 1500))">Copy JSON</button>
              <button class="btn" onclick="this.closest('.backdrop').remove()">Close</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
      }

      // Conflict Management Functions
      function showConflictManagement(routes) {
        const conflictCard = document.getElementById('conflictCard');
        const conflictsDiv = document.getElementById('conflicts');
        
        const hasConflicts = (routes.nginxWarnings && routes.nginxWarnings.length > 0) || 
                            (routes.conflictSummary && routes.conflictSummary.totalConflicts > 0);
        // Hide indicator if user acknowledged
        try{ const ack = JSON.parse(localStorage.getItem('conflictsAck')||'null'); if (ack && ack.ts) return; }catch{}
        
        // Respect local acknowledgement to dismiss banner/content block
        try{
          const ack = JSON.parse(localStorage.getItem('conflictsAck')||'null');
          if (ack && ack.ts && (Date.now() - ack.ts < 7*24*3600*1000)){
            conflictCard.classList.add('hidden');
            return;
          }
        }catch{}
        if (!hasConflicts) { conflictCard.classList.add('hidden'); return; }
        
        conflictCard.classList.remove('hidden');
        // Add a one-time acknowledge button
        const ackBtn = document.createElement('button');
        ackBtn.className = 'btn';
        ackBtn.textContent = 'Acknowledge';
        ackBtn.onclick = ()=>{ try{ localStorage.setItem('conflictsAck', JSON.stringify({ ts: Date.now() })); }catch{} conflictCard.classList.add('hidden'); };
        const header = conflictCard.querySelector('h2');
        if (header && !conflictCard.querySelector('.btn.ack')){ header.appendChild(document.createTextNode(' ')); header.appendChild(ackBtn); ackBtn.classList.add('ack'); }
        conflictsDiv.innerHTML = '';
        
        // Parse nginx warnings to extract conflict information
        const conflicts = parseConflictWarnings(routes.nginxWarnings || []);
        
        conflicts.forEach(conflict => {
          const conflictDiv = document.createElement('div');
          conflictDiv.className = 'conflict-item';
          conflictDiv.innerHTML = `
            <div class="conflict-header">
              <h3>Route: ${conflict.route}</h3>
              <div class="conflict-status">
                Current winner: <strong>${conflict.winner}</strong>
              </div>
            </div>
            <div class="conflict-options">
              <div class="conflict-configs">
                ${conflict.configs.map(config => `
                  <label class="config-option ${config === conflict.winner ? 'active' : ''}">
                    <input type="radio" name="conflict-${conflict.route}" value="${config}" ${config === conflict.winner ? 'checked' : ''}>
                    <span class="config-name">${config.replace(/\.conf$/, '')}</span>
                    <div class="config-actions">
                      <button class="btn-small" onclick="viewConfig('${config}')">View</button>
                      <button class="btn-small" onclick="renameRoute('${conflict.route}', '${config}')">Rename Route</button>
                    </div>
                  </label>
                `).join('')}
              </div>
              <div class="conflict-actions">
                <button class="btn" onclick="resolveConflict('${conflict.route}')">Apply Selection</button>
                <button class="btn" onclick="autoFixConflict('${conflict.route}')">Auto-Fix</button>
              </div>
            </div>
          `;
          conflictsDiv.appendChild(conflictDiv);
        });
      }

      function parseConflictWarnings(warnings) {
        const conflicts = [];
        warnings.forEach(warning => {
          // Parse warning like: "Route /api/: NEW CONFLICT - app2.conf wins (first config) over test-conflict.conf"
          const routeMatch = warning.match(/Route ([^:]+):/);
          const winnerMatch = warning.match(/- ([^\\s]+)\\.conf wins.*over ([^\\s,]+(?:\\.conf)?)/);
          
          if (routeMatch && winnerMatch) {
            const route = routeMatch[1];
            const winner = winnerMatch[1] + '.conf';
            const loser = winnerMatch[2].endsWith('.conf') ? winnerMatch[2] : winnerMatch[2] + '.conf';
            
            conflicts.push({
              route,
              winner,
              configs: [winner, loser]
            });
          }
        });
        return conflicts;
      }

      async function resolveConflict(route) {
        const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
        if (!selectedRadio) return;
        
        const newWinner = selectedRadio.value;
        
        try {
          const response = await fetch(window.DTP.config.apiPath('resolve-conflict'), {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ route, winner: newWinner })
          });
          
          if (response.ok) {
            // Refresh the page to show updated conflicts
            location.reload();
          } else {
            alert('Failed to resolve conflict. Check console for details.');
          }
        } catch (error) {
          alert('Error resolving conflict: ' + error.message);
        }
      }

      function viewConfig(configFile) {
        openConfigModal(configFile);
      }

      function renameRoute(route, configFile) {
        const newRoute = prompt(`Rename route ${route} in ${configFile} to:`, route);
        if (newRoute && newRoute !== route) {
          renameRouteInConfig(route, newRoute, configFile);
        }
      }

      function autoFixConflict(route) {
        // Smart auto-fix suggestions based on route type
        const suggestions = getAutoFixSuggestions(route);
        
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2>Auto-Fix Suggestions for ${route}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <p>Here are intelligent suggestions to resolve this conflict:</p>
              ${suggestions.map(s => `
                <div class="suggestion-item">
                  <h3>${s.title}</h3>
                  <p>${s.description}</p>
                  <code>${s.example}</code>
                  <button class="btn" onclick="applySuggestion('${route}', '${s.action}', '${s.params}')">Apply This Fix</button>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }

      function getAutoFixSuggestions(route) {
        const suggestions = [];
        
        if (route === '/api/') {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Rename one route to be app-specific',
            example: 'location /myapp/api/ { ... }',
            action: 'rename',
            params: '/myapp/api/'
          });
          suggestions.push({
            title: 'Use Versioned API',
            description: 'Add version to make routes unique',
            example: 'location /api/v1/ { ... }',
            action: 'rename', 
            params: '/api/v1/'
          });
        } else if (route === '/admin/') {
          suggestions.push({
            title: 'App-Specific Admin',
            description: 'Make admin path unique to your app',
            example: 'location /myapp/admin/ { ... }',
            action: 'rename',
            params: route.replace('/admin/', '/myapp/admin/')
          });
        } else {
          suggestions.push({
            title: 'Add App Prefix',
            description: 'Prepend your app name to make the route unique',
            example: `location /myapp${route} { ... }`,
            action: 'rename',
            params: `/myapp${route}`
          });
        }
        
        suggestions.push({
          title: 'Let First Config Win', 
          description: 'Keep the current winner, no changes needed',
          example: 'No configuration changes required',
          action: 'accept',
          params: ''
        });
        
        return suggestions;
      }

      async function applySuggestion(route, action, params) {
        if (action === 'accept') {
          document.querySelector('.modal').remove();
          return;
        }
        
        if (action === 'rename') {
          const selectedRadio = document.querySelector(`input[name="conflict-${route}"]:checked`);
          if (!selectedRadio) {
            alert('Please select a config file first');
            return;
          }
          
          const configFile = selectedRadio.value;
          await renameRouteInConfig(route, params, configFile);
          document.querySelector('.modal').remove();
        }
      }

      async function renameRouteInConfig(oldRoute, newRoute, configFile) {
        try {
          const response = await fetch(window.DTP.config.apiPath('rename-route'), {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ oldRoute, newRoute, configFile })
          });
          
          if (response.ok) {
            alert(`Route renamed successfully. Please restart the proxy for changes to take effect.`);
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to rename route: ' + error);
          }
        } catch (error) {
          alert('Error renaming route: ' + error.message);
        }
      }

      function openConfigModal(configFile) {
        // Create and show config viewing modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
          <div class="modal-content large">
            <div class="modal-header">
              <h2>Config File: ${configFile}</h2>
              <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
            </div>
            <div class="modal-body">
              <div class="config-actions">
                <button class="btn" onclick="downloadConfig('${configFile}')">Download</button>
                <button class="btn" onclick="enableConfigEdit(this)">Edit</button>
              </div>
              <pre id="config-content" class="config-display">Loading...</pre>
              <textarea id="config-editor" class="config-editor hidden" rows="30"></textarea>
              <div class="edit-actions hidden">
                <button class="btn" onclick="saveConfig('${configFile}')">Save Changes</button>
                <button class="btn" onclick="cancelConfigEdit()">Cancel</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        loadConfigContent(configFile);
      }

      async function loadConfigContent(configFile) {
        try {
          const response = await fetch(`/devproxy/api/config/${configFile}`);
          const content = await response.text();
          
          if (response.ok) {
            document.getElementById('config-content').textContent = content;
            document.getElementById('config-editor').value = content;
          } else {
            document.getElementById('config-content').textContent = `Error loading config: ${content}`;
          }
        } catch (error) {
          document.getElementById('config-content').textContent = `Error: ${error.message}`;
        }
      }

      function enableConfigEdit(button) {
        document.getElementById('config-content').classList.add('hidden');
        document.getElementById('config-editor').classList.remove('hidden');
        document.querySelector('.edit-actions').classList.remove('hidden');
        button.style.display = 'none';
      }

      function cancelConfigEdit() {
        document.getElementById('config-content').classList.remove('hidden');
        document.getElementById('config-editor').classList.add('hidden');
        document.querySelector('.edit-actions').classList.add('hidden');
        document.querySelector('.config-actions button:nth-child(2)').style.display = '';
      }

      async function saveConfig(configFile) {
        const content = document.getElementById('config-editor').value;
        
        try {
          const response = await fetch(`/devproxy/api/config/${configFile}`, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: content
          });
          
          if (response.ok) {
            alert('Config saved successfully. Restart the proxy for changes to take effect.');
            document.querySelector('.modal').remove();
            location.reload();
          } else {
            const error = await response.text();
            alert('Failed to save config: ' + error);
          }
        } catch (error) {
          alert('Error saving config: ' + error.message);
        }
      }

      function downloadConfig(configFile) {
        const content = document.getElementById('config-content').textContent;
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = configFile;
        a.click();
        URL.revokeObjectURL(url);
      }

      function updateGlobalConflictIndicator(_routes) {
        // Permanently disable the floating conflict banner
        const existing = document.querySelector('.global-conflict-indicator');
        if (existing) existing.remove();
        return;
      }

      function applySeverityToApp(appElement, route, targets, routes) {
        const severity = severityOf(route, targets, routes);
        appElement.classList.add(severity);
      }

      // Modal logic
      function openDiagnoseModal(routeKey, targets, routes){
        // If Calliope is enabled, she overrides manual diagnose with her health flow
        if (document.body.classList.contains('calliope-enabled')){
          try { runCalliopeHealth(routeKey); } catch(e){}
          return;
        }
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Diagnose: <code>${routeKey}</code></h2>
          <div class="section"><h3>Detected Issues</h3><div id="issues"></div></div>
          <div class="section"><h3>Suggested Nginx Snippet</h3><pre id="snippet"></pre></div>
          <div class="section"><h3>Repair Commands</h3><pre id="commands"></pre></div>
          <div class="toolbar"><button class="btn" id="copySnippet">Copy snippet</button><button class="btn" id="copyCmds">Copy commands</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Build issues list
        const issues = [];
        for (const t of targets){
          const info = (routes.summary?.[t]||{})[routeKey];
          if (!info) continue;
          const status = info.status||0;
          if (!(status>=200 && status<300)) issues.push(`${t}: HTTP ${status}`);
          // Note: API conflict detection removed
          if (info.websocket && !info.websocket.ok) issues.push(`${t}: websocket upgrade failed`);
        }
        if (!issues.length) issues.push('No obvious issues detected.');
        modal.querySelector('#issues').innerHTML = `<ul>${issues.map(i=>`<li>${i}</li>`).join('')}</ul>`;

        // Build snippet template
        const name = routeKey.replace(/^\/(.*?)\/?$/, '$1');
        let snippet='';
        if (routeKey === '/api/') {
          snippet = `# Preserve /api prefix to upstream service\nlocation /api/ {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://SERVICE_ALIAS:PORT;\n}`;
        } else if (/^\/[A-Za-z0-9_-]+\/$/.test(routeKey)) {
          snippet = `# Keep prefix, enable HMR\nlocation = ${routeKey.slice(0,-1)} { rewrite ^ ${routeKey} last; }\nlocation ^~ ${routeKey}_next/ {\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection "upgrade";\n  proxy_pass http://${name}-app:2000${routeKey}_next/;\n}\nlocation ^~ ${routeKey} {\n  proxy_http_version 1.1;\n  proxy_set_header Host $host;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header X-Forwarded-Host $host;\n  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n  proxy_set_header X-Forwarded-Prefix ${routeKey.slice(0,-1)};\n  proxy_read_timeout 300;\n  proxy_send_timeout 300;\n  proxy_pass http://${name}-app:2000${routeKey};\n}`;
        } else {
          snippet = `# Example mapping\nlocation ^~ ${routeKey} {\n  proxy_pass http://SERVICE_ALIAS:PORT${routeKey};\n}`;
        }
        modal.querySelector('#snippet').textContent = snippet;

        // Commands
        const cmd = `# Copy snippet to apps/${name||'myapp'}.conf and reload\n./scripts/install-app.sh ${name||'myapp'} examples/next/myapp.conf || true\n# Or place the generated snippet into apps/${name||'myapp'}.conf then:\ndocker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#commands').textContent = cmd;

        // Copy handlers
        modal.querySelector('#copySnippet').addEventListener('click',()=>{
          navigator.clipboard.writeText(snippet);
        });
        modal.querySelector('#copyCmds').addEventListener('click',()=>{
          navigator.clipboard.writeText(cmd);
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }

      // Recommend modal ‚Äì aggregates issues and provides generic fixes/snippets
      function openRecommendModal(routes, onlyRoutes){
        const targets = Object.keys(routes.summary||{});
        const bd = document.createElement('div');
        bd.className='backdrop';
        const modal = document.createElement('div');
        modal.className='modal';
        modal.innerHTML = `<h2>Recommendations</h2>
          <div class=\"section\"><h3>Detected Issues</h3><div id=\"issues\"></div></div>
          <div class="section"><h3>Standard Fixes</h3><ul id="fixes"></ul></div>
          <div class="section"><h3>Snippets</h3>
            <p><strong>Keep prefix (Next.js basePath)</strong></p>
            <pre id="snKeep"></pre>
            <p><strong>Strip prefix (CRA/Storybook)</strong></p>
            <pre id="snStrip"></pre>
            <p><strong>Preserve /api prefix</strong></p>
            <pre id="snApi"></pre>
          </div>
          <div class="section"><h3>Commands</h3><pre id="cmds"></pre></div>
          <div class="toolbar"><button class="btn" id="copyAll">Copy all</button><button class="btn" id="close">Close</button></div>`;
        bd.appendChild(modal);
        document.body.appendChild(bd);

        // Group issues by endpoint for readability
        const issuesByRoute = {};
        targets.forEach(t=>{
          const m = routes.summary[t]||{};
          const routeKeys = onlyRoutes && onlyRoutes.length ? onlyRoutes : Object.keys(m);
          routeKeys.forEach(r=>{
            const info = m[r]||{};
            const st = info.status||0;
            const msgs = [];
            if (!(st>=200 && st<300)) msgs.push(`${t}: HTTP ${st}`);
            if (info.websocket && !info.websocket.ok) msgs.push(`${t}: websocket upgrade failed`);
            // Only flag API ownership conflicts if owned by different config
            // Note: API conflict detection removed
            if (msgs.length) {
              issuesByRoute[r] = issuesByRoute[r] || [];
              issuesByRoute[r].push(...msgs);
            }
          });
        });
        const blocks = Object.keys(issuesByRoute).sort().map(r => `<div class=\"section\"><h3>${r}</h3><ul>${issuesByRoute[r].map(i=>`<li>${i}</li>`).join('')}</ul></div>`);
        modal.querySelector('#issues').innerHTML = blocks.length ? blocks.join('') : '<p>No warnings/errors detected.</p>';

        const fixes = [
          'Ensure all dev services join the external "devproxy" network and use service aliases as upstream hosts.',
          'Avoid proxy_pass variables for dev routes; use fixed upstreams. Use trailing slash to strip prefix when needed.',
          'For HMR: set proxy_http_version 1.1 and Upgrade/Connection headers on prefix routes.',
          'For Next.js behind a path: run a basePath-aware dev instance and DO NOT strip the prefix in the proxy.',
          'For CRA/Storybook behind a path: strip the prefix with trailing-slash proxy_pass and configure PUBLIC_URL or builder base/publicPath.',
          'If multiple projects share /api, keep /api mapped to the API app and ensure other apps call a prefixed API or separate domain.',
        ];
        modal.querySelector('#fixes').innerHTML = fixes.map(f=>`<li>${f}</li>`).join('');

        const snKeep = `# Keep prefix (Next.js basePath example)
location = /myapp { rewrite ^ /myapp/ last; }
location ^~ /myapp/_next/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_pass http://myapp-app:2000/myapp/_next/;
}
location ^~ /myapp/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Prefix /myapp;
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://myapp-app:2000/myapp/;
}`;

        const snStrip = `# Strip prefix (CRA/Storybook example)
location ^~ /ui/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://ui-app:3000/;  # trailing slash strips /ui/
}`;

        const snApi = `# Preserve /api prefix to API upstream
location /api/ {
  proxy_http_version 1.1;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 300; proxy_send_timeout 300;
  proxy_pass http://api-app:8000;
}`;

        modal.querySelector('#snKeep').textContent = snKeep;
        modal.querySelector('#snStrip').textContent = snStrip;
        modal.querySelector('#snApi').textContent = snApi;

        const cmds = `# Re-scan and update status JSON
node ./test/scanApps.js

# Install a snippet into apps/<name>.conf and reload
./scripts/install-app.sh myapp examples/next/myapp.conf || true
docker exec dev-proxy nginx -t && docker exec dev-proxy nginx -s reload`;
        modal.querySelector('#cmds').textContent = cmds;

        const copyAllBtn = modal.querySelector('#copyAll');
        modal.querySelector('#copyAll').addEventListener('click',()=>{
          const all = [snKeep, snStrip, snApi, cmds].join('\n\n');
          navigator.clipboard.writeText(all).then(()=>{
            copyAllBtn.classList.add('copied');
            const prev = copyAllBtn.textContent;
            copyAllBtn.textContent = 'Copied!';
            setTimeout(()=>{ copyAllBtn.textContent = prev; copyAllBtn.classList.remove('copied'); }, 1500);
          });
        });
        const close = ()=>{ document.body.removeChild(bd); };
        modal.querySelector('#close').addEventListener('click', close);
        bd.addEventListener('click', (e)=>{ if (e.target===bd) close(); });
        window.addEventListener('keydown', (e)=>{ if (e.key==='Escape') close(); }, { once:true });
      }
      (function wireTheme(){ try{ (document.getElementById('themeToggle')||document.getElementById('themeToggleFallback')).addEventListener('click', toggleTheme); }catch{} })();
      initTheme();

      // ===== AI Assistant Wiring =====
      // Healing History Management
      let healingHistory = [];
      let isHealing = false;
      
      async function loadHealingHistory() {
        try {
          const response = await fetch('/.artifacts/calliope/healing-log.json');
          if (response.ok) {
            const data = await response.json();
            healingHistory = data.entries || [];
            updateHealingUI();
          } else {
          logDebug('No healing history found');
          }
        } catch (e) {
          logError('Error loading healing history', e);
        }
      }
      
      function updateHealingUI() {
        const badge = document.getElementById('healingBadge');
        if (!badge) return; // guard if badge not present
        const countEl = badge.querySelector('.healing-count');
        if (!countEl) return; // guard if inner element missing
        const count = healingHistory.length;
        
        // Update badge
        countEl.textContent = count > 99 ? '99+' : count;
        badge.style.display = count > 0 ? 'flex' : 'none';
        
        // Update healing status in header (ensure chip is visible and prominent)
        const statusEl = document.getElementById('aiHealingStatus');
        const statusLabelEl = document.getElementById('aiHealingStatusLabel');
        const countHeaderEl = document.getElementById('aiHealingCount');
        try{ 
          if (statusEl){
            statusEl.style.display = 'inline-flex'; 
            statusEl.style.visibility = 'visible';
            statusEl.style.opacity = '1';
          }
        }catch{}
        
        // Only adjust label if not overridden by refreshHealth state mapping
        if (isHealing && statusEl && statusLabelEl) {
          statusEl.classList.remove('status-ready','status-auditing','status-coding','status-offline');
          statusEl.classList.add('status-healing');
          statusLabelEl.textContent = 'üòµ‚Äçüí´ Confused';
        }
        
        if (countHeaderEl) countHeaderEl.textContent = count > 0 ? `(${count})` : '';
        
        // Update history panel UI
        const historyList = document.getElementById('healingHistoryList');
        if (!historyList) return; // guard if panel not present
        
        if (count === 0) {
          historyList.innerHTML = '<div class="empty-history">No healing actions recorded yet.</div>';
          return;
        }
        
        historyList.innerHTML = '';
        
        // Show most recent entries first (limit 10 per spec)
        const recentEntries = [...healingHistory].reverse().slice(0, 10);
        
        recentEntries.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = `healing-entry ${entry.success ? 'success' : 'failure'}`;
          
          const header = document.createElement('div');
          header.className = 'healing-entry-header';
          
          const issue = document.createElement('div');
          issue.className = 'healing-entry-issue';
          issue.textContent = entry.issue || 'Unknown issue';
          
          const timestamp = document.createElement('div');
          timestamp.className = 'healing-entry-timestamp';
          timestamp.textContent = new Date(entry.timestamp).toLocaleString();
          
          header.appendChild(issue);
          header.appendChild(timestamp);
          
          const details = document.createElement('div');
          details.className = 'healing-entry-details';
          
          if (entry.success) {
            details.textContent = `Successfully applied ${entry.solution}`;
          } else {
            details.textContent = entry.details?.error || 'Failed to heal';
          }
          
          const actions = document.createElement('div');
          actions.className = 'healing-entry-actions';
          
          const viewBtn = document.createElement('button');
          viewBtn.textContent = 'View Details';
          viewBtn.addEventListener('click', () => {
            // Open a modal with details
            const detailsStr = JSON.stringify(entry.details || {}, null, 2);
            alert(`Healing Details:\n${detailsStr}`);
          });
          
          actions.appendChild(viewBtn);
          
          entryEl.appendChild(header);
          entryEl.appendChild(details);
          entryEl.appendChild(actions);
          
          historyList.appendChild(entryEl);
          try{
            const summary = [
              `Healed ${entry.route||''} ${entry.success?'‚úÖ':'‚ùå'}`.trim(),
              entry.actions && entry.actions.length ? `Steps: ${entry.actions.join(', ')}` : null,
              entry.details ? `Notes: ${entry.details}` : null,
            ].filter(Boolean).join('\n');
            if (summary){ appendBubble('assistant', summary); }
          }catch{}
        });
      }
      
      async function runSelfHeal() {
        if (isHealing) return;
        
        isHealing = true;
        updateHealingUI();
        
        try {
          // Append a message showing we're starting healing
          appendBubble('assistant', `<img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:16px;height:16px;vertical-align:middle;"> Starting self-healing process... This might take a moment.`);
          
          const thinking = appendThinking();
          
          // Call the advanced healing API
          const response = await fetch(window.DTP.config.apiPath('ai/advanced-heal'), {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
          });
          
          thinking.remove();
          
          if (response.ok) {
            const result = await response.json();
            
            // Format the result as a message
            let message = '‚ú® Self-healing complete!\n\n';
            
            if (result.result.success) {
              message += `${result.result.message || 'The healing was successful.'}\n\n`;
              
              if (result.result.steps) {
                message += 'Steps performed:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}\n`;
                });
              }
              
              if (result.result.appliedStrategies && result.result.appliedStrategies.length > 0) {
                message += '\nApplied strategies:\n';
                result.result.appliedStrategies.forEach(strategy => {
                  message += `- ${strategy.issue}: ${strategy.result.message || strategy.result.success ? 'Success' : 'Failed'}\n`;
                });
              }
              
              message += '\nYour proxy should be working correctly now!';
            } else {
              message += 'The healing process encountered some issues.\n\n';
              
              if (result.result.error) {
                message += `Error: ${result.result.error}\n\n`;
              }
              
              if (result.result.steps) {
                message += 'Steps attempted:\n';
                result.result.steps.forEach(step => {
                  message += `- ${step.name}: ${step.status}${step.error ? ` (${step.error})` : ''}\n`;
                });
              }
              
              message += '\nYou might need to manually fix some issues.';
            }
            
            appendBubble('assistant', message);
            
            // Refresh healing history after a delay
            setTimeout(() => {
              loadHealingHistory();
            }, 2000);
            
          } else {
            const errorText = await response.text();
            appendBubble('assistant', `‚ùå Self-healing failed: ${errorText || response.statusText}`);
          }
        } catch (e) {
          appendBubble('assistant', `‚ùå Error during self-healing: ${e.message}`);
        } finally {
          isHealing = false;
          updateHealingUI();
        }
      }
      
      async function initAiAssistant(){
        const drawer = document.getElementById('aiDrawer');
        const tab = document.getElementById('calliopeOpen');
        const statusEl = document.getElementById('aiStatus');
        const indexEl = document.getElementById('aiIndex');
        const chatEl = document.getElementById('aiChat');
        const askBtn = document.getElementById('aiAskBtn');
        const clearBtn = document.getElementById('aiClearBtn');
        const copyBtn = document.getElementById('aiCopyBtn');
        const healBtn = document.getElementById('aiHealBtn');
        const queryEl = document.getElementById('aiQuery');
        // Persisted chat history loader
        async function loadChatHistory(){
          try{
            const resp = await fetch(window.DTP.config.apiPath('ai/chat-history'), { credentials: 'include' });
            if (!resp.ok) return;
            const data = await resp.json().catch(()=>null);
            const messages = (data && data.messages) || [];
            // Render last 100 to keep UI snappy
            const recent = messages.slice(-100);
            recent.forEach(m => {
              const who = (m.role === 'assistant') ? 'assistant' : 'user';
              appendBubble(who, m.content||'');
            });
          }catch{}
        }

        // Wire the drawer Self‚ÄëCheck button to trigger a self-check heal
        try{
          if (healBtn){
            healBtn.addEventListener('click', ()=>{
              try{
                (window.CalliopeUI && window.CalliopeUI.greetAndSelfCheck) ? window.CalliopeUI.greetAndSelfCheck() : window.dispatchEvent(new CustomEvent('calliope:self-check'));
              }catch{}
            });
          }
        }catch{}

        // Header Self‚ÄëCheck flow implemented here so chat helpers are in scope
        window.addEventListener('calliope:self-check', ()=>{ try{ (window.CalliopeUI && window.CalliopeUI.greetAndSelfCheck) && window.CalliopeUI.greetAndSelfCheck(); }catch{} });

        // Thought polling for progress breadcrumbing
        let thoughtsTimer = null;
        let healthTimer = null;
        let chatEngaged = false; // set true after first user action or diagnose
        let hasUserMessage = false; // guarantees first visible bubble can be user
        const seenThoughtIds = new Set();
        const recentThoughtTexts = [];
        function recordThoughtSeen(ev){
          const id = ev && (ev.id || ev.ts || ev.message);
          if (id) seenThoughtIds.add(String(id));
          const msg = ev && ev.message ? String(ev.message) : '';
          if (msg){
            recentThoughtTexts.push(msg);
            if (recentThoughtTexts.length > 50) recentThoughtTexts.splice(0, recentThoughtTexts.length - 50);
          }
        }
        function shouldDisplayThought(ev){
          const id = ev && (ev.id || ev.ts || ev.message);
          if (id && seenThoughtIds.has(String(id))) return false;
          const msg = ev && ev.message ? String(ev.message) : '';
          if (!msg) return false;
          const last = recentThoughtTexts[recentThoughtTexts.length - 1];
          if (last && last === msg) return false;
          return true;
        }
        function startThoughtsPolling(){
          if (thoughtsTimer) return;
          thoughtsTimer = setInterval(async ()=>{
            try{
              const r = await fetch(window.DTP.config.apiPath('ai/thoughts'), { credentials: 'include', headers: { 'ngrok-skip-browser-warning': 'true' }, cache: 'no-cache' });
              if (!r.ok) return;
              const d = await r.json().catch(()=>null);
              const evs = (d && d.events) || [];
              evs.forEach(ev => {
                if (!shouldDisplayThought(ev)) { recordThoughtSeen(ev); return; }
                const msg = (ev && ev.message) ? String(ev.message) : '';
                const det = ev && ev.details || {};
                if (msg) {
                  logDebug('[Calliope][thought]', msg, det);
                  try{
                    if (msg !== 'status'){
                      // Show streamed thoughts when chat is engaged or empty (initial state)
                      const haveUserMsg = !!(document.getElementById('aiChat')?.querySelector('.bubble.user'));
                      if (chatEngaged || !haveUserMsg) {
                        const lastAssistant = document.querySelector('#aiChat .bubble.assistant:last-of-type');
                        const isThinking = lastAssistant && lastAssistant.classList.contains('thinking');
                        if (!isThinking){
                          appendBubble('assistant', personaWrap(msg));
                        }
                      }
                    }
                  }catch{}
                }
                // Map thought tags to status chip state heuristically
              const statusChip = document.getElementById('aiHealingStatus');
              const labelEl = document.getElementById('aiHealingStatusLabel');
              const lower = msg.toLowerCase();
              const setState = (cls, text)=>{
                  if (statusChip) {
                    statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding','status-offline');
                    statusChip.classList.add(cls);
                  }
                  if (labelEl) labelEl.textContent = text;
              };
              // If backend emits a dedicated status event with a chip hint, honor it
              if (msg === 'status' && det && det.chip){
                const chip = String(det.chip||'').toLowerCase();
                if (chip==='healing') setState('status-healing','üíñ Healing');
                else if (chip==='auditing') setState('status-auditing','üî¨ Auditing');
                else if (chip==='coding') setState('status-coding','üõ†Ô∏è Coding');
                else if (chip==='happy' || chip==='ready' || chip==='idle') setState('status-ready','üòä Happy');
                else if (chip==='offline') setState('status-offline','Offline');
              } else {
                if (/working‚Ä¶|working\.\.\./.test(lower)) ; else
                if (/auditing/.test(lower) || /audit/.test(lower)) setState('status-auditing','üî¨ Auditing');
                else if (/healing/.test(lower) || /heal/.test(lower)) setState('status-healing','üíñ Healing');
                else if (/code review|snapshot|analyz|review/i.test(lower)) setState('status-coding','üõ†Ô∏è Coding');
                else if (/complete ‚úÖ|all clear|finished|done/i.test(lower)) setState('status-ready','üòä Happy');
              }
                recordThoughtSeen(ev);
              });
            }catch{}
          }, 15000);
        }

        function startHealthPolling(){
          if (healthTimer) return;
          healthTimer = setInterval(()=>{
            refreshHealth().catch((e)=>{ try{ logDebug('[Calliope][health] error', e&&e.message); }catch{} });
          }, 15000);
        }

        
        // Healing history elements (use correct IDs; avoid name collision with history array)
        const healingBadgeEl = document.getElementById('aiHealingHistory');
        const healingHistoryEl = document.getElementById('healingHistory');
        const closeHistoryBtn = document.querySelector('.close-history');

        async function refreshHealth(){
          try {
            const health = await fetch(window.DTP.config.apiPath('ai/health'));
            if (!health.ok) throw new Error('disabled');
            const healthJson = await health.json();
            if (statusEl) statusEl.textContent = healthJson.enabled ? `Enabled${healthJson.model?` (${healthJson.model})`:''}` : 'Disabled (no key)';
            // Toggle UI affordances when Calliope is enabled
            const calliopeEnabled = healthJson.enabled; // Only enable Calliope when API key is present
            window.__calliopeEnabled = calliopeEnabled;
            document.body.classList.toggle('calliope-enabled', calliopeEnabled);
            if (typeof window.toggleCalliopeAffordances === 'function') window.toggleCalliopeAffordances(calliopeEnabled);

            // Update Calliope status chip color and label
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            
            const setState = (cls, text)=>{
              if (statusChip) {
                statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding','status-offline');
                statusChip.classList.add(cls);
              }
              if (labelEl) labelEl.textContent = text;
            };

            if (!healthJson.enabled || healthJson.healthy===false){
              setState('status-offline','ü´• AFK');
            } else {
              // Prefer explicit activity if provided by API
              const activity = (healthJson.activity||'').toLowerCase();
              if (activity === 'healing') setState('status-healing','üíñ Healing');
              else if (activity === 'auditing') setState('status-auditing','üî¨ Auditing');
              else if (activity === 'coding') setState('status-coding','üõ†Ô∏è Coding');
              else setState('status-ready','üòä Happy');
            }
          } catch {
            if (statusEl) statusEl.textContent = 'Unavailable';
            // Fallback: disable Calliope UI affordances when API health check fails (no API key)
            document.body.classList.remove('calliope-enabled');
            try { if (typeof window.toggleCalliopeAffordances === 'function') window.toggleCalliopeAffordances(false); } catch(e) {}
            const statusChip = document.getElementById('aiHealingStatus');
            if (statusChip) {
              statusChip.classList.remove('status-ready','status-healing','status-auditing','status-coding');
              statusChip.classList.add('status-offline');
              const chipLabel = statusChip.querySelector('.ai-healing-label');
              if (chipLabel) chipLabel.textContent = 'Offline';
            }
          }
          try {
            const s = await fetch(window.DTP.config.apiPath('ai/stats'));
            if (s.ok){ const sj = await s.json(); if(indexEl) indexEl.textContent = sj.exists ? `${sj.chunks} chunks ‚Ä¢ ${sj.model||''}`.trim() : 'No index'; }
            else if(indexEl) indexEl.textContent = '‚Äî';
          } catch { if(indexEl) indexEl.textContent = '‚Äî'; }
        }

        window.toggleCalliopeAffordances = function(enabled){
          logDebug('üîß toggleCalliopeAffordances called with enabled:', enabled);
          
          // Hide Recommend buttons
          const recButtons = Array.from(document.querySelectorAll('a.btn, button.btn')).filter(el=>/Recommend/i.test(el.textContent||''));
          recButtons.forEach(el=> el.style.display = enabled ? 'none' : '');
          logDebug('üîß Found', recButtons.length, 'recommend buttons to hide');
          
          // NUCLEAR APPROACH: Find ANY button with stethoscope or aria-label Diagnose and override completely (exclude Calliope tab)
          const candidates = Array.from(document.querySelectorAll('button, .icon-btn')).filter(el => {
            const label = el.getAttribute('aria-label') || '';
            const text = el.textContent || '';
            return /Diagnose/i.test(label) || text.includes('Diagnose') || el.querySelector('img[src*="calliope_heart_stethoscope"]');
          });
          candidates.forEach(el => {
            if (el && (el.id === 'calliopeOpen' || (el.closest && el.closest('#calliopeOpen')))) return; // never hijack the Calliope tab
            const parent = el.parentNode; if (!parent) return;
            const clone = el.cloneNode(true);
            parent.replaceChild(clone, el);
            clone.onclick = function(e){
              e.preventDefault(); e.stopPropagation();
              const route = clone.dataset.route || clone.closest('[data-route]')?.dataset?.route;
              if (enabled){
                // When Calliope is enabled, run her health check for the specific route
                if (route) {
                  runCalliopeHealth(route);
                } else {
                  // Fallback: just open the drawer if no route is found
                  const drawer = document.getElementById('aiDrawer');
                  drawer.classList.remove('collapsed');
                  document.body.classList.add('ai-open');
                  setTimeout(()=>{ const q=document.getElementById('aiQuery'); if(q) q.focus(); },100);
                }
              } else {
                // When Calliope is disabled, use the standard diagnose modal
                if (route) openDiagnoseModal(route, targets, routes);
              }
            };
            // Update accessibility labels and titles for all stethoscope/diagnose buttons
            if (enabled){ clone.title='Calliope'; clone.setAttribute('aria-label','Calliope'); }
            else { clone.title='Diagnose'; clone.setAttribute('aria-label','Diagnose'); }
          });
        }

        // Global delegated handler to ensure Calliope runs when enabled,
        // even if buttons were (re)rendered after our overrides.
        // Uses capture phase to pre-empt older listeners.
        document.addEventListener('click', function(e){
          try{
            const enabled = !!window.__calliopeEnabled || document.body.classList.contains('calliope-enabled');
            if (!enabled) return;
            const target = e.target && (e.target.closest && e.target.closest('button, .circular-action-btn, .icon-btn'));
            if (!target) return;
            if (target && (target.id === 'calliopeOpen' || (target.closest && target.closest('#calliopeOpen')))) return; // allow tab to toggle drawer
            const label = target.getAttribute('aria-label') || '';
            const text = target.textContent || '';
            const hasStethoscope = !!target.querySelector && !!target.querySelector('img[src*="calliope_heart_stethoscope"]');
            const isDiagnoseLike = /Diagnose/i.test(label) || text.includes('Diagnose') || hasStethoscope;
            if (!isDiagnoseLike) return;

            // Determine route context robustly
            let route = null;
            const routeContainer = target.closest && target.closest('[data-route]');
            if (routeContainer && routeContainer.dataset && routeContainer.dataset.route) route = routeContainer.dataset.route;
            if (!route && target.dataset && target.dataset.route) route = target.dataset.route;
            if (!route){
              const header = target.closest && target.closest('.route-header');
              const nameEl = header && header.querySelector && header.querySelector('.route-name');
              if (nameEl && nameEl.textContent) route = nameEl.textContent.trim();
            }
            if (!route) return; // no implicit default

            // Override default behavior
            e.preventDefault();
            e.stopPropagation();
            if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();

            // Run Calliope health flow, but if not ready yet, queue it
            try {
              if (typeof runCalliopeHealth === 'function') { runCalliopeHealth(route); }
              else {
                window.__pendingDiagnoseRoute = route || null;
                const drawer = document.getElementById('aiDrawer');
                if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
              }
            } catch(err){
              const drawer = document.getElementById('aiDrawer');
              if (drawer){ drawer.classList.remove('collapsed'); document.body.classList.add('ai-open'); }
            }
          }catch(_e){ /* non-fatal */ }
        }, true);

        async function onAsk(){
          const q = (queryEl.value||'').trim();
          if (!q){ return; }
          // Mark user engagement BEFORE any possible assistant thought rendering
          if (!hasUserMessage) hasUserMessage = true;
          chatEngaged = true;
          askBtn.disabled = true; askBtn.textContent = 'Thinking‚Ä¶';
          // Clear the input immediately so the user can type next question
          queryEl.value = '';
          
          // Append user bubble first so it appears before any thinking indicator
          const firstUser = appendBubble('user', q);
          // Now show thinking animation for at least a short time
          const thinking = appendThinking();
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 800));
          
          try{
            const [resp] = await Promise.all([
              fetch(window.DTP.config.apiPath('ai/ask'), { method:'POST', credentials: 'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ query: q }) }),
              minThinkingTime
            ]);
            
            try{ thinking.remove(); }catch{}
            if (!resp.ok){ appendBubble('assistant', `HTTP ${resp.status}`); return; }
            const data = await resp.json().catch(()=>({ ok:false }));
            if (data && data.ok && data.answer){ appendBubble('assistant', data.answer); }
            else { appendBubble('assistant', 'Something went sideways ‚Äî I could not think of a good answer.'); }
          }catch(e){
            try{ thinking.remove(); }catch{}
            appendBubble('assistant', `Request failed: ${e.message}`); 
          }finally{
            askBtn.disabled = false; askBtn.textContent = 'Ask';
          }
        }

        async function onReindex(){
          reindexBtn.disabled = true; reindexBtn.textContent = 'Indexing‚Ä¶';
          try{
            const resp = await fetch(window.DTP.config.apiPath('ai/reindex'), { method:'POST', credentials: 'include', headers:{'Content-Type':'application/json'}, body: '{}' });
            const data = await resp.json().catch(()=>null);
            if (!resp.ok){ alert(`Reindex failed: ${(data&&data.error)||('HTTP '+resp.status)}`); }
            else { appendBubble('assistant', 'Knowledge index rebuilt ‚úÖ'); }
          } catch(e){ alert('Reindex error: '+e.message); }
          await refreshHealth();
          reindexBtn.disabled = false; reindexBtn.textContent = 'Reindex';
        }

        function appendBubble(who, text){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          
          // Add chat bubble titles with consistent avatar styling
          const titleEl = document.createElement('div');
          titleEl.className = 'bubble-title';
          if (who === 'user') {
            titleEl.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;"><span style="display:inline-flex;width:20px;height:20px;align-items:center;justify-content:center;background:var(--chip);border-radius:50%;font-size:12px;">üßë</span> You</span>';
          } else {
            titleEl.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;"><span style="display:inline-flex;width:20px;height:20px;align-items:center;justify-content:center;background:var(--chip);border-radius:50%;padding:2px;"><img src="/status/assets/calliope_heart_stethoscope.svg" alt="Calliope" style="width:100%;height:100%;"></span> Calliope</span>';
          }
          b.appendChild(titleEl);
          
          // Create content area
          const contentEl = document.createElement('div');
          contentEl.className = 'bubble-content';
          
          if (who === 'assistant'){
            try{
              const html = DOMPurify.sanitize(marked.parse(text || ''));
              contentEl.innerHTML = html;
            }catch{ contentEl.textContent = text; }
          } else {
            contentEl.textContent = text;
          }
          b.appendChild(contentEl);
          
          chatEl.appendChild(b);
          
          // Hide placeholder if this is the first user message
          if (who === 'user' && chatEl.children.length === 1) {
            queryEl.placeholder = '';
          }
          
          // Scroll behavior:
          // - For user messages, scroll to bottom so the sent message is visible
          // - For assistant replies, align the top of the new bubble to the top of the chat (if possible)
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }

        // Persona wrapper to enrich terse backend thoughts into friendly tone with expressive actions
        function personaWrap(text){
          try{
            let t = String(text||'');
            
            // Convert actions to emojis first (like the personality system I use!)
            const actionMap = {
              '*waves*': 'üëã', '*wave*': 'üëã', '*waving*': 'üëã',
              '*jumps excitedly*': 'ü§∏‚Äç‚ôÄÔ∏è', '*jumps up excitedly*': 'ü§∏‚Äç‚ôÄÔ∏è', 
              '*bounces*': 'üéâ', '*bounces happily*': 'üéâ',
              '*crosses fingers*': 'ü§û', '*fingers crossed*': 'ü§û',
              '*waves triumphantly*': 'üèÜ', '*triumph*': 'üèÜ', '*triumphant*': 'üèÜ',
              '*rolls up sleeves*': 'üí™', '*gets serious*': 'üò§', '*determined*': 'üò§',
              '*eyes light up*': '‚ú®', '*gasps*': 'üò∞', '*points*': 'üëâ', '*points excitedly*': 'üëâ',
              '*happy dance*': 'üíÉ', '*celebrates*': 'üéä', '*cheers*': 'üéä',
              '*examines*': 'üîç', '*investigates*': 'üïµÔ∏è‚Äç‚ôÄÔ∏è', '*detective mode*': 'üïµÔ∏è‚Äç‚ôÄÔ∏è',
              '*lightbulb moment*': 'üí°', '*aha*': 'üí°', '*eureka*': 'üí°',
              '*fist pump*': '‚úä', '*pumps fist*': '‚úä', '*victory lap*': 'üèÉ‚Äç‚ôÄÔ∏è',
              '*rubs hands together excitedly*': 'üí´', '*giggles*': 'üòä'
            };
            
            // Apply action-to-emoji conversions
            for (const [action, emoji] of Object.entries(actionMap)) {
              t = t.replace(new RegExp(action.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'), emoji);
            }
            
            // Enhanced expressive conversions for common backend messages
            if (/^Self-check completed/i.test(t)) return 'üî¨ Listening closely‚Ä¶ Self-check completed!';
            if (/^Audit\+heal loop complete/i.test(t)) return 'üéâ All done for now! Audit + heal loop complete.';
            if (/^Working/i.test(t)) return '‚ú® Working my magic‚Ä¶';
            if (/^Starting audit\+heal/i.test(t)) return 'ü©∫‚ú® Taking a peek and patching things up‚Ä¶';
            if (/^Applying subpath healing/i.test(t)) return 'üíñ Applying subpath healing‚Ä¶';
            if (/^Applying Storybook\/Vite proxy guards/i.test(t)) return 'üõ°Ô∏è Tending to Storybook/Vite proxy guards‚Ä¶';
            if (/^Audit did not complete/i.test(t)) return 'ü§î Hmm, my audit stumbled. I\'ll try a different angle.';
            if (/^Verification complete/i.test(t)) return '‚úÖ Verification complete!';
            if (/^Code review complete/i.test(t)) return '‚úÖ Code review complete!';
            if (/^Found.*issue/i.test(t)) return `üëâ ${t}`;
            if (/^Fixed|Repaired|Resolved/i.test(t)) return `üîß ${t}`;
            if (/^Success|Complete.*success/i.test(t)) return `üéâ ${t}`;
            if (/^Error|Failed|Problem/i.test(t)) return `üò∞ ${t}`;
            if (/^Testing|Checking/i.test(t)) return `üîç ${t}`;
            if (/^status$/i.test(t)) return '';
            
            return t;
          }catch{ return text; }
        }
        
        // Appends raw HTML content in a bubble (for complex elements like tables)
        function appendHTMLContent(who, html){
          const b = document.createElement('div');
          b.className = `bubble ${who}`;
          // Directly inject the HTML without markdown parsing
          b.innerHTML = DOMPurify.sanitize(html);
          chatEl.appendChild(b);
          // Scroll to show the new content
          if (who === 'user'){
            chatEl.scrollTop = chatEl.scrollHeight;
          } else {
            const y = Math.max(0, b.offsetTop - 6);
            chatEl.scrollTo({ top: y, behavior: 'smooth' });
          }
          return b;
        }

        function appendThinking(){
          const b = document.createElement('div');
          b.className = 'bubble assistant thinking';
          const span = document.createElement('span');
          span.className = 'dots';
          span.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
          b.appendChild(span);
          chatEl.appendChild(b);
          chatEl.scrollTop = chatEl.scrollHeight;
          return b;
        }

        function ensureAiOpen(){
          const drawer = document.getElementById('aiDrawer');
          if (drawer.classList.contains('collapsed')){
            drawer.classList.remove('collapsed');
            document.body.classList.add('ai-open');
          }
        }

        // Expose a stable, globally callable Self‚ÄëCheck routine to avoid race conditions
        async function greetAndSelfCheck(){
          ensureAiOpen();
          chatEngaged = true; hasUserMessage = true;
          // If there is already a thinking bubble, don't add another
          const alreadyThinking = !!document.querySelector('#aiChat .bubble.assistant.thinking');
          if (!alreadyThinking) appendBubble('assistant', 'Heya! One sec while I listen to /api/...');
          const thinking = alreadyThinking ? document.querySelector('#aiChat .bubble.assistant.thinking') : appendThinking();
          try{
            await fetch(window.DTP.config.apiPath('ai/self-check'), { method:'POST', credentials: 'include', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ heal:true }) });
          }catch{} finally{
            // Keep the thinking bubble visible until next assistant message arrives; do not auto-remove here
          }
        }
        try{
          window.CalliopeUI = Object.assign(window.CalliopeUI||{}, { greetAndSelfCheck });
          if (window.__pendingSelfCheck){
            setTimeout(()=>{ try{ window.CalliopeUI.greetAndSelfCheck(); window.__pendingSelfCheck=false; }catch{} }, 50);
          }
        }catch{}

        async function runCalliopeHealth(routeKey){
          try{
            if (window.__pendingDiagnoseRoute){ delete window.__pendingDiagnoseRoute; }
          }catch{}
          chatEngaged = true;
          ensureAiOpen();
          // First message - acknowledgment (append after recording engagement but before server work)
          appendBubble('assistant', `Heya! ‚ú® One sec while I listen to ${routeKey}‚Ä¶`);
          
          // Show thinking indicator briefly while we kick off background audit+heal
          let thinking = appendThinking();
          // Immediately reflect active state in the status chip
          try {
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            statusChip.classList.remove('status-ready','status-offline');
            statusChip.classList.add('status-auditing');
            labelEl.textContent = 'üî¨ Auditing';
          } catch {}
          const minThinkingTime = new Promise(resolve => setTimeout(resolve, 900));
          
          try{
            // Use container-reachable base; prefer ngrok origin if present, else dev-proxy
            const origin = window.location.origin || '';
            let baseForAudit = 'http://dev-proxy';
            try { const h = (new URL(origin)).hostname||''; if (/\.ngrok\.app$/i.test(h)) baseForAudit = origin; } catch {}
            const cleanRoute = routeKey.endsWith('/') ? routeKey : (routeKey + '/');
            const urlToAudit = (baseForAudit.replace(/\/$/, '')) + cleanRoute;
            const selfCheck = (async ()=>{
              try{
                await fetch(window.DTP.config.apiPath('ai/self-check'), {
                  method: 'POST',
                  credentials: 'include',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ heal: true, route: routeKey, hint: `Focus on route ${routeKey} and its children.` })
                });
              }catch{}
            })();
            const [resp] = await Promise.all([
              fetch(window.DTP.config.apiPath('ai/audit-and-heal'), {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: urlToAudit, route: routeKey, maxPasses: 3, wait: 1500, timeout: 45000 })
              }),
              minThinkingTime,
              selfCheck
            ]);
            thinking.remove();
            if (!resp.ok){
              const friendly = `\nI hit a little hiccup starting my check (HTTP ${resp.status}).\n`+
                `Here's what I'd try next:`+
                `\n- Click "Ask" with: 
\`Please audit and heal /sdk (and give yourself the Storybook/Vite knowledge you need).\``+
                `\n- Or open my thinking stream: <a href="/api/ai/thoughts" target="_blank" rel="noopener">/api/ai/thoughts</a>`;
              appendBubble('assistant', friendly);
              // reset chip back to ready so UI doesn't look stuck on Auditing
              try{
                const statusChip = document.getElementById('aiHealingStatus');
                const labelEl = document.getElementById('aiHealingStatusLabel');
                statusChip.classList.remove('status-auditing','status-healing','status-coding');
                statusChip.classList.add('status-ready');
                labelEl.textContent = 'üòä Happy';
              }catch{}
              return;
            }
            const data = await resp.json().catch(()=>null);
            if (data && data.ok){
              appendBubble('assistant', 'Working my magic‚Ä¶ I\'ll stream each step as it happens. ‚ú®');
            } else {
              const msg = (data && data.result && data.result.message) ? data.result.message : 'Couldn\'t proceed with audit+heal just now.';
              appendBubble('assistant', `‚ö†Ô∏è ${msg}`);
            }
            // Thoughts polling is active and will stream intermediate steps
          } catch(e){
            try { thinking.remove(); } catch{}
            const friendly = `\nOops, my ears got tangled while starting the check: ${e.message}.`+
              `\nTry asking: \`Audit and heal /sdk; add Storybook/Vite proxy guards and host allowances.\``+
              `\nPeek at my thoughts: <a href="/api/ai/thoughts" target="_blank" rel="noopener">/api/ai/thoughts</a>`;
            appendBubble('assistant', friendly);
            try{
              const statusChip = document.getElementById('aiHealingStatus');
              const labelEl = document.getElementById('aiHealingStatusLabel');
              statusChip.classList.remove('status-auditing','status-healing','status-coding');
              statusChip.classList.add('status-ready');
              labelEl.textContent = 'üòä Happy';
            }catch{}
          }
        }

        // Expose for inline handlers and external triggers
        try { window.runCalliopeHealth = runCalliopeHealth; } catch {}

        try{ askBtn && askBtn.addEventListener('click', onAsk); }catch{}
        try{ clearBtn && clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; if(queryEl){ queryEl.value=''; queryEl.focus(); } }); }catch{}
        try{ copyBtn && copyBtn.addEventListener('click', onCopy); }catch{}
        try{ queryEl && queryEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); } }); }catch{}
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        if (tab) {
          try {
            tab.addEventListener('click', ()=>{
          try{
            const isCollapsed = drawer.classList.contains('collapsed');
            if (isCollapsed){
              drawer.classList.remove('collapsed');
              document.body.classList.add('ai-open');
              // Save state
              try { localStorage.setItem('dtpCalliopeOpen', 'true'); } catch {}
              chatEngaged = true;
              try{ const chat=document.getElementById('aiChat'); if (chat && chat.children.length===0) appendBubble('assistant', 'Heya! ‚ú® One sec while I listen‚Ä¶'); }catch{}
              try{ const ask=document.getElementById('aiAskBtn'); if(ask && ask.scrollIntoView) ask.scrollIntoView({ block:'end' }); }catch{}
              setTimeout(()=>{ const q=document.getElementById('aiQuery'); if(q) q.focus(); }, 50);
            } else {
              drawer.classList.add('collapsed');
              document.body.classList.remove('ai-open');
              // Save state
              try { localStorage.setItem('dtpCalliopeOpen', 'false'); } catch {}
            }
            // Update button state
            const nowOpen = !drawer.classList.contains('collapsed');
            tab.classList.toggle('active', nowOpen);
            tab.setAttribute('aria-pressed', String(nowOpen));
            tab.setAttribute('title', nowOpen ? 'Close Calliope' : 'Open Calliope');
          }catch{}
            });
          } catch (e) {
            console.error('Error attaching click handler:', e);
          }
        }
        askBtn.addEventListener('click', onAsk);
        clearBtn.addEventListener('click', ()=>{ chatEl.innerHTML=''; queryEl.value=''; queryEl.focus(); });
        copyBtn.addEventListener('click', onCopy);
        queryEl.addEventListener('keydown', (e)=>{
          if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onAsk(); }
        });
        
        // Copy conversation to clipboard
        async function onCopy(){
          const bubbles = chatEl.querySelectorAll('.bubble');
          let conversation = '';
          bubbles.forEach(bubble => {
            const title = bubble.querySelector('.bubble-title')?.textContent || '';
            const content = bubble.querySelector('.bubble-content')?.textContent || bubble.textContent;
            conversation += `${title}\n${content}\n\n`;
          });
          
          try {
            await navigator.clipboard.writeText(conversation);
            copyBtn.textContent = 'Copied!';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          } catch (err) {
            console.error('Failed to copy:', err);
            copyBtn.textContent = 'Failed';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 2000);
          }
        }
        
        // Restore Calliope state from localStorage
        try {
          const wasOpen = localStorage.getItem('dtpCalliopeOpen') === 'true';
          if (wasOpen && drawer.classList.contains('collapsed')) {
            drawer.classList.remove('collapsed');
            document.body.classList.add('ai-open');
            // Update button states
            const btns = document.querySelectorAll('#calliopeOpen');
            btns.forEach((btn) => {
              btn.classList.add('active');
              btn.setAttribute('aria-pressed', 'true');
              btn.setAttribute('title', 'Close Calliope');
            });
            // Position drawer correctly
            setTimeout(() => {
              const headers = document.querySelectorAll('header');
              let header = null;
              for (const h of headers) {
                const style = getComputedStyle(h);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                  header = h;
                  break;
                }
              }
              const topGap = 16;
              const h = (header && header.offsetHeight) ? header.offsetHeight : 72;
              const top = h + topGap;
              drawer.style.top = top + 'px';
              drawer.style.height = `calc(100vh - ${top + topGap}px)`;
            }, 100);
          }
        } catch {}

        // Healing UI handlers
        // Drawer Self‚ÄëCheck uses lightweight self‚Äëcheck flow (not advanced-heal)
        
        if (healingBadgeEl) healingBadgeEl.addEventListener('click', (e) => {
          e.stopPropagation();
          healingHistoryEl && healingHistoryEl.classList.toggle('visible');
          try{
            const recent5 = [...healingHistory].reverse().slice(0,5);
            if (recent5.length){
              const lines = recent5.map((h)=>{
                const when = h.timestamp ? new Date(h.timestamp).toLocaleString() : '‚Äî';
                const route = h.route || h.issue || 'unknown';
                const outcome = h.success ? '‚úÖ' : '‚ùå';
                const steps = (h.actions && h.actions.length) ? ` ‚Äî steps: ${h.actions.join(', ')}` : '';
                return `${when} ‚Ä¢ ${route} ${outcome}${steps}`;
              }).join('\n');
              appendBubble('assistant', `**Recent healing summaries (latest 5)**\n\n${lines}`);
            } else {
              appendBubble('assistant', 'No healing history available yet.');
            }
          }catch{}
        });
        
        if (closeHistoryBtn) closeHistoryBtn.addEventListener('click', () => {
          healingHistoryEl && healingHistoryEl.classList.remove('visible');
        });
        
        // Initialize healing history
        try {
          await loadHealingHistory();
        } catch (e) {
          console.log('Error loading healing history', e);
        }
        
        // Hide healing status initially if empty
        const aiHealingStatus = document.getElementById('aiHealingStatus');
        try{ if (healingHistory.length === 0 && aiHealingStatus) aiHealingStatus.style.display = 'none'; }catch{}
        
        // Expose minimal debug helpers
        window.__calliopeDebug = {
          setStatus: (s)=>{
            const statusChip = document.getElementById('aiHealingStatus');
            const labelEl = document.getElementById('aiHealingStatusLabel');
            const map = { ready:['status-ready','üòä Happy'], healing:['status-healing','üíñ Healing'], auditing:['status-auditing','üî¨ Auditing'], coding:['status-coding','üõ†Ô∏è Coding'], offline:['status-offline','ü´• AFK'] };
            const m = map[(s||'').toLowerCase()]||map.ready;
            statusChip.className = 'ai-healing-status ' + m[0];
            labelEl.textContent = m[1];
          },
          pingThought:(m)=>fetch(window.DTP.config.apiPath('ai/thoughts/clear'), {method:'POST', credentials: 'include'}).then(()=>appendBubble('assistant', m||'debug thought'))
        };

        // Load persisted chat first, then current health, then begin thoughts polling
        try{
          const wantPersist = (localStorage.getItem('calliopePersistChat') === '1');
          if (wantPersist){ await loadChatHistory(); }
          else { chatEl.innerHTML = ''; }
        }catch{ /* default: no persisted chat during normal/status tests */ }
        await refreshHealth();
        initNotificationsServiceCard(); // Initialize notifications service card
        startThoughtsPolling();
        startHealthPolling();

        // Allow user to stop current work by clicking the status chip
        const statusChip = document.getElementById('aiHealingStatus');
        statusChip.addEventListener('click', async ()=>{
          try{
            const r = await fetch(window.DTP.config.apiPath('ai/cancel'), { method:'POST' });
            if (r.ok){
              appendBubble('assistant', "Oops, I\'ll pause now ‚Äî my hyper‚Äëfocus ran away with me! üí´ I\'ve stopped and I\'m ready to help however you like next.");
            }
          }catch{}
        });

        // Wire global diagnose button to focus the first SDK group or fallback to /sdk
        const bindDiag = (el)=>{
          if (!el) return;
          el.addEventListener('click', (e)=>{
            e.preventDefault(); e.stopPropagation();
            // Try to find a route named /sdk first
            const sdkChip = document.querySelector('[data-route="/sdk"]') || document.querySelector('.route-name');
            const route = sdkChip && (sdkChip.getAttribute && sdkChip.getAttribute('data-route')) || null;
            if (route) runCalliopeHealth(route);
          });
        };
        // legacy buttons removed
      }

    </script>
  </body>
  </html>


